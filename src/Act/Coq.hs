{-
 -
 - coq backend for act
 -
 - unsupported features:
 - + bytestrings
 - + external storage
 - + casting from addresses to contract
 -
 -}

{-# Language OverloadedStrings #-}
{-# Language RecordWildCards #-}
{-# LANGUAGE GADTs #-}
{-# Language DataKinds #-}
{-# Language ViewPatterns #-}


module Act.Coq where

import Prelude hiding (GT, LT)

import Data.Map.Strict (Map)
import Data.Tuple.Extra
import qualified Data.Map.Strict    as M
import qualified Data.List.NonEmpty as NE
import qualified Data.Text          as T
import Data.List (groupBy)
import Control.Monad.State

import EVM.ABI
import Act.Syntax
import Act.Syntax.TypedExplicit
import Act.Syntax.Timing (Time(..), Timing(..))

type Fresh = State Int

header :: T.Text
header = T.unlines
  [ "(* --- GENERATED BY ACT --- *)\n"
  , "Require Import Stdlib.ZArith.ZArith."
  , "Require Import ActLib.ActLib."
  , "Require Stdlib.Strings.String.\n"
  , "Module " <> strMod <> " := Stdlib.Strings.String."
  , "Open Scope Z_scope.\n"
  ]

-- | produce a coq representation of a specification
coq :: Act -> T.Text
coq (Act store contracts) =
  header <> (T.intercalate "\n\n" $ contractCode store <$> contracts)

contractCode :: Store -> Contract -> T.Text
contractCode store (Contract ctor@Constructor{..} behvs) = T.unlines $
  [ "Module " <> T.pack _cname <> ".\n" ]
  <> [ stateRecord ]
  <> [ base store ctor ]
  <> [ initPrecs ctor ]
  <> (filter ((/=) "") [ postCondConstr ctor ])
  <> [ invariants ctor ]
  <> (concatMap (evalSeq behvConds) (groups behvs))
  <> (concatMap (evalSeq (transition store)) (groups behvs))
  <> (filter ((/=) "") $ concatMap (evalSeq retVal) (groups behvs))
  <> (filter ((/=) "") $ concatMap (evalSeq postCondBehv) (groups behvs))
  <> [ step (groups behvs)]
  <> [ initState ctor ]
  <> [ multistep ]
  <> [ reachable ]
  <> [ reachableFromInit ctor]
  <> [ invariantInit ctor ]
  <> [ invariantStep ctor ]
  <> [ invariantReachable ctor]
  <> [ "End " <> T.pack _cname <> "." ]
  where
    groups = groupBy (\b b' -> _name b == _name b')

    stateRecord = T.unlines

      [ "Record" <+> stateType <+> ": Set :=" <+> stateConstructor
      , "{" <+> T.intercalate ("\n" <> "; ") (map decl (M.toList store'))
      , "}."
      ]

    decl (n, (s, _)) = (T.pack n) <+> ":" <+> slotType s

    store' = contractStore _cname store

-- | inductive definition of step relation of 2 states
step :: [[Behaviour]] -> T.Text
step behvs = inductive
  stepType "" (stateType <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = concat (evalSeq stepBehv <$> behvs)

    -- | constructor for the step relation
    stepBehv :: Behaviour -> Fresh (T.Text, Maybe T.Text, T.Text)
    stepBehv (Behaviour name _ i _ _ _ _ _ _) =
      fresh name >>= continuation where
      continuation name' =
        return (name' <> stepSuffix, Just $ envDecl <+> interface i <+> stateDecl, constructorBody)
        where
          constructorBody = (indent 2) . implication $
            [ name' <> "_conds" <+> envVar <+> arguments i <+> stateVar
            , stepType <+> stateVar <+> parens (name' <+> envVar <+> stateVar <+> arguments i)]


-- | definition of reachable states
reachable :: T.Text
reachable = definition
  reachableType args value
  where
    args = parens $ stateVar <+> ":" <+> stateType
    value = "exists" <+> stateVar' <> "," <+> initStateType <+> stateVar'
      <+> "/\\" <+> multistepType <+> stateVar' <+> stateVar

-- | specialization of generic multistep
multistep :: T.Text
multistep = definition
  multistepType args value
  where
    args = parens $ stateVar <+> stateVar' <+> ":" <+> stateType
    value = multistepType <+> stepType <+> stateVar <+> stateVar'

-- | definition of reachable states from initial constructor parameters
reachableFromInit :: Constructor -> T.Text
reachableFromInit (Constructor name i _ _ _ _ _ ) = definition
  reachableFromInitType args value
  where
    args = envDecl <+> interface i <+> stateDecl
    value = initPrecsType <+>
      envVar <+> arguments i <+> "/\\" <+> multistepType <+>
      parens (T.pack name <+> envVar <+> arguments i) <+> stateVar

-- | definition of constructor preconditions
initPrecs :: Constructor -> T.Text
initPrecs (Constructor _ i _ conds _ _ _ ) = definition
  initPrecsType (envDecl <+> interface i) body
  where
    body = indent 2 . conjuction . concat $ [coqprop <$> conds]

-- | definition of behaviour-case conditions
behvConds :: Behaviour -> Fresh T.Text
behvConds (Behaviour name _ i _ conds casecs _ _ _) = do
  name' <- fresh name
  pure $ definition
    (name' <> "_conds") (envDecl <+> interface i <+> stateDecl) body
  where
    body = (indent 2) (conjuction . concat $ [coqprop <$> (conds <> casecs)])

-- | predicate characterizing all initial (post constructor) states
initState :: Constructor -> T.Text
initState (Constructor name i _ _ _ _ _ ) = inductive
  initStateType "" (stateType <> " -> " <> " Prop") [("InitState", Just $ envDecl <+> interface i, constructorBody)]
  where
    baseval = parens $ T.pack name <+> envVar <+> arguments i
    constructorBody = (indent 2) . implication . concat $
      [ [initPrecsType <+> envVar <+> arguments i]
      , [initStateType <+> baseval]
      ]

-- | definition of a base state
base :: Store -> Constructor -> T.Text
base store (Constructor name i _ _ _ _ updates) =
  definition (T.pack name) (envDecl <+> interface i) $
    stateval store name (\_ t -> defaultSlotValue t) updates

transition :: Store -> Behaviour -> Fresh T.Text
transition store (Behaviour name cname i _ _ _ _ rewrites _) = do
  name' <- fresh name
  return $ definition name' (envDecl <+> stateDecl <+> interface i) $
    stateval store cname (\r _ -> ref Pre r) rewrites

-- | inductive definition of a return claim
-- ignores claims that do not specify a return value
retVal :: Behaviour -> Fresh T.Text
retVal (Behaviour name _ i _ conds cases _ _ (Just r)) =
  fresh name >>= continuation where
  continuation name' = return $ inductive
    (name' <> returnSuffix)
    (envDecl <+> stateDecl <+> interface i)
    (returnType r <> " -> Prop")
    [(retname <> introSuffix, Nothing, body)] where

    retname = name' <> returnSuffix
    body = indent 2 . implication . concat $
      [ coqprop <$> conds ++ cases
      , [retname <+> envVar <+> stateVar <+> arguments i <+> typedexp r]
      ]

retVal _ = return ""

-- | Definition of postcondition claim for constructor
postCondConstr :: Constructor -> T.Text
postCondConstr (Constructor _ _ _ _ [] _ _) = ""
postCondConstr (Constructor name i _ _ postcs _ _) =
  T.intercalate "\n\n" $ evalSeq post postcs
    where
    post :: Exp ABoolean -> Fresh T.Text
    post pc =
      fresh (name <> T.unpack postSuffix) >>= continuation where
      continuation postName = return $ definition postName "" body
      body = indent 2 $ T.unlines
        [ forAll $ envDecl <+> interface i <+> stateDecl'
        , implication . concat $
          [ [initPrecsType <+> envVar <+> arguments i]
          , [stateVar' <+> "=" <+> T.pack name <+> envVar <+> arguments i]
          , [coqprop pc]
          ]
        ]

-- | Definition of postcondition claim for behaviour cases
postCondBehv :: Behaviour -> Fresh T.Text
postCondBehv (Behaviour _ _ _ _ _ _ [] _ _) = return ""
postCondBehv (Behaviour name _ i _ _ _ postcs _ _) =
  fresh name >>= continuation where
  continuation name' = return $ T.intercalate "\n\n" $ evalSeq (post name') postcs
    where
      post :: T.Text -> Exp ABoolean -> Fresh T.Text
      post case_name pc =
        fresh (T.unpack $ case_name <> postSuffix) >>= continuation' where
        continuation' postName = return $ definition postName "" body
        body = indent 2 $ T.unlines
          [ forAll $ envDecl <+> stateDecl <+> stateDecl' <+> interface i
          , implication . concat $
            [ [name' <> "_conds" <+> envVar <+> arguments i <+> stateVar]
            , [stateVar' <+> "=" <+> name' <+> envVar <+> stateVar <+> arguments i]
            , [coqprop pc]
            ]
          ]

-- | Definition of invariant proposition
invariants :: Constructor -> T.Text
invariants (Constructor _ _ _ _ _ [] _) = ""
invariants (Constructor _ i _ _ _ invs _) =
  definition "invariants" (envDecl <+> interface i <+> stateDecl) $ indent 2 . conjuction $ invariantProp <$> invs
  where
    invariantProp :: Invariant -> T.Text
    invariantProp (Invariant _ _ _ (PredTimed p _)) = coqprop p


-- | Definition of invariant claim at constructor poststate
invariantInit :: Constructor -> T.Text
invariantInit (Constructor name i _ _ _ _ _) =
  definition invInitType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [invPropVar <+> envVar <+> arguments i <+> parens (T.pack name <+> envVar <+> arguments i)]
        ]
      ]

-- | Definition of invariant claim for behaviour cases
invariantStep :: Constructor -> T.Text
invariantStep (Constructor _ i _ _ _ _ _) =
  definition invStepType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i <+> stateDecl <+> stateDecl'
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [stepType <+> stateVar <+> stateVar']
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar']
        ]
      ]

-- | Lemma extending invariant properties' hold to reachable states,
-- given proof of init and step invariance
invariantReachable :: Constructor -> T.Text
invariantReachable (Constructor _ i _ _ _ _ _) =
  lemma invReachType "" claim proof
  where
    claim = indent 2 $ T.unlines
      [ forAll (envDecl <+> interface i <+> stateDecl <+> invPropDecl i
        <+> parens ("HIPinvInit :" <+> invInitType <+> invPropVar) <+> parens ("HIPinvStep :" <+> invStepType <+> invPropVar))
      , implication . concat $
        [ [reachableFromInitType <+> envVar <+> arguments i <+> stateDecl]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        ]
      ]
    proof = T.unlines $
      [
        "Proof."
      , indent 2 . T.unlines $
        [ "intros" <+> envVar <+> arguments i <+> stateVar <+> invPropVar <+> "HIPinvInit HIPinvStep Hreach."
        , "unfold reachableFromInit in Hreach."
        , "destruct Hreach as [Hinit Hmulti]."
        , "apply step_multi_step with (P := fun s s' =>" <+> invPropVar <+> envVar <+> arguments i <+> "s ->" <+> invPropVar <+> envVar <+> arguments i <+> "s' ) in Hmulti."
        , "- apply Hmulti."
        , "  apply HIPinvInit; assumption."
        , "- intros s s' Hstep."
        , "  apply HIPinvStep with (STATE := s) (STATE' := s') ; assumption."
        , "- unfold Relation_Definitions.reflexive."
        , "  intros."
        , "  assumption."
        , "- unfold Relation_Definitions.transitive."
        , "  intros s1 s2 s3 Ht1 Ht2 Ht3."
        , "  apply Ht2, Ht1."
        , "  assumption."
        ]
     , "Qed."
     ]

-- | produce a state value from a list of storage updates
-- 'handler' defines what to do in cases where a given name isn't updated
stateval :: Store -> Id -> (Ref Storage -> SlotType -> T.Text) -> [StorageUpdate] -> T.Text
stateval store contract handler updates = T.unwords $
  stateConstructor : fmap (\(n, (t, _)) -> updateVar store updates handler (SVar nowhere contract n) t) (M.toList store')
  where
    store' = contractStore contract store

contractStore :: Id -> Store -> Map Id (SlotType, Integer)
contractStore contract store = case M.lookup contract store of
  Just s -> s
  Nothing -> error "Internal error: cannot find constructor in store"


-- | Check is an update update a specific storage reference
eqRef :: Ref Storage -> StorageUpdate -> Bool
eqRef r (Update _ (Item _ r') _) = r == r'

-- | Check if an update updates a location that has a given storage
-- reference as a base
baseRef :: Ref Storage -> StorageUpdate -> Bool
baseRef baseref (Update _ (Item _ r) _) = hasBase r
  where
    hasBase (SVar _ _ _) = False
    hasBase (SArray _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SMapping _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SField _ r' _ _) = r' == baseref || hasBase r'


updateVar :: Store -> [StorageUpdate] -> (Ref Storage -> SlotType -> T.Text) -> Ref Storage -> SlotType -> T.Text
updateVar store updates handler focus t@(StorageValue (ValueType (TContract cid))) =
  case (constructorUpdates, fieldUpdates) of
    -- Only some fields are updated
    ([], updates'@(_:_)) -> parens $ T.unwords $ (T.pack cid <> "." <> stateConstructor) : fmap (\(n, (t', _)) -> updateVar store  updates' handler (focus' n) t') (M.toList store')
    -- No fields are updated, whole contract may be updated with some call to the constructor
    (updates', []) -> foldl (\ _ (Update _ _ e) -> coqexp e) (handler focus t) updates'
    -- The contract is updated with constructor call and field accessing. Unsupported.
    (_:_, _:_) -> error "Cannot handle multiple updates to contract variable"
  where
    focus' x = SField nowhere focus cid x
    store' = contractStore cid store

    fieldUpdates = filter (baseRef focus) updates
    constructorUpdates = filter (eqRef focus) updates

updateVar _ updates handler focus t@(StorageValue _) =
  foldl updatedVal (handler focus t) (filter (eqRef focus) updates)
    where
      updatedVal _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = coqexp e

updateVar _ updates handler focus t@(StorageMapping xs _) = parens $
  lambda n <+> foldl updatedMap prestate (filter (baseRef focus) updates)
    where
      prestate = parens $ handler focus t <+> lambdaArgs n
      n = length xs

      updatedMap _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedMap prestate' (Update _ item e) =
        let ixs = ixsFromItem item in
        "if" <+> boolScope (T.intercalate " && " (map cond (zip ixs ([0..] :: [Int]))))
        <+> "then" <+> coqexp e
        <+> "else" <+> prestate'

      cond (TExp argType arg, i) = parens $ anon <> T.pack (show i) <> eqsym argType <> coqexp arg

      lambda i = if i >= 0 then "fun" <+> lambdaArgs i <+> "=>" else ""

      lambdaArgs i = T.unwords $ map (\a -> anon <> T.pack (show a)) ([0..i-1] :: [Int])

      eqsym :: TValueType a -> T.Text
      eqsym argType = case argType of
        TInteger _ _ -> "=?"
        TAddress -> "=?"
        TBoolean -> "=??"
        TByteStr -> error "bytestrings not supported"
        TArray _ _ -> error "arrays not supported"
        TStruct _ -> error "structs not supported"
        TContract _ -> error "contracts not supported" --TODO


-- | produce a block of declarations from an interface
interface :: Interface -> T.Text
interface (Interface _ decls) =
  T.unwords $ map decl decls where
  decl (Decl t name) = parens $ T.pack name <+> ":" <+> abiType t

arguments :: Interface -> T.Text
arguments (Interface _ decls) =
  T.unwords $ map (\(Decl _ name) -> T.pack name) decls

-- | coq syntax for a slot type
slotType :: SlotType -> T.Text
slotType (StorageMapping xs t) =
  T.intercalate " -> " (map valueType (NE.toList xs ++ [t]))
slotType (StorageValue val) = valueType val

valueType :: ValueType -> T.Text
valueType (ValueType (TContract cid)) = T.pack cid <> "." <> "State" -- the type of a contract is its state record
valueType (ValueType t) = abiType $ toAbiType t

-- | coq syntax for an abi type
abiType :: AbiType -> T.Text
abiType (AbiUIntType _) = "Z"
abiType (AbiIntType _) = "Z"
abiType AbiAddressType = "address"
abiType AbiStringType = strMod <> ".string"
abiType a = error $ show a

-- | coq syntax for a return type
returnType :: TypedExp -> T.Text
returnType (TExp (TInteger _ _) _) = "Z"
returnType (TExp TAddress _) = "Z"
returnType (TExp TBoolean _) = "bool"
returnType (TExp TByteStr _) = error "bytestrings not supported"
returnType (TExp (TStruct _) _) = error "structs not supported"
returnType (TExp (TContract _) _) = error "contracts not allowed as return types"
returnType (TExp (TArray _ _) _) = error "arrays not supported"

-- | default value for a given type
-- this is used in cases where a value is not set in the constructor
defaultSlotValue :: SlotType -> T.Text
defaultSlotValue (StorageMapping xs t) = parens $
  "fun"
  <+> T.unwords (replicate (length (NE.toList xs)) "_")
  <+> "=>"
  <+> defaultVal t
defaultSlotValue (StorageValue t) = defaultVal t

defaultVal :: ValueType -> T.Text
defaultVal (ValueType (TContract _)) = error "Contracts must be explicitly initialized"
defaultVal (ValueType t) = abiVal $ toAbiType t

abiVal :: AbiType -> T.Text
abiVal (AbiUIntType _) = "0"
abiVal (AbiIntType _) = "0"
abiVal AbiAddressType = "0"
abiVal AbiStringType = strMod <> ".EmptyString"
abiVal _ = error "TODO: missing default values"

-- | coq syntax for an expression
coqexp :: Exp a -> T.Text
-- booleans
coqexp (LitBool _ True)  = "true"
coqexp (LitBool _ False) = "false"
coqexp (And _ e1 e2)  = parens $ "andb"    <+> coqexp e1 <+> coqexp e2
coqexp (Or _ e1 e2)   = parens $ "orb"     <+> coqexp e1 <+> coqexp e2
coqexp (Impl _ e1 e2) = parens $ "implb"   <+> coqexp e1 <+> coqexp e2
coqexp (Eq _ _ e1 e2)   = parens $ coqexp e1  <+> "=?" <+> coqexp e2
coqexp (NEq _ _ e1 e2)  = parens $ "negb" <+> parens (coqexp e1  <+> "=?" <+> coqexp e2)
coqexp (Neg _ e)      = parens $ "negb" <+> coqexp e
coqexp (LT _ e1 e2)   = parens $ coqexp e1 <+> "<?"  <+> coqexp e2
coqexp (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=?" <+> coqexp e2
coqexp (GT _ e1 e2)   = parens $ coqexp e2 <+> "<?"  <+> coqexp e1
coqexp (GEQ _ e1 e2)  = parens $ coqexp e2 <+> "<=?" <+> coqexp e1

-- integers
coqexp (LitInt _ i) = T.pack $ show i
coqexp (Add _ e1 e2) = parens $ coqexp e1 <+> "+" <+> coqexp e2
coqexp (Sub _ e1 e2) = parens $ coqexp e1 <+> "-" <+> coqexp e2
coqexp (Mul _ e1 e2) = parens $ coqexp e1 <+> "*" <+> coqexp e2
coqexp (Div _ e1 e2) = parens $ coqexp e1 <+> "/" <+> coqexp e2
coqexp (Mod _ e1 e2) = parens $ "Z.modulo" <+> coqexp e1 <+> coqexp e2
coqexp (Exp _ e1 e2) = parens $ coqexp e1 <+> "^" <+> coqexp e2
coqexp (IntMin _ n)  = parens $ "INT_MIN"  <+> T.pack (show n)
coqexp (IntMax _ n)  = parens $ "INT_MAX"  <+> T.pack (show n)
coqexp (UIntMin _ n) = parens $ "UINT_MIN" <+> T.pack (show n)
coqexp (UIntMax _ n) = parens $ "UINT_MAX" <+> T.pack (show n)

coqexp (InRange _ vt e) = coqexp (bound vt e)

-- polymorphic
coqexp (VarRef _ whn _ e) = entry whn e
coqexp (ITE _ b e1 e2) = parens $ "if"
                               <+> coqexp b
                               <+> "then"
                               <+> coqexp e1
                               <+> "else"
                               <+> coqexp e2

-- environment values
-- Relies on the assumption that Coq record fields have the same name
-- as the corresponding Haskell constructor
coqexp (IntEnv _ envVal) = parens $ T.pack (show envVal) <+> envVar
-- Contracts
coqexp (Create _ cid args) = parens $ T.pack cid <> "." <> T.pack cid <+> envVar <+> coqargs args
-- unsupported
coqexp Cat {} = error "bytestrings not supported"
coqexp Slice {} = error "bytestrings not supported"
coqexp ByStr {} = error "bytestrings not supported"
coqexp ByLit {} = error "bytestrings not supported"
coqexp ByEnv {} = error "bytestrings not supported"
coqexp Array {} = error "arrays not supported"

-- | coq syntax for a proposition
coqprop :: Exp a -> T.Text
coqprop (LitBool _ True)  = "True"
coqprop (LitBool _ False) = "False"
coqprop (And _ e1 e2)  = parens $ coqprop e1 <+> "/\\" <+> coqprop e2
coqprop (Or _ e1 e2)   = parens $ coqprop e1 <+> "\\/" <+> coqprop e2
coqprop (Impl _ e1 e2) = parens $ coqprop e1 <+> "->"  <+> coqprop e2
coqprop (Neg _ e)      = parens $ "not" <+> coqprop e
coqprop (Eq _ _ e1 e2)   = parens $ coqexp e1 <+> "="  <+> coqexp e2
coqprop (NEq _ _ e1 e2)  = parens $ coqexp e1 <+> "<>" <+> coqexp e2
coqprop (LT _ e1 e2)   = parens $ coqexp e1 <+> "<"  <+> coqexp e2
coqprop (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=" <+> coqexp e2
coqprop (GT _ e1 e2)   = parens $ coqexp e1 <+> ">"  <+> coqexp e2
coqprop (GEQ _ e1 e2)  = parens $ coqexp e1 <+> ">=" <+> coqexp e2
coqprop (InRange _ t e) = coqprop (bound t e)

coqprop e = error "ill formed proposition:" <+> T.pack (show e)

-- | coq syntax for a typed expression
typedexp :: TypedExp -> T.Text
typedexp (TExp _ e) = coqexp e

entry :: Time 'Timed -> TItem k a -> T.Text
entry _ (Item TByteStr _) = error "bytestrings not supported"
entry whn (Item _ r) = ref whn r

ref :: Time 'Timed -> Ref k -> T.Text
ref Pre (SVar _ _ name) = parens $ T.pack name <+> stateVar
ref Post (SVar _ _ name) = parens $ T.pack name <+> stateVar'
ref _ (CVar _ _ name) = T.pack name
ref whn (SArray _ r _ ixs) = parens $ ref whn r <+> coqargs (fst <$> ixs)
ref whn (SMapping _ r _ ixs) = parens $ ref whn r <+> coqargs ixs
ref whn (SField _ r cid name) = parens $ T.pack cid <> "." <> T.pack name <+> ref whn r

-- | coq syntax for a list of arguments
coqargs :: [TypedExp] -> T.Text
coqargs es = T.unwords (map typedexp es)

fresh :: Id -> Fresh T.Text
fresh name = state $ \s -> (T.pack (name <> show s), s + 1)

evalSeq :: Traversable t => (a -> Fresh b) -> t a -> t b
evalSeq f xs = evalState (sequence (f <$> xs)) 0

--- text manipulation ---

definition :: T.Text -> T.Text -> T.Text -> T.Text
definition name args value = T.unlines
  [ "Definition" <+> name <+> args <+> ":="
  , value <> "."
  ]

inductive :: T.Text -> T.Text -> T.Text -> [(T.Text, Maybe T.Text, T.Text)] -> T.Text
inductive name args indices constructors = T.unlines
  [ "Inductive" <+> name <+> args <+> ":" <+> indices <+> ":="
  , T.unlines (((<>) "| " . uncurry3 inductiveConstructor) <$> constructors) <> "."
  ]

inductiveConstructor :: T.Text -> Maybe T.Text -> T.Text -> T.Text
inductiveConstructor ctorName Nothing body =
     ctorName <+> ":\n" <> body
inductiveConstructor ctorName (Just bindings) body =
     ctorName <+> ":" <+> forAll bindings <> "\n" <> body

lemma :: T.Text -> T.Text -> T.Text -> T.Text -> T.Text
lemma name args claim proof = T.unlines
  [ "Lemma" <+> name <+> args <+> ":"
  , claim <> "."
  , proof
  ]


-- | forall bindings
forAll :: T.Text -> T.Text
forAll bindings = "forall" <+> bindings <> ","

-- | multiline implication
implication :: [T.Text] -> T.Text
implication xs = "   " <> T.intercalate "\n-> " xs

-- | multiline conjuction
conjuction :: [T.Text] -> T.Text
conjuction [] = "   True"
conjuction xs = "   " <> T.intercalate "\n/\\ " xs

-- | wrap text in parentheses
parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

boolScope :: T.Text -> T.Text
boolScope s = "(" <> s <> ")%bool"

indent :: Int -> T.Text -> T.Text
indent n = T.unlines . fmap (T.replicate n " " <>) . T.lines

(<+>) :: T.Text -> T.Text -> T.Text
"" <+> t2 = t2
t1 <+> "" = t1
t1 <+> t2 = t1 <> " " <> t2

--- constants ---

-- | string module name
strMod :: T.Text
strMod  = "Str"

-- | base state name
baseVar :: T.Text
baseVar = "BASE"

stateType :: T.Text
stateType = "State"

stateVar :: T.Text
stateVar = "STATE"

stateVar' :: T.Text
stateVar' = "STATE'"

nextVar :: T.Text
nextVar = "NEXT"

stateDecl :: T.Text
stateDecl = parens $ stateVar <+> ":" <+> stateType

stateDecl' :: T.Text
stateDecl' = parens $ stateVar' <+> ":" <+> stateType

stateConstructor :: T.Text
stateConstructor = "state"

returnSuffix :: T.Text
returnSuffix = "_ret"

postSuffix :: T.Text
postSuffix = "_post"

invInitType :: T.Text
invInitType  = "invariantInit"

invStepType :: T.Text
invStepType  = "invariantStep"

invReachType :: T.Text
invReachType  = "invariantReachable"

baseSuffix :: T.Text
baseSuffix = "_base"

stepSuffix :: T.Text
stepSuffix = "_step"

introSuffix :: T.Text
introSuffix = "_intro"

stepType :: T.Text
stepType = "step"

initStateType :: T.Text
initStateType = "init"

invPropVar :: T.Text
invPropVar = "IP"

invPropType :: Interface -> T.Text
invPropType (Interface _ decls) = T.intercalate " -> " $ concat [[envType], map (\(Decl t _) -> abiType t) decls, [stateType, "Prop"]]

invPropDecl :: Interface -> T.Text
invPropDecl i = parens $ invPropVar <+> ":" <+> invPropType i

initPrecsType :: T.Text
initPrecsType = "initPreconds"

behvPrecsType :: T.Text
behvPrecsType = "behvPrecs"

multistepType :: T.Text
multistepType = "multistep"

reachableType :: T.Text
reachableType = "reachable"

reachableFromInitType :: T.Text
reachableFromInitType = "reachableFromInit"

reachStep:: T.Text
reachStep= "reach_step"

envType :: T.Text
envType = "Env"

envVar :: T.Text
envVar = "ENV"

envDecl :: T.Text
envDecl = parens $ envVar <+> ":" <+> envType

anon :: T.Text
anon = "_binding_"
