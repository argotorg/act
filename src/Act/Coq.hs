{-
 -
 - coq backend for act
 -
 - unsupported features:
 - + bytestrings
 - + external storage
 - + casting from addresses to contract
 -
 -}

{-# Language OverloadedStrings #-}
{-# Language RecordWildCards #-}
{-# LANGUAGE GADTs #-}
{-# Language DataKinds #-}


module Act.Coq where

import Prelude hiding (GT, LT)

import Data.Map.Strict (Map)
import Data.Maybe
import Data.Tuple.Extra
import qualified Data.Map.Strict    as M
import qualified Data.List.NonEmpty as NE
import qualified Data.Text          as T
import Data.List (groupBy)
import Data.List.Extra (snoc, unsnoc)
import Control.Monad.State

import EVM.ABI
import Act.Syntax
import Act.Syntax.TypedExplicit
import Act.Syntax.Timing (Time(..), Timing(..))

type Fresh = State Int

header :: T.Text
header = T.unlines
  [ "(* --- GENERATED BY ACT --- *)\n"
  , "Require Import Stdlib.ZArith.ZArith."
  , "Require Import ActLib.ActLib."
  , "Require Stdlib.Strings.String.\n"
  , "Module " <> strMod <> " := Stdlib.Strings.String."
  , "Open Scope Z_scope.\n"
  ]

-- | produce a coq representation of a specification
coq :: Act -> T.Text
coq (Act store contracts) =
  header <> (T.intercalate "\n\n" $ contractCode store <$> contracts)

contractCode :: Store -> Contract -> T.Text
contractCode store (Contract ctor@Constructor{..} behvs) = T.unlines $
  [ "Module " <> T.pack _cname <> ".\n" ]
  <> [ stateRecord ]
  <> [ addressIn _cname store ]
  <> [ noAliasing _cname store ]
  <> [ envStateConstraint ]
  <> [ base store ctor ]
  <> [ initPrecs ctor ]
  <> (filter ((/=) "") [ postCondConstr ctor ])
  <> [ invariants ctor ]
  <> (concatMap (evalSeq behvConds) (groups behvs))
  <> (concatMap (evalSeq (transition store)) (groups behvs))
  <> (filter ((/=) "") $ concatMap (evalSeq retVal) (groups behvs))
  <> [ localStep _cname (groups behvs)]
  <> [ extStep _cname store ]
  <> [ step ]
  <> [ initState ctor ]
  <> [ multistep ]
  <> [ reachable ]
  <> [ reachableFromInit ctor]
  <> (filter ((/=) "") $ concatMap (evalSeq postCondBehv) (groups behvs))
  <> [ invariantInit ctor ]
  <> [ invariantStep ctor ]
  <> [ invariantReachable ctor]
  <> [ "End " <> T.pack _cname <> "." ]
  where
    groups = groupBy (\b b' -> _name b == _name b')

    stateRecord = T.unlines
      [ "Record" <+> stateType <+> ": Set :=" <+> stateConstructor
      , "{ " <> T.intercalate ("\n" <> "; ") ("addr : address" : map decl (M.toList store'))
      , "}."
      ]

    decl (n, (s, _)) = (T.pack n) <> " : " <> slotType s

    store' = contractStore _cname store

-- | inductive definition of step relation of 2 states
localStep :: Id -> [[Behaviour]] -> T.Text
localStep contract behvs = inductive
  (localStepType contract) "" (stateType <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = concat (evalSeq stepBehv <$> behvs)

    -- | constructor for the step relation
    stepBehv :: Behaviour -> Fresh (T.Text, Maybe T.Text, T.Text)
    stepBehv (Behaviour name _ i _ _ _ _ _) =
      fresh name >>= continuation where
      continuation name' =
        return (name' <> stepSuffix, Just $ envDecl <+> interface i <+> stateDecl, constructorBody)
        where
          constructorBody = (indent 2) . implication $
            [ name' <> "_conds" <+> envVar <+> arguments i <+> stateVar
            , (localStepType contract) <+> stateVar <+> parens ( "snd" <+> parens ( name' <+> envVar <+> stateVar <+> arguments i))]

envStateConstraint :: T.Text
envStateConstraint = definition
  envStateConstraintType (envDecl <+> stateDecl) body
    where
      body = indent 2 $ forAll (parens ("p : address")) <+> 
        (addressInType <+> "p" <+> stateVar) <+> "->" <+> ("NextAddr" <+> envVar <+> "> p")

envInterfaceConstraint :: Interface -> [T.Text]
envInterfaceConstraint (Interface _ decls) = mapMaybe decl decls
  where
  decl :: Decl -> Maybe T.Text
  decl (Decl (AbiArg AbiAddressType) name) = Just $ "NextAddr" <+> envVar <+> ">" <+> T.pack name
  decl (Decl (ContractArg _ cid) name) = Just $ T.pack cid <> "." <> envStateConstraintType <+> envVar <+> T.pack name
  decl _ = Nothing


extStep :: Id -> Store -> T.Text
extStep main store = inductive
  extStepType "" (envType <+> "->" <+> stateType <+> "->" <+> stateType <+> "-> Prop") body
  where
    body =
      (extStepType <> "_" <> T.pack main, Just $ (envDecl <+> stateDecl <+> stateDecl'), indent 2 $ implication [localStepType main <+> stateVar <+> stateVar', extStepType <+> envVar <+> stateVar <+> stateVar'])
      : (M.elems $ M.mapMaybeWithKey substep localStore)

    localStore = contractStore main store

    substep :: Id -> (SlotType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    substep var (StorageValue (ContractType cid), _) = Just (extStepType <> "_" <> varp, Just (envDecl <+> stateDecl <+> stateDecl'), body')
      where
        varp = T.pack var
        body' = indent 2 . implication . concat $
          [ [ envStateConstraintType <+> envVar <+> stateVar ]
          , [ T.pack cid <> "." <> extStepType <+> envVar <+> parens (varp <+> stateVar) <+> parens (varp <+> stateVar') ]
          , (\var' -> parens (T.pack var' <+> stateVar) <+> "=" <+> parens (T.pack var' <+> stateVar')) <$> (filter (var /=) $ M.keys localStore)
          , [ extStepType <+> envVar <+> stateVar <+> stateVar' ]
          ]
    substep _ _ = Nothing

step :: T.Text
step =
  definition stepType (stateDecl <+> stateDecl') $
    "exists" <+> envDecl <> "," <+> extStepType <+> envVar <+> stateVar <+> stateVar'

combine :: [a] -> [(a,a)]
combine lst = combine' lst []
  where
    combine' [] acc = concat acc
    combine' (x:xs) acc =
      let xcomb = [ (x, y) | y <- xs] in
      combine' xs (xcomb:acc)

addressIn :: Id -> Store -> T.Text
addressIn name store = inductive
  addressInType "" ("Z" <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = ("address_addr", Just stateDecl, indent 5 $ addressInType <+> parens ("addr" <+> stateVar) <+> stateVar)
           : M.elems (M.mapMaybeWithKey subAddr localStore)

    localStore = contractStore name store

    subAddr :: Id -> (SlotType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    -- TODO: check if name `p` can cause conflicts here
    subAddr var (StorageValue (ContractType cid), _) = Just ("address_" <> varp, Just $ parens ("p : address") <+> stateDecl, body')
      where
        varp = T.pack var
        body' = indent 2 . implication $
          [ T.pack cid <> "." <> addressInType <+> "p" <+> parens (varp <+> stateVar)
          , addressInType <+> "p" <+> stateVar
          ]
    subAddr var (StorageValue (PrimitiveType AbiAddressType), _) =
      let varp = T.pack var in
      Just ("address_" <> varp, Just stateDecl, indent 5 $ addressInType <+>  parens (varp <+> stateVar) <+> stateVar)
    subAddr _ _ = Nothing

isAddressSlot :: SlotType -> Bool
isAddressSlot (StorageValue (PrimitiveType AbiAddressType)) = True
isAddressSlot _ = False

slotContractName :: SlotType -> Maybe Id
slotContractName (StorageValue (ContractType cid)) = Just cid
slotContractName _ = Nothing

noAliasing :: Id -> Store -> T.Text
noAliasing name store = definition
  noAliasingType stateDecl body
  where
    body = indent 2 . conjuction $
      (addressPairAliasing <$> addressPairs)
      <> (addressContractAliasing <$> addressContractPairs)
      <> (contractPairAliasing <$> contractPairs)
      <> (subContractAliasing <$> storeContracts)

    localStore = contractStore name store
    storeAddresses = "addr" : M.keys (M.filter (isAddressSlot . fst) localStore)
    addressPairs = filter (not . uncurry (==)) $ combine storeAddresses
    storeContracts = M.toList $ M.mapMaybe (slotContractName . fst) localStore
    addressContractPairs = liftA2 (,) storeContracts storeAddresses
    contractPairs = filter (not. uncurry (==)) $ combine storeContracts
 
    addressPairAliasing :: (Id, Id) -> T.Text
    addressPairAliasing (a1, a2) = parens (T.pack a1 <+> stateVar) <+> "<>" <+> parens (T.pack a2 <+> stateVar)

    -- TODO: check if name `p` can cause conflicts here
    addressContractAliasing :: ((Id, Id), Id) -> T.Text
    addressContractAliasing ((cvar, cid), a) =
      parens $ forAll (parens ("p : address")) <+> 
        ( T.pack cid <> "." <> addressInType <+> "p" <+> parens (T.pack cvar <+> stateVar)) <+> "->" 
        <+> (parens (T.pack a <+> stateVar) <+> "<>" <+> "p")

    contractPairAliasing :: ((Id, Id), (Id, Id)) -> T.Text
    contractPairAliasing ((cvar1, cid1), (cvar2, cid2)) =
      parens $ forAll (parens ("p p' : address")) <+> 
        ( T.pack cid1 <> "." <> addressInType <+> "p" <+> parens (T.pack cvar1 <+> stateVar)) <+> "->" 
        <+> ( T.pack cid2 <> "." <> addressInType <+> "p'" <+> parens (T.pack cvar2 <+> stateVar)) <+> "->" 
        <+> ("p" <+> "<>" <+> "p'")

    subContractAliasing :: (Id, Id) -> T.Text
    subContractAliasing (cvar, cid) = T.pack cid <> "." <> noAliasingType <+> parens (T.pack cvar <+> stateVar)


-- | definition of reachable states
reachable :: T.Text
reachable = definition
  reachableType args value
  where
    args = parens $ stateVar <+> ":" <+> stateType
    value = "exists" <+> stateVar' <> "," <+> initStateType <+> stateVar'
      <+> "/\\" <+> multistepType <+> stateVar' <+> stateVar

-- | specialization of generic multistep
multistep :: T.Text
multistep = definition
  multistepType args value
  where
    args = parens $ stateVar <+> stateVar' <+> ":" <+> stateType
    value = multistepType <+> stepType <+> stateVar <+> stateVar'

-- | definition of reachable states from initial constructor parameters
reachableFromInit :: Constructor -> T.Text
reachableFromInit (Constructor name i _ _ _ _ ) = definition
  reachableFromInitType args value
  where
    args = envDecl <+> interface i <+> stateDecl
    value = initPrecsType <+>
      envVar <+> arguments i <+> "/\\" <+> multistepType <+>
      parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i)) <+> stateVar

-- | definition of constructor preconditions
initPrecs :: Constructor -> T.Text
initPrecs (Constructor _ i conds _ _ _ ) = definition
  initPrecsType (envDecl <+> interface i) body
  where
    body = indent 2 . conjuction . concat $
      [ coqprop <$> conds
      , envInterfaceConstraint i
      ]

-- | definition of behaviour-case conditions
behvConds :: Behaviour -> Fresh T.Text
behvConds (Behaviour name _ i conds casecs _ _ _) = do
  name' <- fresh name
  pure $ definition
    (name' <> "_conds") (envDecl <+> interface i <+> stateDecl) body
  where
    body = indent 2 $ conjuction . concat $
      [ coqprop <$> (conds <> casecs)
      , [ envStateConstraintType <+> envVar <+> stateVar ]
      , envInterfaceConstraint i
      ]

-- | predicate characterizing all initial (post constructor) states
initState :: Constructor -> T.Text
initState (Constructor name i _ _ _ _) = inductive
  initStateType "" (stateType <> " -> " <> " Prop") [("InitState", Just $ envDecl <+> interface i, constructorBody)]
  where
    baseval = parens $ "snd" <+> parens (T.pack name <+> envVar <+> arguments i)
    constructorBody = (indent 2) . implication . concat $
      [ [initPrecsType <+> envVar <+> arguments i]
      , [initStateType <+> baseval]
      ]

-- | definition of a base state
base :: Store -> Constructor -> T.Text
base store (Constructor name i _ _ _ updates) =
  let (s, bindings, finalI) = stateval store name (\_ t -> defaultSlotValue t) updates
  in
  definition (T.pack name) (envDecl <+> interface i)
  (foldr (\a s' -> "let" <+> a <+> "in\n" <> s') (tuple ("NextEnv" <+> iEnv finalI) s) bindings)

transition :: Store -> Behaviour -> Fresh T.Text
transition store (Behaviour name cname i _ _ _ rewrites _) = do
  name' <- fresh name
  let (s, bindings, finalI) = stateval store cname (\r _ -> ref stateVar r) rewrites
  return $ definition name' (envDecl <+> stateDecl <+> interface i) $ foldr (\a s' -> "let" <+> a <+> "in\n" <> s') (tuple ("NextEnv" <+> iEnv finalI) s) bindings

-- | inductive definition of a return claim
-- ignores claims that do not specify a return value
retVal :: Behaviour -> Fresh T.Text
retVal (Behaviour name _ i _ cases _ _ (Just r)) =
  fresh name >>= continuation where
  continuation name' = return $ inductive
    (name' <> returnSuffix)
    (envDecl <+> stateDecl <+> interface i)
    (returnType r <> " -> Prop")
    [(retname <> introSuffix, Nothing, body)] where

    retname = name' <> returnSuffix
    body = indent 2 . implication . concat $
      [ [name' <> "_conds" <+> envVar <+> arguments i <+> stateVar]
      , coqprop <$> cases
      , [retname <+> envVar <+> stateVar <+> arguments i <+> typedexp r] -- can return types be ContractType? probably not
      ]

retVal _ = return ""

-- | Definition of postcondition claim for constructor
postCondConstr :: Constructor -> T.Text
postCondConstr (Constructor _ _ _ [] _ _) = ""
postCondConstr (Constructor name i _ postcs _ _) =
  T.intercalate "\n\n" $ evalSeq post postcs
    where
    post :: Exp ABoolean -> Fresh T.Text
    post pc =
      fresh (name <> T.unpack postSuffix) >>= continuation where
      continuation postName = return $ definition postName "" body
      body = indent 2 $ T.unlines
        [ forAll $ envDecl <+> interface i <+> stateDecl'
        , implication . concat $
          [ [initPrecsType <+> envVar <+> arguments i]
          , [stateVar' <+> "=" <+> "snd" <+> parens (T.pack name <+> envVar <+> arguments i)]
          , [coqprop pc]
          ]
        ]

-- | Definition of postcondition claim for behaviour cases
postCondBehv :: Behaviour -> Fresh T.Text
postCondBehv (Behaviour _ _ _ _ _ [] _ _) = return ""
postCondBehv (Behaviour name _ i _ _ postcs _ _) =
  fresh name >>= continuation where
  continuation name' = return $ T.intercalate "\n\n" $ evalSeq (post name') postcs
    where
      post :: T.Text -> Exp ABoolean -> Fresh T.Text
      post case_name pc =
        fresh (T.unpack $ case_name <> postSuffix) >>= continuation' where
        continuation' postName = return $ definition postName "" body
        body = indent 2 $ T.unlines
          [ forAll $ envDecl <+> stateDecl <+> stateDecl' <+> interface i
          , implication . concat $
            [ [name' <> "_conds" <+> envVar <+> arguments i <+> stateVar]
            , [reachableType <+> stateVar]
            , [stateVar' <+> "=" <+> "snd" <+> parens (name' <+> envVar <+> stateVar <+> arguments i)]
            , [coqprop pc]
            ]
          ]

-- | Definition of invariant proposition
invariants :: Constructor -> T.Text
invariants (Constructor _ _ _ _ [] _) = ""
invariants (Constructor _ i _ _ invs _) =
  definition "invariants" (envDecl <+> interface i <+> stateDecl) $ indent 2 . conjuction $ invariantProp <$> invs
  where
    invariantProp :: Invariant -> T.Text
    invariantProp (Invariant _ _ _ (PredTimed p _)) = coqprop p


-- | Definition of invariant claim at constructor poststate
invariantInit :: Constructor -> T.Text
invariantInit (Constructor name i _ _ _ _) =
  definition invInitType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [invPropVar <+> envVar <+> arguments i <+> parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i))]
        ]
      ]

-- | Definition of invariant claim for behaviour cases
invariantStep :: Constructor -> T.Text
invariantStep (Constructor _ i _ _ _ _) =
  definition invStepType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i <+> stateDecl <+> stateDecl'
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [stepType <+> stateVar <+> stateVar']
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar']
        ]
      ]

-- | Lemma extending invariant properties' hold to reachable states,
-- given proof of init and step invariance
invariantReachable :: Constructor -> T.Text
invariantReachable (Constructor _ i _ _ _ _) =
  lemma invReachType "" claim proof
  where
    claim = indent 2 $ T.unlines
      [ forAll (envDecl <+> interface i <+> stateDecl <+> invPropDecl i
        <+> parens ("HIPinvInit :" <+> invInitType <+> invPropVar) <+> parens ("HIPinvStep :" <+> invStepType <+> invPropVar))
      , implication . concat $
        [ [reachableFromInitType <+> envVar <+> arguments i <+> stateDecl]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        ]
      ]
    proof = T.unlines $
      [
        "Proof."
      , indent 2 . T.unlines $
        [ "intros" <+> envVar <+> arguments i <+> stateVar <+> invPropVar <+> "HIPinvInit HIPinvStep Hreach."
        , "unfold reachableFromInit in Hreach."
        , "destruct Hreach as [Hinit Hmulti]."
        , "apply step_multi_step with (P := fun s s' =>" <+> invPropVar <+> envVar <+> arguments i <+> "s ->" <+> invPropVar <+> envVar <+> arguments i <+> "s' ) in Hmulti."
        , "- apply Hmulti."
        , "  apply HIPinvInit; assumption."
        , "- intros s s' Hstep."
        , "  apply HIPinvStep with (STATE := s) (STATE' := s') ; assumption."
        , "- unfold Relation_Definitions.reflexive."
        , "  intros."
        , "  assumption."
        , "- unfold Relation_Definitions.transitive."
        , "  intros s1 s2 s3 Ht1 Ht2 Ht3."
        , "  apply Ht2, Ht1."
        , "  assumption."
        ]
     , "Qed."
     ]

-- | produce a state value from a list of storage updates
-- 'handler' defines what to do in cases where a given name isn't updated
stateval :: Store -> Id -> (Ref Storage -> SlotType -> T.Text) -> [StorageUpdate] -> (T.Text, [T.Text], Int)
stateval store contract handler updates =
  let (texts, finalI) = runSeq (\(n, (t, _)) -> updateVar store updates handler (SVar nowhere contract n) t) (M.toList store')
      (vals, bindings) = unzip texts
      bindings' = concat bindings
  in
  (T.unwords $ stateConstructor : parens ("NextAddr" <+> iEnv finalI) : vals, bindings', finalI)
  where
    store' = contractStore contract store


contractStore :: Id -> Store -> Map Id (SlotType, Integer)
contractStore contract store = case M.lookup contract store of
  Just s -> s
  Nothing -> error "Internal error: cannot find constructor in store"


-- | Check is an update update a specific storage reference
eqRef :: Ref Storage -> StorageUpdate -> Bool
eqRef r (Update _ (Item _ _ r') _) = r == r'

-- | Check if an update updates a location that has a given storage
-- reference as a base
baseRef :: Ref Storage -> StorageUpdate -> Bool
baseRef baseref (Update _ (Item _ _ r) _) = hasBase r
  where
    hasBase (SVar _ _ _) = False
    hasBase (SArray _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SMapping _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SField _ r' _ _) = r' == baseref || hasBase r'

iState :: Int -> T.Text
iState 0 = "STATE"
iState i = "STATE" <> T.pack (show i)

iEnv :: Int -> T.Text
iEnv 0 = "ENV"
iEnv i = "ENV" <> T.pack (show i)

updateExp :: Exp a -> Fresh (T.Text, [T.Text])
updateExp (Create _ cid args) = do
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <> "." <> T.pack cid <+> iEnv i <+> T.unwords args')
  pure (iState (i+1), bindings)
updateExp (Address _ (Create _ cid args)) = do
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <> "." <> T.pack cid <+> iEnv i <+> T.unwords args')
  pure (parens $ T.pack cid <> ".addr" <+> iState (i+1), bindings)
updateExp e = pure (coqexp e, [])

updateExpTyped :: TypedExp -> Fresh (T.Text, [T.Text])
updateExpTyped (TExp _ _ te) = updateExp te

updateVar :: Store -> [StorageUpdate] -> (Ref Storage -> SlotType -> T.Text) -> Ref Storage -> SlotType -> Fresh (T.Text, [T.Text])
updateVar store updates handler focus t@(StorageValue (ContractType cid)) =
  case unsnoc groupedUpdates of
    Nothing -> pure (handler focus t, [])
    Just (_, (firstU@(Update _ _ e) NE.:| [])) | eqRef focus firstU->
      updateExp e
    Just (_, (firstU@(Update _ _ e) NE.:| nextUpdates)) | eqRef focus firstU-> do
      (newState, bindings) <- updateExp e
      (t', bindings') <- unzip <$> traverse (\(n, (t', _)) -> updateVar store nextUpdates (\r _ -> ref newState r) (refocus n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <> "." <> stateConstructor) : parens (T.pack cid <> ".addr" <+> newState) : t', bindings ++ concat bindings')
    Just (_, fieldUpdates) -> do
      t' <- traverse (\(n, (t', _)) -> fst <$> updateVar store (NE.toList fieldUpdates) handler (focus' n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <> "." <> stateConstructor) : parens (T.pack cid <> ".addr" <+> ref stateVar focus) : t', [])
  where
    focus' x = SField nowhere focus cid x
    refocus x = SVar nowhere cid x
    store' = contractStore cid store

    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates
    groupedUpdates = NE.groupBy (\_ b -> not $ eqRef focus b) focusUpdates

    --fieldUpdates = filter (baseRef focus) updates
    --constructorUpdates = filter (eqRef focus) updates

updateVar _ updates handler focus t@(StorageValue (PrimitiveType AbiAddressType)) =
  case unsnoc focusUpdates of
    Nothing -> pure (handler focus t, [])
    Just (_, (Update _ _ e)) -> updateExp e
  where
    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates

updateVar _ updates handler focus t@(StorageValue (PrimitiveType _)) =
  pure (foldl updatedVal (handler focus t) (filter (eqRef focus) updates), [])
    where
      updatedVal _ (Update SByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = coqexp e

updateVar _ updates handler focus t@(StorageMapping xs _) = pure (parens $
  lambda n <+> foldl updatedMap prestate (filter (baseRef focus) updates), [])
    where
      prestate = parens $ handler focus t <+> lambdaArgs n
      n = length xs

      updatedMap _ (Update SByteStr _ _) = error "bytestrings not supported"
      updatedMap prestate' (Update _ item e) =
        let ixs = ixsFromItem item in
        "if" <+> boolScope (T.intercalate " && " (map cond (zip ixs ([0..] :: [Int]))))
        <+> "then" <+> coqexp e
        <+> "else" <+> prestate'

      cond (TExp argType _ arg, i) = parens $ anon <> T.pack (show i) <> eqsym argType <> coqexp arg

      lambda i = if i >= 0 then "fun" <+> lambdaArgs i <+> "=>" else ""

      lambdaArgs i = T.unwords $ map (\a -> anon <> T.pack (show a)) ([0..i-1] :: [Int])

      eqsym :: SType a -> T.Text
      eqsym argType = case argType of
        SInteger -> "=?"
        SBoolean -> "=??"
        SByteStr -> error "bytestrings not supported"
        SContract -> "=?" -- TODO: check if correct, probably yes
        SSArray _ -> error "arrays not supported"


-- | produce a block of declarations from an interface
interface :: Interface -> T.Text
interface (Interface _ decls) =
  T.unwords $ map decl decls where
  decl (Decl (AbiArg AbiAddressType) name) = parens $ T.pack name <+> ":" <+> abiType AbiAddressType
  decl (Decl (ContractArg _ cid) name) = parens $ T.pack name <+> ":" <+> T.pack cid <> ".State"
  decl (Decl (AbiArg t) name) = parens $ T.pack name <+> ":" <+> abiType t

arguments :: Interface -> T.Text
arguments (Interface _ decls) =
  T.unwords $ map (\(Decl _ name) -> T.pack name) decls

-- | coq syntax for a slot type
slotType :: SlotType -> T.Text
slotType (StorageMapping xs t) =
  T.intercalate " -> " (map mappingIdxType (NE.toList xs ++ [t]))
slotType (StorageValue val) = valueType val

valueType :: ValueType -> T.Text
valueType (PrimitiveType t) = abiType t
valueType (ContractType cid) = T.pack cid <> "." <> "State" -- the type of a contract is its state record

mappingIdxType :: ValueType -> T.Text
mappingIdxType (PrimitiveType t) = abiType t
mappingIdxType (ContractType _) = "address" -- index by addresses, not contents of states

-- | coq syntax for an abi type
abiType :: AbiType -> T.Text
abiType (AbiUIntType _) = "Z"
abiType (AbiIntType _) = "Z"
abiType AbiAddressType = "address"
abiType AbiStringType = strMod <> ".string"
abiType a = error $ show a

-- | coq syntax for a return type
returnType :: TypedExp -> T.Text
returnType (TExp SInteger _ _) = "Z"
returnType (TExp SBoolean _ _) = "bool"
returnType (TExp SByteStr _ _) = error "bytestrings not supported"
returnType (TExp SContract _ _) = error "Contracts cannot be returned"
returnType (TExp (SSArray _) _ _) = error "arrays not supported"

-- | default value for a given type
-- this is used in cases where a value is not set in the constructor
defaultSlotValue :: SlotType -> T.Text
defaultSlotValue (StorageMapping xs t) = parens $
  "fun"
  <+> T.unwords (replicate (length (NE.toList xs)) "_")
  <+> "=>"
  <+> defaultVal t
defaultSlotValue (StorageValue t) = defaultVal t

defaultVal :: ValueType -> T.Text
defaultVal (PrimitiveType t) = abiVal t
defaultVal (ContractType _) = error "Contracts must be explicitly initialized"

abiVal :: AbiType -> T.Text
abiVal (AbiUIntType _) = "0"
abiVal (AbiIntType _) = "0"
abiVal AbiAddressType = "0"
abiVal AbiStringType = strMod <> ".EmptyString"
abiVal _ = error "TODO: missing default values"

-- | coq syntax for an expression
coqexp :: Exp a -> T.Text
-- booleans
coqexp (LitBool _ True)  = "true"
coqexp (LitBool _ False) = "false"
coqexp (And _ e1 e2)  = parens $ "andb"    <+> coqexp e1 <+> coqexp e2
coqexp (Or _ e1 e2)   = parens $ "orb"     <+> coqexp e1 <+> coqexp e2
coqexp (Impl _ e1 e2) = parens $ "implb"   <+> coqexp e1 <+> coqexp e2
coqexp (Eq _ _ e1 e2)   = parens $ coqexp e1  <+> "=?" <+> coqexp e2
coqexp (NEq _ _ e1 e2)  = parens $ "negb" <+> parens (coqexp e1  <+> "=?" <+> coqexp e2)
coqexp (Neg _ e)      = parens $ "negb" <+> coqexp e
coqexp (LT _ e1 e2)   = parens $ coqexp e1 <+> "<?"  <+> coqexp e2
coqexp (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=?" <+> coqexp e2
coqexp (GT _ e1 e2)   = parens $ coqexp e2 <+> "<?"  <+> coqexp e1
coqexp (GEQ _ e1 e2)  = parens $ coqexp e2 <+> "<=?" <+> coqexp e1

-- integers
coqexp (LitInt _ i) = T.pack $ show i
coqexp (Add _ e1 e2) = parens $ coqexp e1 <+> "+" <+> coqexp e2
coqexp (Sub _ e1 e2) = parens $ coqexp e1 <+> "-" <+> coqexp e2
coqexp (Mul _ e1 e2) = parens $ coqexp e1 <+> "*" <+> coqexp e2
coqexp (Div _ e1 e2) = parens $ coqexp e1 <+> "/" <+> coqexp e2
coqexp (Mod _ e1 e2) = parens $ "Z.modulo" <+> coqexp e1 <+> coqexp e2
coqexp (Exp _ e1 e2) = parens $ coqexp e1 <+> "^" <+> coqexp e2
coqexp (IntMin _ n)  = parens $ "INT_MIN"  <+> T.pack (show n)
coqexp (IntMax _ n)  = parens $ "INT_MAX"  <+> T.pack (show n)
coqexp (UIntMin _ n) = parens $ "UINT_MIN" <+> T.pack (show n)
coqexp (UIntMax _ n) = parens $ "UINT_MAX" <+> T.pack (show n)

coqexp (InRange _ t e) = coqexp (bound t e)

-- polymorphic
coqexp (VarRef _ whn _ i) = entry whn i
coqexp (ITE _ b e1 e2) = parens $ "if"
                               <+> coqexp b
                               <+> "then"
                               <+> coqexp e1
                               <+> "else"
                               <+> coqexp e2

-- environment values
-- Relies on the assumption that Coq record fields have the same name
-- as the corresponding Haskell constructor
coqexp (IntEnv _ envVal) = parens $ T.pack (show envVal) <+> envVar
-- Contracts
coqexp Create {} = error "Internal error: coqexp called for creation expression"
-- unsupported
coqexp (Address cid e) = parens $ T.pack cid <> ".addr" <+> coqexp e
coqexp Cat {} = error "bytestrings not supported"
coqexp Slice {} = error "bytestrings not supported"
coqexp ByStr {} = error "bytestrings not supported"
coqexp ByLit {} = error "bytestrings not supported"
coqexp ByEnv {} = error "bytestrings not supported"
coqexp Array {} = error "arrays not supported"

-- | coq syntax for a proposition
coqprop :: Exp a -> T.Text
coqprop (LitBool _ True)  = "True"
coqprop (LitBool _ False) = "False"
coqprop (And _ e1 e2)  = parens $ coqprop e1 <+> "/\\" <+> coqprop e2
coqprop (Or _ e1 e2)   = parens $ coqprop e1 <+> "\\/" <+> coqprop e2
coqprop (Impl _ e1 e2) = parens $ coqprop e1 <+> "->"  <+> coqprop e2
coqprop (Neg _ e)      = parens $ "not" <+> coqprop e
coqprop (Eq _ _ e1 e2)   = parens $ coqexp e1 <+> "="  <+> coqexp e2
coqprop (NEq _ _ e1 e2)  = parens $ coqexp e1 <+> "<>" <+> coqexp e2
coqprop (LT _ e1 e2)   = parens $ coqexp e1 <+> "<"  <+> coqexp e2
coqprop (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=" <+> coqexp e2
coqprop (GT _ e1 e2)   = parens $ coqexp e1 <+> ">"  <+> coqexp e2
coqprop (GEQ _ e1 e2)  = parens $ coqexp e1 <+> ">=" <+> coqexp e2
coqprop (InRange _ t e) = coqprop (bound t e)

coqprop e = error "ill formed proposition:" <+> T.pack (show e)

-- | coq syntax for a typed expression
typedexp :: TypedExp -> T.Text
typedexp (TExp _ _ e) = coqexp e

entry :: Time 'Timed -> TItem k a -> T.Text
entry _ (Item SByteStr _ _) = error "bytestrings not supported"
entry Pre  (Item _ _ r) = ref stateVar r
entry Post (Item _ _ r) = ref stateVar' r

ref :: T.Text -> Ref k -> T.Text
ref refState (SVar _ cid name) = parens $ T.pack cid <> "." <> T.pack name <+> refState
ref _ (CVar _ _ name) = T.pack name
ref refState (SArray _ r _ ixs) = parens $ ref refState r <+> coqargs (fst <$> ixs)
ref refState (SMapping _ r _ ixs) = parens $ ref refState r <+> coqargs ixs
ref refState (SField _ r cid name) = parens $ T.pack cid <> "." <> T.pack name <+> ref refState r

-- | coq syntax for a list of arguments
coqargs :: [TypedExp] -> T.Text
coqargs es = T.unwords (map typedexp es)

fresh :: Id -> Fresh T.Text
fresh name = state $ \s -> (T.pack (name <> show s), s + 1)

getIncr :: Fresh Int
getIncr = state $ \s -> (s, s + 1)

evalSeq :: Traversable t => (a -> Fresh b) -> t a -> t b
evalSeq f xs = evalState (sequence (f <$> xs)) 0

runSeq :: Traversable t => (a -> Fresh b) -> t a -> (t b, Int)
runSeq f xs = runState (sequence (f <$> xs)) 0

--- text manipulation ---

definition :: T.Text -> T.Text -> T.Text -> T.Text
definition name args value = T.unlines
  [ "Definition" <+> name <+> args <+> ":="
  , value <> "."
  ]

inductive :: T.Text -> T.Text -> T.Text -> [(T.Text, Maybe T.Text, T.Text)] -> T.Text
inductive name args indices constructors = T.unlines
  [ "Inductive" <+> name <+> args <+> ":" <+> indices <+> ":="
  , T.unlines (((<>) "| " . uncurry3 inductiveConstructor) <$> constructors) <> "."
  ]

inductiveConstructor :: T.Text -> Maybe T.Text -> T.Text -> T.Text
inductiveConstructor ctorName Nothing body =
     ctorName <+> ":\n" <> body
inductiveConstructor ctorName (Just bindings) body =
     ctorName <+> ":" <+> forAll bindings <> "\n" <> body

lemma :: T.Text -> T.Text -> T.Text -> T.Text -> T.Text
lemma name args claim proof = T.unlines
  [ "Lemma" <+> name <+> args <+> ":"
  , claim <> "."
  , proof
  ]


-- | forall bindings
forAll :: T.Text -> T.Text
forAll bindings = "forall" <+> bindings <> ","

-- | multiline implication
implication :: [T.Text] -> T.Text
implication xs = "   " <> T.intercalate "\n-> " xs

-- | multiline conjuction
conjuction :: [T.Text] -> T.Text
conjuction [] = "   True"
conjuction xs = "   " <> T.intercalate "\n/\\ " xs

-- | wrap text in parentheses
parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

tuple :: T.Text -> T.Text -> T.Text
tuple a b = "(" <> a <> ", " <> b <> ")"

boolScope :: T.Text -> T.Text
boolScope s = "(" <> s <> ")%bool"

indent :: Int -> T.Text -> T.Text
indent n = T.unlines . fmap (T.replicate n " " <>) . T.lines

(<+>) :: T.Text -> T.Text -> T.Text
"" <+> t2 = t2
t1 <+> "" = t1
t1 <+> t2 = t1 <> " " <> t2

--- constants ---

-- | string module name
strMod :: T.Text
strMod  = "Str"

-- | base state name
baseVar :: T.Text
baseVar = "BASE"

stateType :: T.Text
stateType = "State"

stateVar :: T.Text
stateVar = "STATE"

stateVar' :: T.Text
stateVar' = "STATE'"

nextVar :: T.Text
nextVar = "NEXT"

stateDecl :: T.Text
stateDecl = parens $ stateVar <+> ":" <+> stateType

stateDecl' :: T.Text
stateDecl' = parens $ stateVar' <+> ":" <+> stateType

stateConstructor :: T.Text
stateConstructor = "state"

returnSuffix :: T.Text
returnSuffix = "_ret"

postSuffix :: T.Text
postSuffix = "_post"

invInitType :: T.Text
invInitType  = "invariantInit"

invStepType :: T.Text
invStepType  = "invariantStep"

invReachType :: T.Text
invReachType  = "invariantReachable"

baseSuffix :: T.Text
baseSuffix = "_base"

stepSuffix :: T.Text
stepSuffix = "_step"

introSuffix :: T.Text
introSuffix = "_intro"

localStepType :: Id -> T.Text
localStepType name = T.pack name <> "_step"

stepType :: T.Text
stepType = "step"

extStepType :: T.Text
extStepType = "extStep"

addressInType :: T.Text
addressInType = "addressIn"

noAliasingType :: T.Text
noAliasingType = "noAliasing"

envStateConstraintType :: T.Text
envStateConstraintType = "envStateConstraint"

initStateType :: T.Text
initStateType = "init"

invPropVar :: T.Text
invPropVar = "IP"

invPropType :: Interface -> T.Text
invPropType (Interface _ decls) = T.intercalate " -> " $ concat [[envType], map decl' decls, [stateType, "Prop"]]
  where
  decl' (Decl (ContractArg _ cid) _) = T.pack cid <> ".State"
  decl' (Decl (AbiArg t) _) = abiType t

invPropDecl :: Interface -> T.Text
invPropDecl i = parens $ invPropVar <+> ":" <+> invPropType i

initPrecsType :: T.Text
initPrecsType = "initPreconds"

behvPrecsType :: T.Text
behvPrecsType = "behvPrecs"

multistepType :: T.Text
multistepType = "multistep"

reachableType :: T.Text
reachableType = "reachable"

reachableFromInitType :: T.Text
reachableFromInitType = "reachableFromInit"

reachStep:: T.Text
reachStep= "reach_step"

envType :: T.Text
envType = "Env"

envVar :: T.Text
envVar = "ENV"

envVar' :: T.Text
envVar' = "ENV'"

envDecl :: T.Text
envDecl = parens $ envVar <+> ":" <+> envType

envDecl' :: T.Text
envDecl' = parens $ envVar' <+> ":" <+> envType

anon :: T.Text
anon = "_binding_"
