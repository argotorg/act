{-
 -
 - coq backend for act
 -
 - unsupported features:
 - + bytestrings
 - + external storage
 - + casting from addresses to contract
 -
 -}

{-# Language OverloadedStrings #-}
{-# Language RecordWildCards #-}
{-# LANGUAGE GADTs #-}
{-# Language DataKinds #-}


module Act.Coq where

import Prelude hiding (GT, LT)

import Data.Map.Strict (Map)
import qualified Data.Map.Strict    as M
import qualified Data.List.NonEmpty as NE
import qualified Data.Text          as T
import Data.List (groupBy)
import Control.Monad.State

import EVM.ABI
import Act.Syntax
import Act.Syntax.TypedExplicit

type Fresh = State Int

header :: T.Text
header = T.unlines
  [ "(* --- GENERATED BY ACT --- *)\n"
  , "Require Import Coq.ZArith.ZArith."
  , "Require Import ActLib.ActLib."
  , "Require Coq.Strings.String.\n"
  , "Module " <> strMod <> " := Coq.Strings.String."
  , "Open Scope Z_scope.\n"
  ]

-- | produce a coq representation of a specification
coq :: Act -> T.Text
coq (Act store contracts) =
  header <> (T.intercalate "\n\n" $ contractCode store <$> contracts)

contractCode :: Store -> Contract -> T.Text
contractCode store (Contract ctor@Constructor{..} behvs) = T.unlines $
  [ "Module " <> T.pack _cname <> ".\n" ]
  <> [ stateRecord ]
  <> [ base store ctor ]
  <> [ postCondConstr ctor ]
  <> [ invariantProps ctor ]
  <> [ invariants ctor ]
  <> (concatMap (evalSeq (transition store)) (groups behvs))
  <> filter ((/=) "") (concatMap (evalSeq retVal) (groups behvs))
  <> (concatMap (evalSeq postCondBehv) (groups behvs))
  <> [ step (groups behvs)]
  <> [ initPred ctor ]
  <> [ multistep ]
  <> [ reachable ]
  <> [ reachableFromInit ]
  <> [ invariantInit ctor ]
  <> [ invariantStep ctor ]
  <> [ reachableInvariant ]
  <> [ "End " <> T.pack _cname <> "." ]
  where
    groups = groupBy (\b b' -> _name b == _name b')

    stateRecord = T.unlines
      [ "Record " <> stateType <> " : Set := " <> stateConstructor
      , "{ " <> T.intercalate ("\n" <> "; ") (map decl (M.toList store'))
      , "}."
      ]

    decl (n, (s, _)) = (T.pack n) <> " : " <> slotType s

    store' = contractStore _cname store

-- | inductive definition of step relation of 2 states
step :: [[Behaviour]] -> T.Text
step behvs = inductive
  stepType "" (stateType <> " -> " <> stateType <> " -> Prop") body
  where
    body = concat (evalSeq stepBehv <$> behvs)

-- | constructor for the step relation
stepBehv :: Behaviour -> Fresh T.Text
stepBehv (Behaviour name _ i _ conds cases _ _ _) =
  fresh name >>= continuation where
  continuation name' =
    return $ name'
      <> stepSuffix <> " : forall "
      <> envDecl <> " "
      <> parens (stateVar <> " : " <> stateType) <> " "
      <> interface i <> ",\n"
      <> constructorBody where

    constructorBody = (indent 2) . implication $
      (coqprop stateVar <$> cases ++ conds)
      <> [ stepType <+> stateVar <+> parens (name' <+> envVar <+> stateVar <+> arguments i)]


-- | definition of reachable states
reachable :: T.Text
reachable = definition
  reachableType args value
  where
    args = parens $ stateVar <> " : " <> stateType
    value = "exists " <> stateVar' <> ", " <> initType <>
      " " <> stateVar' <> " /\\ " <> multistepType <+>
      stateVar' <+> stateVar
    stateVar' = stateVar <> "'"

-- | specialization of generic multistep
multistep :: T.Text
multistep = definition
  multistepType args value
  where
    args = parens $ stateVar <+> stateVar' <> " : " <> stateType
    value = multistepType <+> stepType <+> stateVar <+> stateVar'
    stateVar' = stateVar <> "'"

-- | definition of reachable states from initial state
reachableFromInit :: T.Text
reachableFromInit = definition
  reachableFromInitType args value
  where
    args = parens $ stateVar <+> stateVar' <> " : " <> stateType
    value = initType <>
      " " <> stateVar <> " /\\ " <> multistepType <+>
      stateVar <+> stateVar'
    stateVar' = stateVar <> "'"

-- | predicate characterizing all initial (post constructor) states
initPred :: Constructor -> T.Text
initPred (Constructor name i@(Interface _ decls) _ conds _ _ _ ) = inductive
  initType "" (stateType <> " -> " <> " Prop") [body]
  where
    body = "Init : " <> universal <> "\n" <> constructorBody
    baseval = parens $ T.pack name <+> envVar <+> arguments i
    constructorBody = (indent 2) . implication . concat $
      [ coqprop stateVar <$> conds
      , [initType <+> baseval]
      ]
    universal =
      "forall " <> envDecl <+>
      (if null decls
       then ""
       else interface i) <> ","

-- | definition of a base state
base :: Store -> Constructor -> T.Text
base store (Constructor name i _ _ _ _ updates) =
  definition (T.pack name) (envDecl <+> interface i) $
    stateval store name (\_ t -> defaultSlotValue t) updates

transition :: Store -> Behaviour -> Fresh T.Text
transition store (Behaviour name cname i _ _ _ _ rewrites _) = do
  name' <- fresh name
  return $ definition name' (envDecl <+> stateDecl <+> interface i) $
    stateval store cname (\r _ -> ref stateVar r) rewrites

-- | inductive definition of a return claim
-- ignores claims that do not specify a return value
retVal :: Behaviour -> Fresh T.Text
retVal (Behaviour name _ i _ conds cases _ _ (Just r)) =
  fresh name >>= continuation where
  continuation name' = return $ inductive
    (name' <> returnSuffix)
    (envDecl <+> stateDecl <+> interface i)
    (returnType r <> " -> Prop")
    [retname <> introSuffix <> " :\n" <> body] where


    retname = name' <> returnSuffix
    body = indent 2 . implication . concat $
      [ coqprop stateVar <$> conds ++ cases
      , [retname <+> envVar <+> stateVar <+> arguments i <+> typedexp stateVar r]
      ]

retVal _ = return ""

--postCondConstr :: Constructor -> T.Text
--postCondConstr (Constructor _ _ _ _ [] _ _) = ""
--postCondConstr (Constructor name i _ conds postcs _ _) =
--  lemma
--    (T.pack name <> postSuffix)
--    (envDecl <+> stateDecl <+> interface i)
--    body
--    "Admitted."
--    where
--      body = indent 2 . implication . concat $ 
--        [ --["init STATE"]
--        coqprop "" <$> conds -- state should no be read here so doesn't matter?
--        , ["STATE = " <> T.pack name <+> envVar <+> arguments i]
--        , [T.intercalate " /\\ " $ coqprop stateVar <$> postcs]
--        ]
postCondConstr :: Constructor -> T.Text
postCondConstr (Constructor _ _ _ _ [] _ _) = ""
postCondConstr (Constructor name i _ conds postcs _ _) =
  T.intercalate "\n\n" $ evalSeq post postcs
    where
      post :: Exp ABoolean -> Fresh T.Text
      post pc =
        fresh (name <> T.unpack postSuffix) >>= continuation where
        continuation postName = return $
          lemma
          postName
          (envDecl <+> stateDecl <+> interface i)
          body
          "Admitted."
        body = indent 2 . implication . concat $
          [ --["init STATE"]
          coqprop "" <$> conds -- state should no be read here so doesn't matter?
          , ["STATE = " <> T.pack name <+> envVar <+> arguments i]
          , [coqprop stateVar pc]
          ]

postCondBehv :: Behaviour -> Fresh T.Text
postCondBehv (Behaviour _ _ _ _ _ _ [] _ _) = return ""
postCondBehv (Behaviour name _ i _ conds cases postcs _ _) =
  fresh name >>= continuation where
  continuation name' = return $ T.intercalate "\n\n" $ evalSeq (post name') postcs
    where
      post :: T.Text -> Exp ABoolean -> Fresh T.Text
      post case_name pc =
        fresh (T.unpack $ case_name <> postSuffix) >>= continuation' where
        continuation' postName = return $
          lemma
          postName
          (envDecl <+> stateDecl <+> stateDecl' <+> interface i)
          body
          "Admitted."
        body = indent 2 . implication . concat $
          [ coqprop stateVar <$> conds ++ cases
          , ["STATE' = " <> name' <+> envVar <+> stateVar <+> arguments i]
          , [coqprop stateVar pc]
          ]

invariantInit :: Constructor -> T.Text
invariantInit (Constructor name i _ conds _ _ _) =
  lemma (T.pack name <> invInitSuffix)
  (envDecl <+> interface i <+> "(P :" <+> envType <+> interfaceTypes i <+> stateType <+> " -> Prop)")
  claim
  "Admitted."
  where
    claim = indent 2 . implication . concat $
      [ coqprop "" <$> conds
      , ["invariant P"]
      , ["P" <+> envVar <+> arguments i <+> parens (T.pack name <+> envVar <+> arguments i)]
      ]
-- invariantConstr :: Constructor -> T.Text
-- invariantConstr (Constructor name i _ conds _ invs _) =
--   T.intercalate "\n\n" $ evalSeq inv invs
--   where
--     inv :: Invariant-> Fresh T.Text
--     inv (Invariant _ _ _ (PredTimed p _)) =
--       fresh (name <> T.unpack invInitSuffix) >>= continuation' where
--       continuation' name' = return $
--         lemma
--         name'
--         (envDecl <+> stateDecl <+> interface i)
--         body
--         "Admitted."
--       body = indent 2 . implication . concat $ 
--         [ --["init STATE"]
--         coqprop "" <$> conds -- state should no be read here so doesn't matter?
--         , ["STATE = " <> T.pack name <+> envVar <+> arguments i]
--         , [coqprop stateVar p]
--         ]

invariantStep :: Constructor -> T.Text
invariantStep (Constructor name i _ conds _ _ _) =
  lemma (T.pack name <> invStepSuffix)
  (envDecl <+> interface i <+> stateDecl <+> stateDecl' <+> "(P :" <+> envType <+> interfaceTypes i <+> stateType <+> " -> Prop)")
  claim
  "Admitted."
  where
    claim = indent 2 . implication . concat $
      [ coqprop "" <$> conds
      , ["step" <+> stateVar <+> stateVar <> "'"]
      , ["invariant P"]
      , ["P" <+> envVar <+> arguments i <+> stateVar]
      , ["P" <+> envVar <+> arguments i <+> stateVar <> "'"]
      ]

--invariantStep :: Constructor -> T.Text
--invariantStep (Constructor name i _ conds _ invs _) =
--  T.intercalate "\n\n" $ evalSeq inv invs
--  where
--    inv :: Invariant-> Fresh T.Text
--    inv (Invariant _ _ _ (PredTimed p _)) =
--      fresh (name <> T.unpack invStepSuffix) >>= continuation' where
--      continuation' name' = return $
--        lemma
--        name'
--        (envDecl <+> interface i <+> stateDecl <+> stateDecl')
--        body
--        "Admitted."
--      body = indent 2 . implication . concat $ 
--        [ --["init STATE"]
--          coqprop "" <$> conds -- state should no be read here so doesn't matter?
--        , [stepType <+> stateVar <+> stateVar <> "'"]
--        , [coqprop stateVar p]
--        , [coqprop (stateVar <> "'") p]
--        ]

invariantProps :: Constructor -> T.Text
invariantProps (Constructor _ i _ _ _ invs _) =
  T.concat $ evalSeq (invariantProp i) invs

invariantProp :: Interface -> Invariant -> Fresh T.Text
invariantProp i (Invariant _ _ _ (PredTimed p _)) =
  fresh "invariantProp" >>= continuation where
  continuation name' = return $ definition
    name'
    (envDecl <+> interface i <+> stateDecl)
    (coqprop stateVar p)


invariants :: Constructor -> T.Text
invariants (Constructor _ i _ _ _ invs _) =
  inductive
  "invariant"
  ""
  ("(" <> envType <+> interfaceTypes i <+> stateType <> " -> Prop) -> Prop")
  (evalSeq inv_constructor invs)
  where
    inv_constructor :: Invariant -> Fresh T.Text
    inv_constructor (Invariant _ _ _ (PredTimed _ _)) =
      fresh' "invariant" "invariantProp" >>= continuation where
      continuation (constr, term) = return $ constr <> ": invariant " <> term

-- | produce a state value from a list of storage updates
-- 'handler' defines what to do in cases where a given name isn't updated
stateval :: Store -> Id -> (Ref Storage -> SlotType -> T.Text) -> [StorageUpdate] -> T.Text
stateval store contract handler updates = T.unwords $
  stateConstructor : fmap (\(n, (t, _)) -> updateVar store updates handler (SVar nowhere contract n) t) (M.toList store')
  where
    store' = contractStore contract store

contractStore :: Id -> Store -> Map Id (SlotType, Integer)
contractStore contract store = case M.lookup contract store of
  Just s -> s
  Nothing -> error "Internal error: cannot find constructor in store"


-- | Check is an update update a specific storage reference
eqRef :: Ref Storage -> StorageUpdate -> Bool
eqRef r (Update _ (Item _ _ r') _) = r == r'

-- | Check if an update updates a location that has a given storage
-- reference as a base
baseRef :: Ref Storage -> StorageUpdate -> Bool
baseRef baseref (Update _ (Item _ _ r) _) = hasBase r
  where
    hasBase (SVar _ _ _) = False
    hasBase (SArray _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SMapping _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SField _ r' _ _) = r' == baseref || hasBase r'


updateVar :: Store -> [StorageUpdate] -> (Ref Storage -> SlotType -> T.Text) -> Ref Storage -> SlotType -> T.Text
updateVar store updates handler focus t@(StorageValue (ContractType cid)) =
  case (constructorUpdates, fieldUpdates) of
    -- Only some fields are updated
    ([], updates'@(_:_)) -> parens $ T.unwords $ (T.pack cid <> "." <> stateConstructor) : fmap (\(n, (t', _)) -> updateVar store  updates' handler (focus' n) t') (M.toList store')
    -- No fields are updated, whole contract may be updated with some call to the constructor
    (updates', []) -> foldl (\ _ (Update _ _ e) -> coqexp stateVar e) (handler focus t) updates'
    -- The contract is updated with constructor call and field accessing. Unsupported.
    (_:_, _:_) -> error "Cannot handle multiple updates to contract variable"
  where
    focus' x = SField nowhere focus cid x
    store' = contractStore cid store

    fieldUpdates = filter (baseRef focus) updates
    constructorUpdates = filter (eqRef focus) updates

updateVar _ updates handler focus t@(StorageValue (PrimitiveType _)) =
  foldl updatedVal (handler focus t) (filter (eqRef focus) updates)
    where
      updatedVal _ (Update SByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = coqexp stateVar e

updateVar _ updates handler focus t@(StorageMapping xs _) = parens $
  lambda n <> foldl updatedMap prestate (filter (baseRef focus) updates)
    where
      prestate = parens $ handler focus t <+> lambdaArgs n
      n = length xs

      updatedMap _ (Update SByteStr _ _) = error "bytestrings not supported"
      updatedMap prestate' (Update _ item e) =
        let ixs = ixsFromItem item in -- This will not work if the domain is a contract type
        "if " <> boolScope (T.intercalate " && " (map cond (zip ixs ([0..] :: [Int]))))
        <> " then " <> coqexp stateVar e
        <> " else " <> prestate'

      cond (TExp argType _ arg, i) = parens $ anon <> T.pack (show i) <> eqsym argType <> coqexp stateVar arg

      lambda i = if i >= 0 then "fun " <> lambdaArgs i <> " => " else ""

      lambdaArgs i = T.unwords $ map (\a -> anon <> T.pack (show a)) ([0..i-1] :: [Int])

      eqsym :: SType a -> T.Text
      eqsym argType = case argType of
        SInteger -> " =? "
        SBoolean -> " =?? "
        SByteStr -> error "bytestrings not supported"
        SSArray _ -> error "arrays not supported"


-- | produce a block of declarations from an interface
interface :: Interface -> T.Text
interface (Interface _ decls) =
  T.unwords $ map decl decls where
  decl (Decl t name) = parens $ T.pack name <> " : " <> abiType t

arguments :: Interface -> T.Text
arguments (Interface _ decls) =
  T.unwords $ map (\(Decl _ name) -> T.pack name) decls

interfaceTypes :: Interface -> T.Text
interfaceTypes (Interface _ decls) =
  T.intercalate " -> " (map (\(Decl t _) -> abiType t) decls) <> (T.pack " -> ")

-- | coq syntax for a slot type
slotType :: SlotType -> T.Text
slotType (StorageMapping xs t) =
  T.intercalate " -> " (map valueType (NE.toList xs ++ [t]))
slotType (StorageValue val) = valueType val

valueType :: ValueType -> T.Text
valueType (PrimitiveType t) = abiType t
valueType (ContractType cid) = T.pack cid <> "." <> "State" -- the type of a contract is its state record

-- | coq syntax for an abi type
abiType :: AbiType -> T.Text
abiType (AbiUIntType _) = "Z"
abiType (AbiIntType _) = "Z"
abiType AbiAddressType = "address"
abiType AbiStringType = strMod <> ".string"
abiType a = error $ show a

-- | coq syntax for a return type
returnType :: TypedExp -> T.Text
returnType (TExp SInteger _ _) = "Z"
returnType (TExp SBoolean _ _) = "bool"
returnType (TExp SByteStr _ _) = error "bytestrings not supported"
returnType (TExp (SSArray _) _ _) = error "arrays not supported"

-- | default value for a given type
-- this is used in cases where a value is not set in the constructor
defaultSlotValue :: SlotType -> T.Text
defaultSlotValue (StorageMapping xs t) = parens $
  "fun "
  <> T.unwords (replicate (length (NE.toList xs)) "_")
  <> " => "
  <> defaultVal t
defaultSlotValue (StorageValue t) = defaultVal t

defaultVal :: ValueType -> T.Text
defaultVal (PrimitiveType t) = abiVal t
defaultVal (ContractType _) = error "Contracts must be explicitly initialized"

abiVal :: AbiType -> T.Text
abiVal (AbiUIntType _) = "0"
abiVal (AbiIntType _) = "0"
abiVal AbiAddressType = "0"
abiVal AbiStringType = strMod <> ".EmptyString"
abiVal _ = error "TODO: missing default values"

-- | coq syntax for an expression
coqexp :: T.Text -> Exp a -> T.Text
-- booleans
coqexp _ (LitBool _ True)  = "true"
coqexp _ (LitBool _ False) = "false"
coqexp s (And _ e1 e2)  = parens $ "andb "   <> coqexp s e1 <+> coqexp s e2
coqexp s (Or _ e1 e2)   = parens $ "orb"     <> coqexp s e1 <+> coqexp s e2
coqexp s (Impl _ e1 e2) = parens $ "implb"   <> coqexp s e1 <+> coqexp s e2
coqexp s (Eq _ _ e1 e2)   = parens $ coqexp s e1  <> " =? " <> coqexp s e2
coqexp s (NEq _ _ e1 e2)  = parens $ "negb " <> parens (coqexp s e1  <> " =? " <> coqexp s e2)
coqexp s (Neg _ e)      = parens $ "negb " <> coqexp s e
coqexp s (LT _ e1 e2)   = parens $ coqexp s e1 <> " <? "  <> coqexp s e2
coqexp s (LEQ _ e1 e2)  = parens $ coqexp s e1 <> " <=? " <> coqexp s e2
coqexp s (GT _ e1 e2)   = parens $ coqexp s e2 <> " <? "  <> coqexp s e1
coqexp s (GEQ _ e1 e2)  = parens $ coqexp s e2 <> " <=? " <> coqexp s e1

-- integers
coqexp _ (LitInt _ i) = T.pack $ show i
coqexp s (Add _ e1 e2) = parens $ coqexp s e1 <> " + " <> coqexp s e2
coqexp s (Sub _ e1 e2) = parens $ coqexp s e1 <> " - " <> coqexp s e2
coqexp s (Mul _ e1 e2) = parens $ coqexp s e1 <> " * " <> coqexp s e2
coqexp s (Div _ e1 e2) = parens $ coqexp s e1 <> " / " <> coqexp s e2
coqexp s (Mod _ e1 e2) = parens $ "Z.modulo " <> coqexp s e1 <> coqexp s e2
coqexp s (Exp _ e1 e2) = parens $ coqexp s e1 <> " ^ " <> coqexp s e2
coqexp _ (IntMin _ n)  = parens $ "INT_MIN "  <> T.pack (show n)
coqexp _ (IntMax _ n)  = parens $ "INT_MAX "  <> T.pack (show n)
coqexp _ (UIntMin _ n) = parens $ "UINT_MIN " <> T.pack (show n)
coqexp _ (UIntMax _ n) = parens $ "UINT_MAX " <> T.pack (show n)

coqexp s (InRange _ t e) = coqexp s (bound t e)

-- polymorphic
coqexp s (VarRef _ _ _ e) = entry s e
coqexp s (ITE _ b e1 e2) = parens $ "if "
                               <> coqexp s b
                               <> " then "
                               <> coqexp s e1
                               <> " else "
                               <> coqexp s e2

-- environment values
-- Relies on the assumption that Coq record fields have the same name
-- as the corresponding Haskell constructor
coqexp _ (IntEnv _ envVal) = parens $ T.pack (show envVal) <+> envVar
-- Contracts
coqexp s (Create _ cid args) = parens $ T.pack cid <> "." <> T.pack cid <+> envVar <+> coqargs s args
-- unsupported
coqexp _ Cat {} = error "bytestrings not supported"
coqexp _ Slice {} = error "bytestrings not supported"
coqexp _ ByStr {} = error "bytestrings not supported"
coqexp _ ByLit {} = error "bytestrings not supported"
coqexp _ ByEnv {} = error "bytestrings not supported"
coqexp _ Array {} = error "arrays not supported"

-- | coq syntax for a proposition
coqprop :: T.Text -> Exp a -> T.Text
coqprop _ (LitBool _ True)  = "True"
coqprop _ (LitBool _ False) = "False"
coqprop s (And _ e1 e2)  = parens $ coqprop s e1 <> " /\\ " <> coqprop s e2
coqprop s (Or _ e1 e2)   = parens $ coqprop s e1 <> " \\/ " <> coqprop s e2
coqprop s (Impl _ e1 e2) = parens $ coqprop s e1 <> " -> " <> coqprop s e2
coqprop s (Neg _ e)      = parens $ "not " <> coqprop s e
coqprop s (Eq _ _ e1 e2)   = parens $ coqexp s e1 <> " = "  <> coqexp s e2
coqprop s (NEq _ _ e1 e2)  = parens $ coqexp s e1 <> " <> " <> coqexp s e2
coqprop s (LT _ e1 e2)   = parens $ coqexp s e1 <> " < "  <> coqexp s e2
coqprop s (LEQ _ e1 e2)  = parens $ coqexp s e1 <> " <= " <> coqexp s e2
coqprop s (GT _ e1 e2)   = parens $ coqexp s e1 <> " > "  <> coqexp s e2
coqprop s (GEQ _ e1 e2)  = parens $ coqexp s e1 <> " >= " <> coqexp s e2
coqprop s (InRange _ t e) = coqprop s (bound t e)

coqprop _ e = error "ill formed proposition: " <> T.pack (show e)

-- | coq syntax for a typed expression
typedexp :: T.Text -> TypedExp -> T.Text
typedexp s (TExp _ _ e) = coqexp s e

entry :: T.Text -> TItem k a -> T.Text
entry _ (Item SByteStr _ _) = error "bytestrings not supported"
entry s (Item _ _ r) = ref s r

ref :: T.Text -> Ref k -> T.Text
ref s (SVar _ _ name) = parens $ T.pack name <+> s
ref _ (CVar _ _ name) = T.pack name
ref s (SArray _ r _ ixs) = parens $ ref s r <+> coqargs s (fst <$> ixs)
ref s (SMapping _ r _ ixs) = parens $ ref s r <+> coqargs s ixs
ref s (SField _ r cid name) = parens $ T.pack cid <> "." <> T.pack name <+> ref s r

-- | coq syntax for a list of arguments
coqargs :: T.Text -> [TypedExp] -> T.Text
coqargs s es = T.unwords (map (typedexp s) es)

fresh :: Id -> Fresh T.Text
fresh name = state $ \s -> (T.pack (name <> show s), s + 1)

fresh' :: Id -> Id -> Fresh (T.Text, T.Text)
fresh' constr term = state $ \s -> ((T.pack (constr <> show s), T.pack (term <> show s)), s + 1)

evalSeq :: Traversable t => (a -> Fresh b) -> t a -> t b
evalSeq f xs = evalState (sequence (f <$> xs)) 0

--- text manipulation ---

definition :: T.Text -> T.Text -> T.Text -> T.Text
definition name args value = T.unlines
  [ "Definition " <> name <+> args <> " :="
  , value <> "."
  ]

inductive :: T.Text -> T.Text -> T.Text -> [T.Text] -> T.Text
inductive name args indices constructors = T.unlines
  [ "Inductive " <> name <+> args <> " : " <> indices <> " :="
  , (T.concat $ ("| " <>) <$> constructors) <> "."
  ]

lemma :: T.Text -> T.Text -> T.Text -> T.Text -> T.Text
lemma name args claim proof = T.unlines
  [ "Lemma " <> name <+> args <> " : "
  , claim <> "."
  , proof
  ]

reachableInvariant :: T.Text
reachableInvariant = "Theorem inv_reach :\n forall (ENV : Env) (STATE : State) (P : Env -> State -> Prop),\n reachableFromInit (StateMachine ENV) STATE\n -> invariant P\n -> P ENV STATE.\n Proof.\n intros ENV STATE P Hreach HinvP.\n unfold reachableFromInit in Hreach.\n destruct Hreach as [Hinit Hmulti].\n apply step_multi_step with (P := fun s s' => P ENV s  -> P ENV s' ) in Hmulti.\n - apply Hmulti.\n apply StateMachine_invInit.\n + assumption.\n - intros s s' Hstep.\n apply StateMachine_invStep with (STATE := s) (STATE' := s') ; assumption.\n - unfold Relation_Definitions.reflexive.\n intros.\n assumption.\n - unfold Relation_Definitions.transitive.\n intros s1 s2 s3 Ht1 Ht2 Ht3.\n apply Ht2, Ht1.\n assumption.\n Qed."

-- | multiline implication
implication :: [T.Text] -> T.Text
implication xs = "   " <> T.intercalate "\n-> " xs

-- | wrap text in parentheses
parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

boolScope :: T.Text -> T.Text
boolScope s = "(" <> s <> ")%bool"

indent :: Int -> T.Text -> T.Text
indent n = T.unlines . fmap (T.replicate n " " <>) . T.lines

--- constants ---

-- | string module name
strMod :: T.Text
strMod  = "Str"

-- | base state name
baseVar :: T.Text
baseVar = "BASE"

stateType :: T.Text
stateType = "State"

stateVar :: T.Text
stateVar = "STATE"

nextVar :: T.Text
nextVar = "NEXT"

stateDecl :: T.Text
stateDecl = parens $ stateVar <> " : " <> stateType

stateDecl' :: T.Text
stateDecl' = parens $ stateVar <> "' : " <> stateType

stateConstructor :: T.Text
stateConstructor = "state"

returnSuffix :: T.Text
returnSuffix = "_ret"

postSuffix :: T.Text
postSuffix = "_post"

invInitSuffix :: T.Text
invInitSuffix  = "_invInit"

invStepSuffix :: T.Text
invStepSuffix  = "_invStep"

baseSuffix :: T.Text
baseSuffix = "_base"

stepSuffix :: T.Text
stepSuffix = "_step"

introSuffix :: T.Text
introSuffix = "_intro"

stepType :: T.Text
stepType = "step"

initType :: T.Text
initType = "init"

multistepType :: T.Text
multistepType = "multistep"

reachableType :: T.Text
reachableType = "reachable"

reachableFromInitType :: T.Text
reachableFromInitType = "reachableFromInit"

reachStep:: T.Text
reachStep= "reach_step"

envType :: T.Text
envType = "Env"

envVar :: T.Text
envVar = "ENV"

envDecl :: T.Text
envDecl = parens $ envVar <> " : " <> envType

anon :: T.Text
anon = "_binding_"

(<+>) :: T.Text -> T.Text -> T.Text
t1 <+> t2 = t1 <> " " <> t2

