{-
 -
 - coq backend for act
 -
 - unsupported features:
 - + bytestrings
 - + external storage
 - + casting from addresses to contract
 -
 - TODO: flip to create Sets for i.e. in addressIm
 - TODO: integer bounds on calldata, and address constrains as well
 - TODO: Replace THIS with NextAddr in constrs
 - TODO: Maybe _creates and _updates are inductive as well?
 - TODO: initBefore will maybe need to return new NextAddr
 - TODO: Consistent predicate
 - -}

{-# Language OverloadedStrings #-}
{-# Language RecordWildCards #-}
{-# LANGUAGE GADTs #-}
{-# Language DataKinds #-}
{-# Language ViewPatterns #-}


module Act.Coq where

import Prelude hiding (GT, LT)

import Data.Map.Strict (Map)
import Data.Tuple.Extra
import qualified Data.Map.Strict    as M
import qualified Data.List.NonEmpty as NE
import qualified Data.Text          as T
import Data.List.Extra (snoc, unsnoc)
import Control.Monad.State
import Data.Maybe (mapMaybe)

import EVM.ABI
import Act.Syntax
import Act.Syntax.TypedExplicit

type Fresh = State Int

header :: T.Text
header = T.unlines
  [ "(* --- GENERATED BY ACT --- *)\n"
  , "Require Import Stdlib.ZArith.ZArith."
  , "Require Import ActLib.ActLib."
  , "Require Stdlib.Strings.String.\n"
  , "Module " <> strMod <> " := Stdlib.Strings.String."
  , "Open Scope Z_scope.\n"
  ]

-- | produce a coq representation of a specification
coq :: Act -> T.Text
coq (Act store contracts) =
  header <> (T.intercalate "\n\n" $ contractCode store <$> contracts)

contractCode :: StorageTyping -> Contract -> T.Text
contractCode store (Contract _ ctor@Constructor{..} behvs) = T.unlines $
  [ "Module " <> T.pack _cname <> ".\n" ]
  <> [ stateRecord ]
  <> [ contractAddressIn _cname store ]
  -- <> [ addressIn _cname store ]
  <> [ noAliasing _cname store ]
  -- <> [ intBounds _cname store ]
  <> [ intBoundsRec _cname store ]
  <> [ nextAddrConstraint ]
  <> [ constructorCode store ctor ]
  <> ( behaviourCode store <$> behvs )
  <> [ localStep _cname behvs]
  <> [ extStep _cname store ]
  <> [ step ]
  <> [ multistep ]
  <> [ reachable ]
  <> [ reachableFromInit ctor]
  <> [ stepBefore ]
  <> [ multistepBefore ]
  <> [ reachableBefore ]
  <> ( postCondConstr ctor )
  <> ( concatMap postCondBehv behvs )
  <> [ invariantInit ctor ]
  <> [ invariantStep ctor ]
  <> [ invariantReachable ctor]
  <> [ "End " <> T.pack _cname <> "." ]
  where

    stateRecord = T.unlines

      [ "Record" <+> stateType <+> ": Set :=" <+> stateConstructor
      , "{ " <> T.intercalate ("\n" <> "; ") (addrFieldDecl : map decl (M.toList store'))
      , "}."
      ]

    decl (n, (s, _)) = (T.pack n) <> " : " <> valueType s

    store' = contractStore _cname store

constructorCode :: StorageTyping -> Constructor -> T.Text
constructorCode store (Constructor cname iface _ precs cases _ invs) = T.unlines $
  [ initPrecs iface precs ]
  -- <> evalSeq (ctorCreates store cname iface) cases
  -- <> [ ctorCall cname iface cases ]
  <> [ construction' store cname iface cases ]
  -- <> [ initState cname iface cases ]
  <> [ initState' cname iface cases ]
  <> [ initStateBefore' cname iface cases ]
  <> [ invariants iface invs ]

-- | definition of constructor preconditions
initPrecs :: Interface -> [Exp ABoolean] -> T.Text
initPrecs i conds = inductive
  initPrecsType (envDecl <+> interface i <+> nextAddrDecl) "Prop" [("ctorPreconds", Nothing, body)]
  where
    body = indent 2 . implication . concat $
      [ coqprop <$> conds
      , interfaceConstraints i
      , coqbound ("Caller" <+> envVar) (ValueType TAddress)
      , coqbound ("Origin" <+> envVar) (ValueType TAddress)
      , coqbound ("This" <+> envVar) (ValueType TAddress)
      , ["Caller" <+> envVar <+> "<" <+> nextAddrVar]
      , ["Origin" <+> envVar <+> "<" <+> nextAddrVar]
      , ["This" <+> envVar <+> "=" <+> nextAddrVar]
      , [ initPrecsType <+> envVar <+> arguments i <+> nextAddrVar ]
      ]

{-
ctorCreates :: StorageTyping -> Id -> Interface -> Ccase -> Fresh T.Text
ctorCreates store name iface (Case _ _ updates) = do
  name' <- freshId name
  let createsName = name' <> "_creates"
  pure $ base store name createsName iface updates

ctorCall :: Id -> Interface -> [Ccase] -> T.Text
ctorCall name iface cases = case unsnoc (zip ([0..] :: [Int]) cases) of
  Just (cases', (lastCaseNum, _)) ->
    definition (T.pack name <> "_call") (nextAddrDecl <+> envDecl <+> interface iface)
    (foldr iteCase (caseText lastCaseNum) cases')
  Nothing -> error "Internal error: empty constructor cases list"
  where
    caseText i = T.pack (name <> show i) <> "_creates" <+> nextAddrVar <+> envVar <+> arguments iface

    iteCase :: (Int, Ccase) -> T.Text -> T.Text
    iteCase (i, (Case _ casecond _)) elseText =
      "if" <+> (coqbool casecond) <+>
      "then" <+> caseText i <+>
      "else" <+> elseText
      -}

indicesList :: [T.Text] -> T.Text
indicesList is = T.intercalate " -> " is

argList :: [T.Text] -> T.Text
argList = T.unwords

constructorType :: T.Text
constructorType = "constructor"

-- | Relation characterizing constructor calls
construction' :: StorageTyping -> Id -> Interface -> Cases [StorageUpdate] -> T.Text
construction' store name i cases = inductive
  constructorType
  (argList $ [envDecl] <> interface' i <> [nextAddrDecl])
  (indicesList [stateType, addressType, "Prop"])
  (evalSeq caseCtor cases)
  where
    baseval n = parens $ "snd" <+> parens (T.pack n <+> nextAddrVar <+> envVar <+> arguments i)


    caseCtor :: Ccase -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (Case _ caseCond updates) = do
      name' <- freshId name
      let createsName = name' <> "_creates"
      let body = (indent 2) . implication . concat $
            [ [initPrecsType <+> envVar <+> arguments i <+> nextAddrVar ]
            , [ coqprop caseCond ]
            , bindingsHyp
            , [constructorType <+> envVar <+> arguments i <+> nextAddrVar <+> parens s <+> parens (iNextAddr finalI)]
            ]
      pure (T.pack name', argList <$> bindingsNames, body)
      where 
        (s, bindings, finalI) = stateval True store name (\_ t -> defaultVal t) updates
        bindingsHyp = snd <$> bindings
        bindingsNames = case concatMap fst bindings of
          [] -> Nothing
          l -> Just l

-- | predicate characterizing all initial (post constructor) states
initState' :: Id -> Interface -> Cases [StorageUpdate] -> T.Text
initState' name i cases = inductive
  initStateType (stateVar) (indicesList ["Prop"]) ccase
  -- [("InitState", Just $ envDecl <+> interface i, constructorBody)]
  where
    ccase = [(T.pack "fromConstructor", Just $ argList $ [envDecl] <> interface' i <> [nextAddrDecl, nextAddrDecl'], body)]
    body = indent 2 . implication $
      [ constructorType <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar <+> nextAddrVar'
      , initStateType <+> stateVar
      ]


-- | predicate characterizing all initial (post constructor) states
initState :: Id -> Interface -> Cases [StorageUpdate] -> T.Text
initState name i cases = inductive
  initStateType "" (stateType <+> "->" <+> "Prop") (evalSeq caseCtor cases) -- [("InitState", Just $ envDecl <+> interface i, constructorBody)]
  where
    baseval n = parens $ "snd" <+> parens (T.pack n <+> nextAddrVar <+> envVar <+> arguments i)

    caseCtor :: Ccase -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (Case _ caseCond _) = do
      name' <- freshId name
      let createsName = name' <> "_creates"
      let body = (indent 2) . implication . concat $
            [ [initPrecsType <+> nextAddrVar <+> envVar <+> arguments i]
            , interfaceConstraints i
            , coqbound ("Caller" <+> envVar) (ValueType TAddress)
            , coqbound ("Origin" <+> envVar) (ValueType TAddress)
            , coqbound ("This" <+> envVar) (ValueType TAddress)
            , ["Caller" <+> envVar <+> "<" <+> nextAddrVar]
            , ["Origin" <+> envVar <+> "<" <+> nextAddrVar]
            , ["This" <+> envVar <+> "=" <+> nextAddrVar]
            , [ coqprop caseCond ]
            , [initStateType <+> baseval createsName]
            ]
      pure (T.pack name', Just $ nextAddrDecl <+> envDecl <+> interface i, body)

-- | predicate characterizing all initial (post constructor) states
initStateBefore' :: Id -> Interface -> Cases [StorageUpdate] -> T.Text
initStateBefore' name i cases = inductive
  initStateBeforeType (boundDecl <+> stateVar) (indicesList ["Prop"]) ccase
  where
    ccase = [(T.pack "fromConstructorBefore", Just $ argList $ [envDecl] <> interface' i <> [nextAddrDecl, nextAddrDecl'], body)]
    body = indent 2 . implication $
      [ constructorType <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar <+> nextAddrVar'
      , (nextAddrVar' <+> "<=" <+> boundVar)
      , initStateBeforeType <+> boundVar <+> stateVar 
      ]

-- | predicate characterizing all initial (post constructor) states that can be instantiated before a given environment
initStateBefore :: Id -> Interface -> Cases [StorageUpdate] -> T.Text
initStateBefore name i cases = inductive
  initStateBeforeType "" (boundType <+> "->" <+> stateType <+> "->" <+> "Prop") (evalSeq caseCtor cases)
  where
    baseval n = parens $ "snd" <+> parens (T.pack n <+> nextAddrVar <+> envVar <+> arguments i)
    finalAddr n = parens $ "fst" <+> parens (T.pack n <+> nextAddrVar <+> envVar <+> arguments i)

    caseCtor :: Ccase -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (Case _ caseCond _) = do
      name' <- freshId name
      let createsName = name' <> "_creates"
      let body = (indent 2) . implication . concat $
            [ [initPrecsType <+> nextAddrVar <+> envVar <+> arguments i]
            , interfaceConstraints i
            , ["Caller" <+> envVar <+> "<" <+> nextAddrVar]
            , ["Origin" <+> envVar <+> "<" <+> nextAddrVar]
            , ["This" <+> envVar <+> "=" <+> nextAddrVar]
            , [ finalAddr createsName <+> "<=" <+> boundVar]
            , [ coqprop caseCond ]
            , [initStateBeforeType <+> boundVar <+> baseval createsName]
            ]
      pure (T.pack name' <> "_before", Just $ boundDecl <+> nextAddrDecl <+> envDecl <+> stateDecl <+> interface i, body)


behaviourCode :: StorageTyping -> Behaviour -> T.Text
behaviourCode store (Behaviour name cname iface _ precs cases _) = T.unlines $
  [ behvConds name iface precs ]
  <> [ behvPred store name cname iface cases ]
  <> [ retVal name iface cases ]

-- | definition of behaviour-case conditions
behvConds :: Id -> Interface -> [Exp ABoolean] -> T.Text
behvConds name i conds = do
  inductive
    (T.pack name <> "_conds") (envDecl <+> interface i <+> stateDecl <+> nextAddrDecl ) "Prop" [((T.pack name <> "_condsC"), Nothing, body name)]
  where
    body n = indent 2 . implication . concat $
      [ coqprop <$> conds
      , [ nextAddrConstraintType <+> nextAddrVar <+> stateVar ]
      , interfaceConstraints i
      , coqbound ("Caller" <+> envVar) (ValueType TAddress)
      , coqbound ("Origin" <+> envVar) (ValueType TAddress)
      , coqbound ("This" <+> envVar) (ValueType TAddress)
      , ["This" <+> envVar <+> "<" <+> nextAddrVar]
      , ["Caller" <+> envVar <+> "<" <+> nextAddrVar]
      , ["Origin" <+> envVar <+> "<" <+> nextAddrVar]
      , ["This" <+> envVar <+> "<>" <+> "Caller" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Origin" <+> envVar]
      , ["This" <+> envVar <+> "=" <+> addrField <+> stateVar ]
      , [ (T.pack n <> "_conds") <+> envVar <+> arguments i <+> stateVar <+>nextAddrVar ]
      ]

behvUpdates :: StorageTyping -> Id -> Id -> Interface -> Bcase -> Fresh T.Text
behvUpdates store name cname iface (Case _ _ (updates, _)) = do
  name' <- freshId name
  let createsName = name' <> "_updates"
  pure $ transition store createsName cname iface updates


behvCall :: Id -> Interface -> [Bcase] -> T.Text
behvCall name iface cases = case unsnoc (zip ([0..] :: [Int]) cases) of
  Just (cases', (lastCaseNum, _)) ->
    definition (T.pack name <> "_call") (nextAddrDecl <+> envDecl <+> stateDecl <+> interface iface)
    (foldr iteCase (caseText lastCaseNum) cases')
  Nothing -> error "Internal error: empty constructor cases list"
  where
    caseText i = T.pack (name <> show i) <> "_updates" <+> nextAddrVar <+> envVar <+> stateVar <+> arguments iface

    iteCase :: (Int, Bcase) -> T.Text -> T.Text
    iteCase (i, (Case _ casecond _)) elseText =
      "if" <+> (coqbool casecond) <+>
      "then" <+> caseText i <+>
      "else" <+> elseText

behvPred :: StorageTyping -> Id -> Id -> Interface -> [Bcase] -> T.Text
behvPred store name cname i cases = inductive
  (T.pack name <> "_transition") (argList $ [envDecl] <> interface' i <> [stateDecl, nextAddrDecl])  (indicesList $ [stateType, addressType, "Prop"]) caseCtors
  where
    caseCtors = (evalSeq caseCtor cases)

    caseCtor :: Bcase -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (Case _ caseCond (updates, _)) = do
      name' <- fresh name
      pure (name' <> stepSuffix, T.unwords <$> bindingsNames, caseBody caseCond name')
      where 
        (s, bindings, finalI) = stateval False store cname (\r _ -> ref r) updates
        bindingsHyp = snd <$> bindings
        bindingsNames = case concatMap fst bindings of
          [] -> Nothing
          l -> Just l

        caseBody c _ = (indent 2) . implication . concat $
          [ [(T.pack name) <> "_conds" <+> envVar <+> arguments i <+> stateVar <+> nextAddrVar ]
          , [ coqprop c ]
          , bindingsHyp
          , [ (T.pack name <> "_transition") 
            <+> envVar
            <+> arguments i
            <+> stateVar
            <+> nextAddrVar
            <+> parens s
            <+> parens (iNextAddr finalI)
            ]
          ]

{-
behvPred :: Id -> Interface -> [Bcase] -> T.Text
behvPred name i cases = inductive
  (T.pack name <> "_transition") "" (nextAddrType <+> "->" <+> nextAddrType <+> "->" <+> envType <+> "->" <+> stateType <+> "->" <+> stateType <+> interfaceType i <+> "-> Prop") caseCtors
  where
    caseCtors = (evalSeq caseCtor cases)

    caseCtor :: Bcase -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (Case _ caseCond _) = do
      name' <- fresh name
      pure (name' <> stepSuffix, Just $ nextAddrDecl <+> nextAddrDecl' <+> envDecl <+> interface i <+> stateDecl, caseBody caseCond name')

    caseBody c n = (indent 2) . implication . concat $
      [ [(T.pack name) <> "_conds" <+> nextAddrVar <+> envVar <+> stateVar <+> arguments i]
      , [ nextAddrConstraintType <+> nextAddrVar <+> stateVar ]
      , interfaceConstraints i
      , ["This" <+> envVar <+> "<" <+> nextAddrVar]
      , ["Caller" <+> envVar <+> "<" <+> nextAddrVar]
      , ["Origin" <+> envVar <+> "<" <+> nextAddrVar]
      , ["This" <+> envVar <+> "<>" <+> "Caller" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Origin" <+> envVar]
      , ["This" <+> envVar <+> "=" <+> addrField <+> stateVar ]
      , [ coqprop c ]
      , [ (T.pack name <> "_transition") <+> nextAddrVar
        <+> parens ("fst" <+> parens ( n <> "_updates" <+> nextAddrVar <+> envVar <+> stateVar <+> arguments i))
        <+> envVar
        <+> stateVar
        <+> parens ("snd" <+> parens ( n <> "_updates" <+> nextAddrVar <+> envVar <+> stateVar <+> arguments i))
        <+> arguments i ]
      ]
-}


-- | Inductive definition of step relation of 2 states
-- that takes into account only transitions of the current contract type
localStep :: Id -> [Behaviour] -> T.Text
localStep contract behvs = inductive
  (localStepType contract) (argList [envDecl, stateDecl, nextAddrDecl, stateDecl', nextAddrDecl']) ("Prop") (stepBehv <$> behvs)
  where
    -- | constructor for the step relation
    stepBehv :: Behaviour -> (T.Text, Maybe T.Text, T.Text)
    stepBehv (Behaviour name _ i _ _ _ _) = (T.pack name <> stepSuffix, bindings, constructorBody)
      where
        bindings = case interface i of
          "" -> Nothing
          i' -> Just $ i'
        constructorBody = implication
          [T.pack name <> "_transition" <+> envVar <+> arguments i <+> stateVar <+> nextAddrVar <+> stateVar' <+> nextAddrVar' 
          , localStepType contract <+> envVar <+> stateVar <+> nextAddrVar <+> stateVar' <+> nextAddrVar']

-- | Constraint on Env expressing that the NextAddr field should be greated than
-- all addresses contained in the state
nextAddrConstraint :: T.Text
nextAddrConstraint = definition
  nextAddrConstraintType (nextAddrDecl <+> stateDecl) body
    where
      body = indent 2 $ forAll (parens ("p : address")) <+>
        (addressInType <+> stateVar <+> "p" ) <+> "->" <+> (nextAddrVar <+> "> p")

-- | Inductive definition of step relation of 2 states
-- that takes into account transitions of the current contract type
-- and all transitions possible for contained contracts
extStep :: Id -> StorageTyping -> T.Text
extStep main store = inductive
  extStepType (argList [envDecl, stateDecl, nextAddrDecl, stateDecl', nextAddrDecl']) "Prop" body
    where
    body =
      (extStepType <> "_" <> T.pack main, Nothing
      , indent 2 $ implication [localStepType main <+> envVar <+> stateVar <+> nextAddrVar <+> stateVar' <+> nextAddrVar', extStepType <+> envVar <+> stateVar <+> nextAddrVar <+> stateVar' <+> nextAddrVar'])
      : (M.elems $ M.mapMaybeWithKey substep localStore)

    localStore = contractStore main store

    substep :: Id -> (ValueType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    substep var (ValueType (TContract cid), _) = Just (extStepType <> "_" <> varp, Nothing, body')
      where
        varp = T.pack var
        body' = indent 2 . implication . concat $
          [ [ nextAddrConstraintType <+> nextAddrVar <+> stateVar ]
          , [ "Origin" <+> envVar <+> "<>" <+> addrField <+> stateVar ]
          , [ "Caller" <+> envVar <+> "<>" <+> addrField <+> stateVar ]
          , [ integerBoundsType <+> stateVar ]
          , [ T.pack cid <.> extStepType <+> envVar <+> parens (varp <+> stateVar) <+> nextAddrVar <+> parens (varp <+> stateVar') <+> nextAddrVar' ]
          , [ addrField <+> stateVar <+> "=" <+> addrField <+> stateVar' ]
          , (\var' -> parens (T.pack var' <+> stateVar) <+> "=" <+> parens (T.pack var' <+> stateVar')) <$> (filter (var /=) $ M.keys localStore)
          -- , (M.elems $ M.mapMaybeWithKey (subBounds var) localStore)
          , [ extStepType <+> envVar <+> stateVar <+> nextAddrVar <+> stateVar' <+> nextAddrVar' ]
          ]
    substep _ _ = Nothing

    subBounds :: Id -> Id -> (ValueType, Integer) -> Maybe T.Text
    subBounds stepVar var (ValueType (TContract cid), _) | var /= stepVar = Just $ T.pack cid <.> integerBoundsType <+> parens (T.pack var <+> stateVar)
    subBounds _ _ _ = Nothing



step :: T.Text
step =
  definition stepType (stateDecl <+> stateDecl') $
    "exists" <+> envDecl <+> nextAddrDecl <+> nextAddrDecl' <> "," <+> extStepType <+> envVar <+> stateVar <+> nextAddrVar <+> stateVar' <+> nextAddrVar'

stepBefore :: T.Text
stepBefore =
  definition stepBeforeType (boundDecl <+> stateDecl <+> stateDecl') $
    "exists" <+> envDecl <+> nextAddrDecl <+> nextAddrDecl' <> "," <+> extStepType <+> envVar <+> stateVar <+> nextAddrVar <+> stateVar'<+> nextAddrVar' 
    <+> "/\\" <+> nextAddrVar' <+> "<=" <+> boundVar


combine :: [a] -> [(a,a)]
combine lst = combine' lst []
  where
    combine' [] acc = concat acc
    combine' (x:xs) acc =
      let xcomb = [ (x, y) | y <- xs] in
      combine' xs (xcomb:acc)

-- | Predicate that holds if p is an address of known contract type
-- in the given state
contractAddressIn :: Id -> StorageTyping -> T.Text
contractAddressIn name store = inductive
  contractAddressInType (argList [stateDecl]) (indicesList [addressType, "Prop"]) body
  where
    body = ("addressOf_This", Nothing, indent 5 $ contractAddressInType <+> stateVar <+> parens (addrField <+> stateVar))
           : M.elems (M.mapMaybeWithKey subCAddr localStore)

    localStore = contractStore name store

    subCAddr :: Id -> (ValueType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    subCAddr var (ValueType (TContract cid), _) = Just ("addressOf_" <> varp, Just $ parens ("p :" <+> addressType), body')
      where
        varp = T.pack var
        body' = indent 2 . implication $
          [ T.pack cid <.> contractAddressInType <+> parens (varp <+> stateVar) <+> "p"
          , contractAddressInType <+> stateVar <+> "p"
          ]
    subCAddr _ _ = Nothing

{-
-- | Predicate that holds if p is an address in the given state
addressIn :: Id -> StorageTyping -> T.Text
addressIn name store = inductive
  addressInType "" ("Z" <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = ("address_addr", Just stateDecl, indent 5 $ addressInType <+> parens (addrField <+> stateVar) <+> stateVar)
           : ("address_subcontract", Just $ parens ("p : address") <+> stateDecl, indent 5 $ contractAddressInType <+> "p" <+> stateVar <+> "->" <+> addressInType <+> "p" <+> stateVar)
           : M.elems (M.mapMaybeWithKey subAddr localStore)

    localStore = contractStore name store

    subAddr :: Id -> (ValueType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    subAddr var (ValueType TAddress, _) =
      let varp = T.pack var in
      Just ("address_" <> varp, Just stateDecl, indent 5 $ addressInType <+>  parens (varp <+> stateVar) <+> stateVar)
    subAddr _ _ = Nothing
  -}

slotContractName :: ValueType -> Maybe Id
slotContractName (ValueType (TContract cid)) = Just cid
slotContractName _ = Nothing

noAliasing :: Id -> StorageTyping -> T.Text
noAliasing name store = inductive
  noAliasingType stateDecl "Prop" [("noAliasingC", Nothing, body)]
  where
    body = indent 2 . implication $
      (addressSubContractAliasing <$> storeContracts)
      <> (contractPairAliasing <$> contractPairs)
      <> (subContractAliasing <$> storeContracts)
      <> [noAliasingType <+> stateVar]

    localStore = contractStore name store
    storeContracts = M.toList $ M.mapMaybe (slotContractName . fst) localStore
    contractPairs = filter (not. uncurry (==)) $ combine storeContracts

    addressSubContractAliasing :: (Id, Id) -> T.Text
    addressSubContractAliasing (cvar, cid) =
      parens $ forAll (parens ("p : address")) <+>
        ( T.pack cid <.> contractAddressInType <+> parens (T.pack cvar <+> stateVar) <+> "p") <+> "->"
        <+> (parens (addrField <+> stateVar) <+> "<>" <+> "p")

    contractPairAliasing :: ((Id, Id), (Id, Id)) -> T.Text
    contractPairAliasing ((cvar1, cid1), (cvar2, cid2)) =
      parens $ forAll (parens ("p p' : address")) <+>
        ( T.pack cid1 <.> contractAddressInType <+> parens (T.pack cvar1 <+> stateVar) <+> "p") <+> "->"
        <+> ( T.pack cid2 <.> contractAddressInType <+> parens (T.pack cvar2 <+> stateVar) <+> "p'") <+> "->"
        <+> ("p" <+> "<>" <+> "p'")

    subContractAliasing :: (Id, Id) -> T.Text
    subContractAliasing (cvar, cid) = T.pack cid <.> noAliasingType <+> parens (T.pack cvar <+> stateVar)

{-
intBounds :: Id -> StorageTyping -> T.Text
intBounds name store = inductive
  "integerBounds" stateDecl "Prop" [("integerBoundsC", Nothing, body)]
  where
    body = indent 2 . implication $ ((M.elems $ M.mapMaybeWithKey go localStore) <> ["integerBounds" <+> stateVar])

    localStore = contractStore name store

    go :: Id -> (ValueType, Integer) -> Maybe T.Text
    go v (ValueType (TContract cid), _) = Just $
      "0 <=" <+> T.pack cid <.> addrField <+> parens (T.pack v <+> stateVar) <+> "<= UINT_MAX 160"
    go v (ValueType TAddress, _) = Just $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX 160"
    go v (ValueType (TInteger n Unsigned), _) = Just $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX" <+> T.pack (show n)
    go v (ValueType (TInteger n Signed), _) = Just $
      "INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> "<= INT_MAX" <+> T.pack (show n)
    go v (ValueType t@(TMapping _ _), _) = case unfoldMappingType t of
      (length -> i, ValueType TAddress) -> pure $ parens $
        "forall" <+> ixs i <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= UINT_MAX 160"
      (length -> i, ValueType (TInteger n Unsigned)) -> pure $ parens $
        "forall" <+> ixs i <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= UINT_MAX" <+> T.pack (show n)
      (length -> i, ValueType (TInteger n Signed)) -> pure $ parens $
        "forall" <+> ixs i <> ", INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= INT_MAX" <+> T.pack (show n)
      _ -> Nothing
    go _ _ = Nothing

    ixs n = T.unwords $ T.pack . (<>) "i" . show <$> [0..(n-1)]
    -}

coqbound :: T.Text -> ValueType -> [T.Text]
coqbound v (ValueType (TContract cid)) =
  [ "0 <=" <+> T.pack cid <.> addrField <+> parens v <+> "<= UINT_MAX 160"
  , T.pack cid <.> integerBoundsType <+> parens v ]
coqbound v (ValueType TAddress) = pure $
  "0 <=" <+> v <+> "<= UINT_MAX 160"
coqbound v (ValueType (TInteger n Unsigned)) = pure $
  "0 <=" <+> v <+> "<= UINT_MAX" <+> T.pack (show n)
coqbound v (ValueType (TInteger n Signed)) = pure $
  "INT_MIN" <+> T.pack (show n) <+> "<=" <+> v <+> "<= INT_MAX" <+> T.pack (show n)
coqbound v (ValueType t@(TMapping _ _)) = case unfoldMappingType t of
  (length -> i, ValueType TAddress) -> pure $ parens $
    "forall" <+> ixs i <> ", 0 <=" <+> v <+> ixs i <+> "<= UINT_MAX 160"
  (length -> i, ValueType (TInteger n Unsigned)) -> pure $ parens $
    "forall" <+> ixs i <> ", 0 <=" <+> v <+> ixs i <+> "<= UINT_MAX" <+> T.pack (show n)
  (length -> i, ValueType (TInteger n Signed)) -> pure $ parens $
    "forall" <+> ixs i <> ", INT_MIN" <+> T.pack (show n) <+> "<=" <+> v <+> ixs i <+> "<= INT_MAX" <+> T.pack (show n)
  _ -> []
  where
    ixs n = T.unwords $ T.pack . (<>) "i" . show <$> [0..(n-1)]
coqbound _ _ = []

intBoundsRec :: Id -> StorageTyping -> T.Text
intBoundsRec name store = inductive
  integerBoundsType stateDecl "Prop" [("integerBoundsC", Nothing, body)]
  where
    body = indent 2 . implication . concat $ ((M.elems $ M.mapWithKey go localStore) <> [[integerBoundsType <+> stateVar]])

    localStore = contractStore name store

    go :: Id -> (ValueType, Integer) -> [T.Text]
    go v (t,_) = coqbound (T.pack v <+> stateVar) t

interfaceConstraints :: Interface -> [T.Text]
interfaceConstraints i@(Interface _ decls) = concatMap go decls <> interfaceConsistency i
  where go (Arg t@(ContractArg _ cid) v) =
          [ T.pack cid <.> nextAddrConstraintType <+> nextAddrVar <+> T.pack v
          , T.pack cid <.> reachableBeforeType <+> nextAddrVar <+> T.pack v ]
          <> coqbound (T.pack v) (argToValueType t)
        go (Arg t@(AbiArg _) v) =
          coqbound (T.pack v) (argToValueType t)

-- NOTE: do we also need to compare within the given states? see hevm/pass/cast-4
interfaceConsistency :: Interface -> [T.Text]
interfaceConsistency (Interface _ decls) = (uncurry consistency) <$> contractArgPairs
  where
    contractArgs = mapMaybe contractArg decls
    contractArgPairs = combine contractArgs

    contractArg (Arg (ContractArg _ c) v) = Just (c,v)
    contractArg _ = Nothing

    consistency :: (Id, Id) -> (Id, Id) -> T.Text
    consistency (c1, a1) (c2, a2) =
      T.pack c1 <.> addrField <+> T.pack a1 <+> "=" <+> T.pack c2 <.> addrField <+> T.pack a2
      <+> "->" <+> T.pack a1 <+> "=" <+> T.pack a2


{-
interfaceStateVarsConstraints :: Interface -> [T.Text]
interfaceStateVarsConstraints (Interface _ decls) = concatMap go decls
  where go (Arg (ContractArg _ cid) v) =
          [ T.pack cid <.> nextAddrConstraintType <+> nextAddrVar <+> T.pack v
          , T.pack cid <.> reachableBeforeType <+> nextAddrVar <+> T.pack v ]
        go _ = []
        -}

-- | definition of reachable states
reachable :: T.Text
reachable = definition
  reachableType args value
  where
    args = parens $ stateVar <+> ":" <+> stateType
    value = "exists" <+> stateVar' <> "," <+> initStateType <+> stateVar'
      <+> "/\\" <+> multistepType <+> stateVar' <+> stateVar

reachableBefore :: T.Text
reachableBefore = definition
  reachableBeforeType args value
  where
    args = boundDecl <+> stateDecl
    value = "exists" <+> stateVar' <> "," <+> initStateBeforeType <+> boundVar <+> stateVar' 
      <+> "/\\" <+> multistepBeforeType <+> boundVar <+> stateVar' <+> stateVar

-- | specialization of generic multistep
multistep :: T.Text
multistep = definition
  multistepType args value
  where
    args = parens $ stateVar <+> stateVar' <+> ":" <+> stateType
    value = multistepType <+> stepType <+> stateVar <+> stateVar'

multistepBefore :: T.Text
multistepBefore = definition
  multistepBeforeType args value
  where
    args = boundDecl <+> stateDecl <+> stateDecl'
    value = "ActLib" <.> multistepType <+> parens (stepBeforeType <+> boundVar) <+> stateVar <+> stateVar'

-- | definition of reachable states from initial constructor parameters
reachableFromInit :: Constructor -> T.Text
reachableFromInit (Constructor _ i _ _ _ _ _ ) = definition
  reachableFromInitType args value
  where
    args = envDecl <+> interface i <+> nextAddrDecl <+> stateDecl
    value = "exists" <+> stateVar' <+> nextAddrVar' <> "," <+> constructorType <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar' <+> nextAddrVar'
      <+> "/\\" <+> multistepType <+> stateVar' <+> stateVar





-- | definition of a base state
base :: StorageTyping -> Id -> Id -> Interface -> [StorageUpdate] -> T.Text
base store name createsName i updates =
  let (s, bindings, finalI) = stateval True store name (\_ t -> defaultVal t) updates in
  definition (T.pack createsName) (nextAddrDecl <+> envDecl <+> interface i)
    (foldr (\(_,b) s' -> "let" <+> b <+> "in\n" <> s') (tuple (iNextAddr finalI) s) bindings)

transition :: StorageTyping -> Id -> Id -> Interface -> [StorageUpdate] -> T.Text
transition store name cname i rewrites =
  let (s, bindings, finalI) = stateval False store cname (\r _ -> ref r) rewrites in
  definition (T.pack name) (nextAddrDecl <+> envDecl <+> stateDecl <+> interface i)
    (foldr (\(_,b) s' -> "let" <+> b <+> "in\n" <> s') (tuple (iNextAddr finalI) s) bindings)

{-
behvPred :: StorageTyping -> Id -> Id -> Interface -> [Bcase] -> T.Text
behvPred store name cname i cases = inductive
(T.pack name <> "_transition") (argList $ [nextAddrDecl, envDecl] <> interface' i <> [stateDecl])  (indicesList $ [stateType, addressType, "Prop"]) caseCtors
where
  caseCtors = (evalSeq caseCtor cases)

  caseCtor :: Bcase -> Fresh (T.Text, Maybe T.Text, T.Text)
  caseCtor (Case _ caseCond (updates, _)) = do
    name' <- fresh name
    pure (name' <> stepSuffix, T.unwords <$> bindingsNames, caseBody caseCond name')
    where 
      (s, bindings, finalI) = stateval False store cname (\r _ -> ref r) updates
      bindingsHyp = snd <$> bindings
      bindingsNames = case concatMap fst bindings of
        [] -> Nothing
        l -> Just l

      caseBody c n = (indent 2) . implication . concat $
        [ [(T.pack name) <> "_conds" <+> nextAddrVar <+> envVar <+> stateVar <+> arguments i]
        , [ coqprop c ]
        , bindingsHyp
        , [ (T.pack name <> "_transition") <+> nextAddrVar
          <+> envVar
          <+> arguments i
          <+> stateVar
          <+> parens s
          <+> parens (iNextAddr finalI)
          ]
        ]
        -}

-- | inductive definition of a return claim
-- ignores claims that do not specify a return value
retVal :: Id -> Interface -> [Bcase] -> T.Text
retVal _ _ [] = ""
retVal _ _ ((Case _ _ (_,Nothing)):_) = ""
retVal name i cases@((Case _ _ (_, Just ret0)):_) = do
  inductive
    (T.pack name <> returnSuffix)
    (envDecl <+> interface i <+> stateDecl <+> nextAddrDecl )
    (returnType ret0 <> " -> Prop")
    caseCtors
  where
    retname n = n <> returnSuffix

    caseCtors = (evalSeq caseCtor cases)

    caseCtor :: Bcase -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (Case _ _ (_, Nothing)) = error "Internal error: Case does not return"
    caseCtor (Case _ caseCond (_, Just ret)) = do
      name' <- fresh name
      pure (name' <> returnSuffix, Nothing, caseBody)
      where 
        caseBody = (indent 2) . implication . concat $
          [ [(T.pack name) <> "_conds" <+> envVar <+> arguments i <+> stateVar <+> nextAddrVar ]
          , [ coqprop caseCond ]
          , [retname (T.pack name) <+> envVar <+> arguments i <+> stateVar <+> nextAddrVar <+> typedexp ret]
          ]

-- | Definition of postcondition claim for constructor
postCondConstr :: Constructor -> [T.Text]
postCondConstr (Constructor cname iface _ _ _ postcs _) = evalSeq (go cname iface) postcs
  where
  go :: Id -> Interface -> Exp ABoolean -> Fresh T.Text
  go name i postc = do
    postName <- fresh (name <> "_post")
    return $ definition postName "" body
    where
      body = indent 2 $ T.unlines
        [ forAll $ nextAddrDecl <+> envDecl <+> stateDecl' <+> interface i
        , implication . concat $
          [ [initPrecsType <+> nextAddrVar <+> envVar <+> arguments i]
          , [stateVar' <+> "=" <+> "snd" <+> parens (T.pack name <+> nextAddrVar <+> envVar <+> arguments i)]
          , [coqprop postc]
          ]
        ]

-- | Definition of postcondition claim for behaviour cases
-- TODO: need way to call behaviour with all cases, maybe through transition predicate?
postCondBehv :: Behaviour -> [T.Text]
postCondBehv (Behaviour bname _ iface _ _ _ postcs) = evalSeq (go bname iface) postcs
  where
  go :: Id -> Interface -> Exp ABoolean -> Fresh T.Text
  go name i postc = do
    postName <- fresh (name <> "_post")
    return $ definition postName "" (body postName)
    where
      body n = indent 2 $ T.unlines
        [ forAll $ nextAddrDecl <+> nextAddrDecl' <+> envDecl <+> stateDecl <+> stateDecl' <+> interface i
        , implication . concat $
          [ [T.pack bname <> "_conds" <+> envVar <+> arguments i <+> stateVar <+> nextAddrVar ]
          , [reachableType <+> stateVar]
          , [(T.pack bname <> "_transition" <+> envVar <+> arguments i <+> stateVar <+> nextAddrVar <+> stateVar'<+> nextAddrVar' )]
          , [coqprop postc]
          ]
        ]

-- | Definition of invariant proposition
invariants :: Interface -> [Invariant] -> T.Text
invariants _ [] = ""
invariants i invs =
  definition "invariants" (nextAddrDecl <+> envDecl <+> stateDecl <+> interface i) $ indent 2 . conjuction $ invariantProp <$> invs
  where
    invariantProp :: Invariant -> T.Text
    invariantProp (Invariant _ _ _ (PredTimed p _)) = coqprop p


-- | Definition of invariant claim at constructor poststate
invariantInit :: Constructor -> T.Text
invariantInit (Constructor _ i _ _ _ _ _) =
  definition invInitType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i <+> nextAddrDecl <+> stateDecl <+> nextAddrDecl'
      , implication . concat $
        [ [constructorType <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar <+> nextAddrVar']
        , [invPropVar <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar]
        ]
      ]

-- | Definition of invariant claim for behaviour cases
invariantStep :: Constructor -> T.Text
invariantStep (Constructor _ i _ _ _ _ _) =
  definition invStepType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i <+> nextAddrDecl <+> stateDecl <+> stateDecl' 
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i <+> nextAddrVar ]
        , [stepType <+> stateVar <+> stateVar']
        , [invPropVar <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar]
        , [invPropVar <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar']
        ]
      ]

-- | Lemma extending invariant properties' hold to reachable states,
-- given proof of init and step invariance
invariantReachable :: Constructor -> T.Text
invariantReachable (Constructor _ i _ _ _ _ _) =
  lemma invReachType "" claim proof
  where
    claim = indent 2 $ T.unlines
      [ forAll (envDecl <+> interface i <+> nextAddrDecl <+> stateDecl <+> invPropDecl i
        <+> parens ("HIPinvInit :" <+> invInitType <+> invPropVar) <+> parens ("HIPinvStep :" <+> invStepType <+> invPropVar))
      , implication . concat $
        [ [reachableFromInitType <+> envVar <+> arguments i <+> nextAddrVar <+> stateDecl ]
        , [invPropVar <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar]
        ]
      ]
    proof = T.unlines $
      [
        "Proof."
      , indent 2 . T.unlines $
        [ "intros" <+> envVar <+> arguments i <+> nextAddrVar <+> stateVar <+> invPropVar <+> "HIPinvInit HIPinvStep Hreach."
        , "unfold reachableFromInit in Hreach."
        , "destruct Hreach as [iState [iNA [Hinit Hmulti]]]."
        , "apply step_multi_step with (P := fun s s' =>" <+> invPropVar <+> envVar <+> arguments i <+> nextAddrVar <+> "s ->" <+> invPropVar <+> envVar <+> arguments i <+> nextAddrVar <+> "s' ) in Hmulti."
        , "- apply Hmulti."
        , "  eapply HIPinvInit; eassumption."
        , "- intros s s' Hstep."
        , "  destruct Hinit as [iNA' Hprecs]."
        , "  eapply HIPinvStep with (STATE := s) (STATE' := s'); eassumption."
        , "- unfold Relation_Definitions.reflexive."
        , "  intros."
        , "  assumption."
        , "- unfold Relation_Definitions.transitive."
        , "  intros s1 s2 s3 Ht1 Ht2 Ht3."
        , "  apply Ht2, Ht1."
        , "  assumption."
        ]
     , "Qed."
     ]

-- | produce a state value from a list of storage updates
-- 'handler' defines what to do in cases where a given name isn't updated
-- TODO Lefteris: the order of `NextAddr`'s increments will follow the order in which the storage slots are stored in `StorageTyping`,
-- which is alphabetical since it is a mapping keyed on names. This is a divergance from the formalization, where increments follow the order
-- in which the the storage variables are defined. Not really important as addresses currently cannot be compared (right?), but fix at some point.
stateval :: Bool -> StorageTyping -> Id -> (Ref LHS -> ValueType -> T.Text) -> [StorageUpdate] -> (T.Text, [([T.Text], T.Text)], Int)
stateval ctor store contract handler updates =
  let (texts, finalI) = runSeq (\(n, (t, _)) -> updateVar store updates handler (SVar nowhere Pre contract n) t) (M.toList store') (if ctor then 1 else 0)
      (vals, bindings) = unzip texts
      bindings' = concat bindings
      finalBindings = if ctor then env1Binding : bindings' else bindings'
      env1Binding = ([iNextAddr 1], "NextAddr1 = NextAddr + 1")
  in
  (T.unwords $ stateConstructor : addr : vals, finalBindings, finalI)
  where
    addr = if ctor then "NextAddr" else parens (T.pack contract <.> addrField <+> stateVar)
    store' = contractStore contract store


contractStore :: Id -> StorageTyping -> Map Id (ValueType, Integer)
contractStore contract store = case M.lookup contract store of
  Just s -> s
  Nothing -> error $ "Internal error: cannot find constructor of " <> contract <> " in store"


-- | Check is an update update a specific storage reference
eqRef :: Ref LHS -> StorageUpdate -> Bool
eqRef r (Update _ r' _) = r == r'

-- | Check if an update updates a location that has a given storage
-- reference as a base
baseRef :: Ref LHS -> StorageUpdate -> Bool
baseRef baseref (Update _ r _) = hasBase r
  where
    hasBase (SVar _ _ _ _) = False
    hasBase (RArrIdx _ r' _ _) = r' == baseref || hasBase r'
    --hasBase (RMapIdx _ r' _ _) = r' == baseref || hasBase r'
    hasBase (RField _ r' _ _) = r' == baseref || hasBase r'

iState :: Int -> T.Text
iState 0 = "STATE"
iState i = "STATE" <> T.pack (show i)

iNextAddr :: Int -> T.Text
iNextAddr 0 = "NextAddr"
iNextAddr i = "NextAddr" <> T.pack (show i)

updateExp :: Exp a -> Fresh (T.Text, [([T.Text],T.Text)])
updateExp (Create _ cid args payment) = do
  let paymentExp = maybe "0" coqexp payment
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) ([iState (i+1), iNextAddr (i+1)], T.pack cid <.> constructorType <+> parens ("CallEnv" <+> paymentExp <+> parens ("This ENV") <+> envVar) <+> T.unwords args' <+> iNextAddr i <+> iState (i+1) <+> iNextAddr (i+1))
  pure (iState (i+1), bindings)
updateExp (Address _ c (Create _ cid args payment)) = do
  let paymentExp = maybe "0" coqexp payment
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) ([iState (i+1), iNextAddr (i+1)], T.pack cid <.> constructorType <+> parens ("CallEnv" <+> paymentExp <+> parens ("This ENV") <+> envVar) <+> T.unwords args' <+> iNextAddr i <+> iState (i+1) <+> iNextAddr (i+1))
  pure (parens $ T.pack c <.> addrField <+> iState (i+1), bindings)
updateExp e = pure (coqexp e, [])

updateExpTyped :: TypedExp -> Fresh (T.Text, [([T.Text], T.Text)])
updateExpTyped (TExp _ te) = updateExp te

unField :: Ref LHS -> Ref LHS -> Ref LHS
unField rFocus (RField pn r cid x) | r == rFocus = SVar pn Pre cid x --TODO: Think about timing here
unField rFocus (RField pn r cid x) = RField pn (unField rFocus r) cid x
unField _ r' = r'

-- Returns the value of the state after all updates, as well as the relevant let-bindings for said state value
updateVar :: StorageTyping -> [StorageUpdate] -> (Ref LHS -> ValueType -> T.Text) -> Ref LHS -> ValueType -> Fresh (T.Text, [([T.Text], T.Text)])
updateVar store updates handler focus t@(ValueType (TContract cid)) =
  case unsnoc groupedUpdates of
    -- No update to relevant slot
    Nothing -> pure (handler focus t, [])
    -- Update of only the base slot, not any of the contract fields
    Just (_, (firstU@(Update _ _ e) NE.:| [])) | eqRef focus firstU->
      updateExp e
    -- Updates to the base slot and to the contracts fields
    Just (_, (firstU@(Update _ _ e) NE.:| nextUpdates)) | eqRef focus firstU-> do
      (newState, bindings) <- updateExp e
      (t', bindings') <- unzip <$> traverse (\(n, (t', _)) -> updateVar store nextUpdates (\r _ -> refState newState $ unField focus r) (focus' n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <.> stateConstructor) : parens (T.pack cid <.> addrField <+> newState) : t', bindings ++ concat bindings')
    -- Updates only to the files of the contract
    Just (_, fieldUpdates) -> do
      (t', bindings') <- unzip <$> traverse (\(n, (t', _)) -> updateVar store (NE.toList fieldUpdates) handler (focus' n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <.> stateConstructor) : parens (T.pack cid <.> addrField <+> refState stateVar focus) : t', concat bindings')
  where
    focus' x = RField nowhere focus cid x
    store' = contractStore cid store

    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates
    -- `groupedUpdates` groups all relevant updates by starting a new group 
    -- when an update to the base reference is encountered. Consequently
    -- all updates before the last group will be overwritten and so can be ignored
    groupedUpdates = NE.groupBy (\_ b -> not $ eqRef focus b) focusUpdates

updateVar _ updates handler focus t@(ValueType TAddress) =
  case unsnoc focusUpdates of
    Nothing -> pure (handler focus t, [])
    Just (_, (Update _ _ e)) -> updateExp e
  where
    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates

updateVar _ updates handler focus t@(ValueType (TMapping _ _)) =
  -- Note: If creates are allowed in indices then bindings should be collected from them.
  -- The result type cannot be a contract so no creates, and thus no bindings, are present there.
  pure (foldl updatedVal (handler focus t) (filter (eqRef focus) updates), [])
    where
      updatedVal _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = mappingExp e 0

updateVar _ updates handler focus t@(ValueType _) =
  pure (foldl updatedVal (handler focus t) (filter (eqRef focus) updates), [])
    where
      updatedVal _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = coqexp e



-- | produce a block of declarations from an interface
interface :: Interface -> T.Text
interface (Interface _ decls) =
  T.unwords $ map decl decls where
  decl (Arg (AbiArg AbiAddressType) name) = parens $ T.pack name <+> ":" <+> abiType AbiAddressType
  decl (Arg (ContractArg _ cid) name) = parens $ T.pack name <+> ":" <+> T.pack cid <.> "State"
  decl (Arg (AbiArg t) name) = parens $ T.pack name <+> ":" <+> abiType t

-- | produce a block of declarations from an interface
interface' :: Interface -> [T.Text]
interface' (Interface _ decls) =
  map decl decls where
  decl (Arg (AbiArg AbiAddressType) name) = parens $ T.pack name <+> ":" <+> abiType AbiAddressType
  decl (Arg (ContractArg _ cid) name) = parens $ T.pack name <+> ":" <+> T.pack cid <.> "State"
  decl (Arg (AbiArg t) name) = parens $ T.pack name <+> ":" <+> abiType t

interfaceType :: Interface -> T.Text
interfaceType (Interface _ []) = ""
interfaceType (Interface _ decls) = (T.pack "->") <+> (
  T.intercalate " -> " $ map decl decls)
  where
  decl (Arg (AbiArg AbiAddressType) _) = abiType AbiAddressType
  decl (Arg (ContractArg _ cid) _) = T.pack cid <.> "State"
  decl (Arg (AbiArg t) _) = abiType t

arguments :: Interface -> T.Text
arguments (Interface _ decls) =
  T.unwords $ map (\(Arg _ name) -> T.pack name) decls

-- | coq syntax for a value type
valueType :: ValueType -> T.Text
valueType (ValueType (TContract cid)) = T.pack cid <> "." <> "State" -- the type of a contract is its state record
valueType (ValueType (TMapping k t)) = valueType k <+> "->" <+> valueType t
valueType (ValueType t) = abiType $ toAbiType t

unfoldMappingType :: TValueType AMapping -> ([ValueType], ValueType)
unfoldMappingType mt = go (ValueType mt) []
  where
    go :: ValueType -> [ValueType] -> ([ValueType], ValueType)
    go (ValueType (TMapping key t)) keys = go t (keys ++ [key])
    go t keys = (keys, t)

-- | coq syntax for an abi type
abiType :: AbiType -> T.Text
abiType (AbiUIntType _) = "Z"
abiType (AbiIntType _) = "Z"
abiType AbiAddressType = "address"
abiType AbiStringType = strMod <.> "string"
abiType a = error $ show a

-- | coq syntax for a return type
returnType :: TypedExp -> T.Text
returnType (TExp (TInteger _ _) _) = "Z"
returnType (TExp TUnboundedInt _) = "Z"
returnType (TExp TAddress _) = "Z"
returnType (TExp TBoolean _) = "bool"
returnType (TExp (TContract _) _) = error "contracts not allowed as return types"
returnType (TExp (TMapping _ _) _) = error "mappings not supported as return types"
returnType (TExp TByteStr _) = error "bytestrings not supported"
returnType (TExp (TStruct _) _) = error "structs not supported"
returnType (TExp (TArray _ _) _) = error "arrays not supported"


-- | default value for a given type
-- this is used in cases where a value is not set in the constructor
defaultVal :: ValueType -> T.Text
defaultVal (ValueType (TMapping _ t)) = parens $
  "fun" <+> "_" <+> "=>" <+> defaultVal t
defaultVal (ValueType (TContract _)) = error "Contracts must be explicitly initialized"
defaultVal (ValueType t) = abiVal $ toAbiType t

abiVal :: AbiType -> T.Text
abiVal (AbiUIntType _) = "0"
abiVal (AbiIntType _) = "0"
abiVal AbiAddressType = "0"
abiVal AbiStringType = strMod <.> "EmptyString"
abiVal _ = error "TODO: missing default values"

-- | coq syntax for an expression
coqexp :: Exp a -> T.Text
-- booleans
coqexp (LitBool _ True)  = "true"
coqexp (LitBool _ False) = "false"
coqexp (And _ e1 e2)  = parens $ "andb"    <+> coqexp e1 <+> coqexp e2
coqexp (Or _ e1 e2)   = parens $ "orb"     <+> coqexp e1 <+> coqexp e2
coqexp (Impl _ e1 e2) = parens $ "implb"   <+> coqexp e1 <+> coqexp e2
coqexp (Eq _ _ e1 e2)   = parens $ coqexp e1  <+> "=?" <+> coqexp e2
coqexp (NEq _ _ e1 e2)  = parens $ "negb" <+> parens (coqexp e1  <+> "=?" <+> coqexp e2)
coqexp (Neg _ e)      = parens $ "negb" <+> coqexp e
coqexp (LT _ e1 e2)   = parens $ coqexp e1 <+> "<?"  <+> coqexp e2
coqexp (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=?" <+> coqexp e2
coqexp (GT _ e1 e2)   = parens $ coqexp e2 <+> "<?"  <+> coqexp e1
coqexp (GEQ _ e1 e2)  = parens $ coqexp e2 <+> "<=?" <+> coqexp e1

-- integers
coqexp (LitInt _ i) = T.pack $ show i
coqexp (Add _ e1 e2) = parens $ coqexp e1 <+> "+" <+> coqexp e2
coqexp (Sub _ e1 e2) = parens $ coqexp e1 <+> "-" <+> coqexp e2
coqexp (Mul _ e1 e2) = parens $ coqexp e1 <+> "*" <+> coqexp e2
coqexp (Div _ e1 e2) = parens $ coqexp e1 <+> "/" <+> coqexp e2
coqexp (Mod _ e1 e2) = parens $ "Z.modulo" <+> coqexp e1 <+> coqexp e2
coqexp (Exp _ e1 e2) = parens $ coqexp e1 <+> "^" <+> coqexp e2
coqexp (IntMin _ n)  = parens $ "INT_MIN"  <+> T.pack (show n)
coqexp (IntMax _ n)  = parens $ "INT_MAX"  <+> T.pack (show n)
coqexp (UIntMin _ n) = parens $ "UINT_MIN" <+> T.pack (show n)
coqexp (UIntMax _ n) = parens $ "UINT_MAX" <+> T.pack (show n)

coqexp (InRange _ t e) = coqexp (And nowhere (LEQ nowhere (lowerBound t) e) $ LEQ nowhere e (upperBound t))

-- polymorphic
coqexp (VarRef _ _ r) = ref r
coqexp (ITE _ b e1 e2) = parens $ "if"
                             <+> coqexp b
                             <+> "then"
                             <+> coqexp e1
                             <+> "else"
                             <+> coqexp e2

-- environment values
-- Relies on the assumption that Coq record fields have the same name
-- as the corresponding Haskell constructor
-- coqexp (IntEnv _ This) = parens $ addrField <+> stateVar
coqexp (IntEnv _ envVal) = parens $ T.pack (show envVal) <+> envVar
-- Contracts
coqexp Create {} = error "Internal error: coqexp called for creation expression; call updateExp"
coqexp (Address _ c e) = parens $ T.pack c <.> addrField <+> coqexp e

coqexp me@(Mapping _ _ _ _) = mappingExp me 0
coqexp me@(MappingUpd _ _ _ _ _) = mappingExp me 0

-- unsupported
coqexp Cat {} = error "bytestrings not supported"
coqexp Slice {} = error "bytestrings not supported"
coqexp ByStr {} = error "bytestrings not supported"
coqexp ByLit {} = error "bytestrings not supported"
coqexp ByEnv {} = error "bytestrings not supported"
coqexp Array {} = error "arrays not supported"

mappingExp :: Exp a -> Int -> T.Text
mappingExp (Mapping _ keyType valType@VType es) level = parens $
  "fun" <+> (anon <> (T.pack $ show level)) <+> "=>" <+>
  foldr (mappingElem level keyType) (defaultVal (ValueType valType)) es
mappingExp (MappingUpd _ r keyType _ es) level = parens $
  "fun" <+> (anon <> (T.pack $ show level)) <+> "=>" <+>
  foldr (mappingElem level keyType) (ref r <> (anon <> (T.pack $ show level))) es
mappingExp e _ = coqexp e

mappingElem :: Int -> TValueType a -> (Exp a, Exp b) -> T.Text -> T.Text
mappingElem level keyType (key, ve) elseText =
  "if" <+> boolScope (parens (anon <> T.pack (show level)) <+> eqsym keyType <+> coqexp key) <+>
  "then" <+> mappingExp ve (level + 1) <+>
  "else" <+> elseText

eqsym :: TValueType a -> T.Text
eqsym argType = case argType of
  TInteger _ _ -> "=?"
  TUnboundedInt -> "=?"
  TAddress -> "=?"
  TBoolean -> "=??"
  TMapping _ _ -> error "mapping as keys not supported"
  TByteStr -> error "bytestrings as keys not supported"
  TArray _ _ -> error "arrays as key not supported"
  TStruct _ -> error "structs as key not supported"
  TContract _ -> error "contracts as key not supported"


-- | coq syntax for a proposition
coqprop :: Exp ABoolean -> T.Text
coqprop (LitBool _ True)  = "True"
coqprop (LitBool _ False) = "False"
coqprop (And _ e1 e2)  = parens $ coqprop e1 <+> "/\\" <+> coqprop e2
coqprop (Or _ e1 e2)   = parens $ coqprop e1 <+> "\\/" <+> coqprop e2
coqprop (Impl _ e1 e2) = parens $ coqprop e1 <+> "->"  <+> coqprop e2
coqprop (Neg _ e)      = parens $ "not" <+> coqprop e
coqprop (Eq _ _ e1 e2)   = parens $ coqexp e1 <+> "="  <+> coqexp e2
coqprop (NEq _ _ e1 e2)  = parens $ coqexp e1 <+> "<>" <+> coqexp e2
coqprop (LT _ e1 e2)   = parens $ coqexp e1 <+> "<"  <+> coqexp e2
coqprop (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=" <+> coqexp e2
coqprop (GT _ e1 e2)   = parens $ coqexp e1 <+> ">"  <+> coqexp e2
coqprop (GEQ _ e1 e2)  = parens $ coqexp e1 <+> ">=" <+> coqexp e2
coqprop (InRange _ t e) = coqprop (And nowhere (LEQ nowhere (lowerBound t) e) $ LEQ nowhere e (upperBound t))
coqprop (ITE _ b e1 e2) =
  parens $ "if" <+> coqbool b <+> "then" <+> coqexp e1 <+> "else" <+> coqexp e2

coqprop e@(VarRef _ _ _) = error "ill formed proposition:" <+> T.pack (show e) --TODO: is this necessary?

coqbool :: Exp ABoolean -> T.Text
coqbool (LitBool _ True)  = "true"
coqbool (LitBool _ False) = "false"
coqbool (And _ e1 e2)  = parens $ "andb" <+> coqbool e1 <+> coqbool e2
coqbool (Or _ e1 e2)   = parens $ "orb" <+> coqbool e1 <+> coqbool e2
coqbool (Impl _ e1 e2) = parens $ "implb" <+> coqbool e1 <+> coqbool e2
coqbool (Neg _ e)      = parens $ "neqb" <+> coqbool e
coqbool (Eq _ t e1 e2)   = boolScope $ coqexp e1 <+> eqsym t <+> coqexp e2
coqbool (NEq _ t e1 e2)  = boolScope $ "negb" <+> parens (coqexp e1 <+> eqsym t <+> coqexp e2)
coqbool (LT _ e1 e2)   = parens $ coqexp e1 <+> "<?"  <+> coqexp e2
coqbool (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=?" <+> coqexp e2
coqbool (GT _ e1 e2)   = parens $ coqexp e1 <+> ">?"  <+> coqexp e2
coqbool (GEQ _ e1 e2)  = parens $ coqexp e1 <+> ">=?" <+> coqexp e2
coqbool (InRange _ t e) = coqbool (And nowhere (LEQ nowhere (lowerBound t) e) $ LEQ nowhere e (upperBound t))

coqbool e = error "ill formed proposition:" <+> T.pack (show e)

-- | coq syntax for a typed expression
typedexp :: TypedExp -> T.Text
typedexp (TExp _ e) = coqexp e

ref :: Ref k -> T.Text
ref (SVar _ Pre cid name) = parens $ T.pack cid <.> T.pack name <+> stateVar
ref (SVar _ Post cid name) = parens $ T.pack cid <.> T.pack name <+> stateVar'
ref (CVar _ _ name) = T.pack name
ref (RArrIdx _ r ix _) = parens $ ref r <+> coqexp ix
ref (RMapIdx _ (TRef _ _ r) ix) = parens $ ref r <+> typedexp ix
ref (RField _ r cid name) = parens $ T.pack cid <.> T.pack name <+> ref r

refState :: T.Text -> Ref k -> T.Text
refState s (SVar _ _ cid name) = parens $ T.pack cid <.> T.pack name <+> s
refState _ (CVar _ _ name) = T.pack name
refState s (RArrIdx _ r ix _) = parens $ refState s r <+> coqexp ix
refState s (RMapIdx _ (TRef _ _ r) ix) = parens $ refState s r <+> typedexp ix
refState s (RField _ r cid name) = parens $ T.pack cid <.> T.pack name <+> refState s r

-- | coq syntax for a list of arguments
coqargs :: [TypedExp] -> T.Text
coqargs es = T.unwords (map typedexp es)

fresh :: Id -> Fresh T.Text
fresh name = state $ \s -> (T.pack (name <> show s), s + 1)

freshId :: Id -> Fresh Id
freshId name = state $ \s -> (name <> show s, s + 1)

getIncr :: Fresh Int
getIncr = state $ \s -> (s, s + 1)

evalSeq :: Traversable t => (a -> Fresh b) -> t a -> t b
evalSeq f xs = evalState (sequence (f <$> xs)) 0

runSeq :: Traversable t => (a -> Fresh b) -> t a -> Int -> (t b, Int)
runSeq f xs iInit = runState (sequence (f <$> xs)) iInit

--- text manipulation ---

definition :: T.Text -> T.Text -> T.Text -> T.Text
definition name args value = T.unlines
  [ "Definition" <+> name <+> args <+> ":="
  , value <> "."
  ]

data InductiveCnstr = IndC { cname :: T.Text, bindings :: [T.Text], body :: T.Text }
data Inductive = Inductive
  { name :: T.Text
  , args :: [T.Text]
  , indices :: [T.Text]
  , constructors :: [InductiveCnstr]
  }

inductive :: T.Text -> T.Text -> T.Text -> [(T.Text, Maybe T.Text, T.Text)] -> T.Text
inductive name args indices constructors = T.unlines
  [ "Inductive" <+> name <+> args <+> ":" <+> indices <+> ":="
  , T.unlines (((<>) "| " . uncurry3 inductiveConstructor) <$> constructors) <> "."
  ]

inductiveConstructor :: T.Text -> Maybe T.Text -> T.Text -> T.Text
inductiveConstructor ctorName Nothing body =
     ctorName <+> ":\n" <> body
inductiveConstructor ctorName (Just bindings) body =
     ctorName <+> ":" <+> forAll bindings <> "\n" <> body

lemma :: T.Text -> T.Text -> T.Text -> T.Text -> T.Text
lemma name args claim proof = T.unlines
  [ "Lemma" <+> name <+> args <+> ":"
  , claim <> "."
  , proof
  ]


-- | forall bindings
forAll :: T.Text -> T.Text
forAll bindings = "forall" <+> bindings <> ","

-- | multiline implication
implication :: [T.Text] -> T.Text
implication xs = "   " <> T.intercalate "\n-> " xs

-- | multiline conjuction
conjuction :: [T.Text] -> T.Text
conjuction [] = "   True"
conjuction xs = "   " <> T.intercalate "\n/\\ " xs

-- | wrap text in parentheses
parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

tuple :: T.Text -> T.Text -> T.Text
tuple a b = "(" <> a <> ", " <> b <> ")"

boolScope :: T.Text -> T.Text
boolScope s = "(" <> s <> ")%bool"

indent :: Int -> T.Text -> T.Text
indent n = T.unlines . fmap (T.replicate n " " <>) . T.lines

(<+>) :: T.Text -> T.Text -> T.Text
"" <+> t2 = t2
t1 <+> "" = t1
t1 <+> t2 = t1 <> " " <> t2

(<.>) :: T.Text -> T.Text -> T.Text
t1 <.> t2 = t1 <> "." <> t2

--- constants ---

-- | string module name
strMod :: T.Text
strMod  = "Str"

-- | base state name
baseVar :: T.Text
baseVar = "BASE"

stateType :: T.Text
stateType = "State"

stateVar :: T.Text
stateVar = "STATE"

stateVar' :: T.Text
stateVar' = "STATE'"

nextVar :: T.Text
nextVar = "NEXT"

stateDecl :: T.Text
stateDecl = parens $ stateVar <+> ":" <+> stateType

stateDecl' :: T.Text
stateDecl' = parens $ stateVar' <+> ":" <+> stateType

stateConstructor :: T.Text
stateConstructor = "state"

addressType :: T.Text
addressType = "address"

addrField :: T.Text
addrField = "addr"

addrFieldDecl :: T.Text
addrFieldDecl = addrField <> " : address"

returnSuffix :: T.Text
returnSuffix = "_ret"

postSuffix :: T.Text
postSuffix = "_post"

invInitType :: T.Text
invInitType  = "invariantInit"

invStepType :: T.Text
invStepType  = "invariantStep"

invReachType :: T.Text
invReachType  = "invariantReachable"

baseSuffix :: T.Text
baseSuffix = "_base"

stepSuffix :: T.Text
stepSuffix = "_step"

introSuffix :: T.Text
introSuffix = "_intro"

localStepType :: Id -> T.Text
localStepType name = T.pack name <> "_step"

stepType :: T.Text
stepType = "step"

stepBeforeType :: T.Text
stepBeforeType = "stepBefore"

extStepType :: T.Text
extStepType = "extStep"

addressInType :: T.Text
addressInType = "addressIn"

contractAddressInType :: T.Text
contractAddressInType = "addressIn"

noAliasingType :: T.Text
noAliasingType = "noAliasing"

nextAddrConstraintType :: T.Text
nextAddrConstraintType = "nextAddrConstraint"

initStateType :: T.Text
initStateType = "init"

initStateBeforeType :: T.Text
initStateBeforeType = "initBefore"

invPropVar :: T.Text
invPropVar = "IP"

invPropType :: Interface -> T.Text
invPropType (Interface _ decls) = T.intercalate " -> " $ concat [[envType], map decl' decls, [addressType, stateType, "Prop"]]
  where
  decl' (Arg (ContractArg _ cid) _) = T.pack cid <> ".State"
  decl' (Arg (AbiArg t) _) = abiType t

invPropDecl :: Interface -> T.Text
invPropDecl i = parens $ invPropVar <+> ":" <+> invPropType i

initPrecsType :: T.Text
initPrecsType = "initPreconds"

behvPrecsType :: T.Text
behvPrecsType = "behvPrecs"

integerBoundsType :: T.Text
integerBoundsType = "stateIntegerBounds"

multistepType :: T.Text
multistepType = "multistep"

multistepBeforeType :: T.Text
multistepBeforeType = "multistepBefore"

reachableType :: T.Text
reachableType = "reachable"

reachableBeforeType :: T.Text
reachableBeforeType = "reachableBefore"

reachableFromInitType :: T.Text
reachableFromInitType = "reachableFromInit"

reachStep:: T.Text
reachStep= "reach_step"

nextAddrType :: T.Text
nextAddrType = "address"

nextAddrVar :: T.Text
nextAddrVar = "NextAddr"

nextAddrDecl :: T.Text
nextAddrDecl = parens $ nextAddrVar <+> ":" <+> nextAddrType

nextAddrVar' :: T.Text
nextAddrVar' = "NextAddr'"

nextAddrDecl' :: T.Text
nextAddrDecl' = parens $ nextAddrVar' <+> ":" <+> nextAddrType

envType :: T.Text
envType = "Env"

envVar :: T.Text
envVar = "ENV"

envVar' :: T.Text
envVar' = "ENV'"

envDecl :: T.Text
envDecl = parens $ envVar <+> ":" <+> envType

envDecl' :: T.Text
envDecl' = parens $ envVar' <+> ":" <+> envType

boundType :: T.Text
boundType = "address"

boundVar :: T.Text
boundVar = "BOUND"

boundDecl :: T.Text
boundDecl = parens $ boundVar <+> ":" <+> boundType


anon :: T.Text
anon = "_binding_"
