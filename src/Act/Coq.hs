{-
 -
 - coq backend for act
 -
 - unsupported features:
 - + bytestrings
 - + external storage
 - + casting from addresses to contract
 -
 -}

{-# Language OverloadedStrings #-}
{-# Language RecordWildCards #-}
{-# LANGUAGE GADTs #-}
{-# Language DataKinds #-}
{-# Language ViewPatterns #-}


module Act.Coq where

import Prelude hiding (GT, LT)

import Data.Map.Strict (Map)
import Data.Tuple.Extra
import qualified Data.Map.Strict    as M
import qualified Data.List.NonEmpty as NE
import qualified Data.Text          as T
import Data.List.Extra (snoc, unsnoc)
import Control.Monad.State

import EVM.ABI
import Act.Syntax
import Act.Syntax.TypedExplicit

type Fresh = State Int

header :: T.Text
header = T.unlines
  [ "(* --- GENERATED BY ACT --- *)\n"
  , "Require Import Stdlib.ZArith.ZArith."
  , "Require Import ActLib.ActLib."
  , "Require Stdlib.Strings.String.\n"
  , "Module " <> strMod <> " := Stdlib.Strings.String."
  , "Open Scope Z_scope.\n"
  ]

-- | produce a coq representation of a specification
coq :: Act -> T.Text
coq (Act store contracts) =
  header <> (T.intercalate "\n\n" $ contractCode store <$> contracts)

contractCode :: StorageTyping -> Contract -> T.Text
contractCode store (Contract ctor@Constructor{..} behvs) = T.unlines $
  [ "Module " <> T.pack _cname <> ".\n" ]
  <> [ stateRecord ]
  <> [ contractAddressIn _cname store ]
  <> [ addressIn _cname store ]
  <> [ noAliasing _cname store ]
  <> [ intBounds _cname store ]
  <> [ intBoundsRec _cname store ]
  <> [ nextAddrConstraint ]
  <> [ constructorCode store ctor ]
  <> ( behaviourCode store <$> behvs )
  <> [ localStep _cname behvs]
  <> [ extStep _cname store ]
  <> [ step ]
  <> [ multistep ]
  <> [ reachable ]
  <> [ reachableFromInit ctor]
  <> [ stepBefore ]
  <> [ multistepBefore ]
  <> [ reachableBefore ]
  <> ( postCondConstr ctor )
  <> ( concat $ postCondBehv <$> behvs )
  <> [ invariantInit ctor ]
  <> [ invariantStep ctor ]
  <> [ invariantReachable ctor]
  <> [ "End " <> T.pack _cname <> "." ]
  where

    stateRecord = T.unlines

      [ "Record" <+> stateType <+> ": Set :=" <+> stateConstructor
      , "{ " <> T.intercalate ("\n" <> "; ") (addrFieldDecl : map decl (M.toList store'))
      , "}."
      ]

    decl (n, (s, _)) = (T.pack n) <> " : " <> valueType s

    store' = contractStore _cname store

constructorCode :: StorageTyping -> Constructor -> T.Text
constructorCode store (Constructor cname iface precs cases _ invs) = T.unlines $
  [ initPrecs iface precs ]
  <> evalSeq (ctorCreates store cname iface) cases
  <> [ initState cname iface cases ]
  <> [ initStateBefore cname iface cases ]
  <> [ invariants iface invs ]

-- | definition of constructor preconditions
initPrecs :: Interface -> [Exp ABoolean] -> T.Text
initPrecs i conds = inductive
  initPrecsType (envDecl <+> interface i) "Prop" [("ctorPreconds", Nothing, body)]
  where
    body = indent 2 . implication . concat $
      [ coqprop <$> conds
      , interfaceStateVarsConstraints i
      , ["Caller" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["Origin" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Caller" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Origin" <+> envVar]
      , ["This" <+> envVar <+> "=" <+> "NextAddr" <+> envVar] -- addrField <+> parens ("snd" <+> parens (T.pack name <+> envVar)) ]
      , [ initPrecsType <+> envVar <+> arguments i ]
      ]

ctorCreates :: StorageTyping -> Id -> Interface -> (Exp ABoolean, [StorageUpdate]) -> Fresh T.Text
ctorCreates store name iface (_, updates) = do
  name' <- freshId name
  let createsName = name' <> "_creates"
  pure $ base store createsName iface updates

-- | predicate characterizing all initial (post constructor) states
initState :: Id -> Interface -> Cases [StorageUpdate] -> T.Text
initState name i cases = inductive
  initStateType "" (stateType <+> "->" <+> "Prop") (evalSeq caseCtor cases) -- [("InitState", Just $ envDecl <+> interface i, constructorBody)]
  where
    baseval n = parens $ "snd" <+> parens (T.pack n <+> envVar <+> arguments i)

    caseCtor :: (Exp ABoolean, [StorageUpdate]) -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (caseCond, _) = do
      name' <- freshId name
      let createsName = name' <> "_creates"
      let body = (indent 2) . implication . concat $
            [ [initPrecsType <+> envVar <+> arguments i]
            , ["This" <+> envVar <+> "=" <+> addrField <+> baseval createsName]
            , [ coqprop caseCond ]
            , [initStateType <+> baseval createsName]
            ]
      pure (T.pack name', Just $ envDecl <+> interface i, body)

-- | predicate characterizing all initial (post constructor) states that can be instantiated before a given environment
initStateBefore :: Id -> Interface -> Cases [StorageUpdate] -> T.Text
initStateBefore name i cases = inductive
  initStateBeforeType "" (envType <+> "->" <+> stateType <+> "->" <+> "Prop") (evalSeq caseCtor cases)
  where
    baseval n = parens $ "snd" <+> parens (T.pack n <+> envVar <+> arguments i)

    fenvVar = "FENV" :: T.Text
    fenvDecl = parens $ fenvVar <+> ":" <+> envType

    caseCtor :: (Exp ABoolean, [StorageUpdate]) -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (caseCond, _) = do
      name' <- freshId name
      let createsName = name' <> "_creates"
      let body = (indent 2) . implication . concat $
            [ [initPrecsType <+> envVar <+> arguments i]
            , [tuple envVar' stateVar <+> "=" <+> T.pack name <.> T.pack name <+> envVar <+> arguments i]
            , ["This" <+> envVar <+> "=" <+> addrField <+> stateDecl]
            , ["NextAddr" <+> envVar' <+> "<=" <+> "NextAddr" <+> fenvVar]
            , [ coqprop caseCond ]
            , [initStateType <+> baseval createsName]
            ]
      pure (T.pack name', Just $ envDecl <+> interface i <+> envDecl' <+> fenvDecl <+> stateDecl, body)


behaviourCode :: StorageTyping -> Behaviour -> T.Text
behaviourCode store (Behaviour name cname iface precs cases _) = T.unlines $
  [ behvConds name iface precs ]
  <> evalSeq (behvUpdates store name cname iface) cases
  <> [ behvPred name iface cases ]
  <> evalSeq (retVal name iface) cases

-- | definition of behaviour-case conditions
behvConds :: Id -> Interface -> [Exp ABoolean] -> T.Text
behvConds name i conds = do
  inductive
    (T.pack name <> "_conds") (envDecl <+> interface i <+> stateDecl) "Prop" [((T.pack name <> "_condsC"), Nothing, body name)]
  where
    body n = indent 2 . implication . concat $
      [ coqprop <$> conds
      , [ nextAddrConstraintType <+> envVar <+> stateVar ]
      , interfaceStateVarsConstraints i
      , ["This" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["Caller" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["Origin" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Caller" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Origin" <+> envVar]
      , ["This" <+> envVar <+> "=" <+> addrField <+> stateVar ]
      , [ (T.pack n <> "_conds") <+> envVar <+> arguments i <+> stateVar ]
      ]

behvUpdates :: StorageTyping -> Id -> Id -> Interface -> (Exp ABoolean, ([StorageUpdate], Maybe TypedExp)) -> Fresh T.Text
behvUpdates store name cname iface (_, (updates, _)) = do
  name' <- freshId name
  let createsName = name' <> "_updates"
  pure $ transition store createsName cname iface updates


behvPred :: Id -> Interface -> [(Exp ABoolean, ([StorageUpdate], Maybe TypedExp))] -> T.Text
behvPred name i cases = inductive
  (T.pack name) "" (envType <+> "->" <+> stateType <+> "->" <+> envType <+> "->" <+> stateType <+> "-> Prop") caseCtors
  where
    caseCtors = (evalSeq caseCtor cases)

    caseCtor :: (Exp ABoolean, ([StorageUpdate], Maybe TypedExp)) -> Fresh (T.Text, Maybe T.Text, T.Text)
    caseCtor (caseCond, (_, _))= do
      name' <- fresh name
      pure (name' <> stepSuffix, Just $ envDecl <+> interface i <+> stateDecl, caseBody caseCond name')

    caseBody c n = (indent 2) . implication $
      [ (T.pack name) <> "_conds" <+> envVar <+> arguments i <+> stateVar
      , "This" <+> envVar <+> "=" <+> addrField <+> stateVar
      , coqprop c
      , (T.pack name) <+> envVar <+> stateVar
        <+> parens ("fst" <+> parens ( n <> "_updates" <+> envVar <+> stateVar <+> arguments i))
        <+> parens ("snd" <+> parens ( n <> "_updates" <+> envVar <+> stateVar <+> arguments i))
      ]


-- | Inductive definition of step relation of 2 states
-- that takes into account only transitions of the current contract type
localStep :: Id -> [Behaviour] -> T.Text
localStep contract behvs = inductive
  (localStepType contract) "" (envType <+> "->" <+> stateType <+> "->" <+> envType <+> "->" <+> stateType <+> "-> Prop") (stepBehv <$> behvs)
  where
    -- | constructor for the step relation
    stepBehv :: Behaviour -> (T.Text, Maybe T.Text, T.Text)
    stepBehv (Behaviour name _ _ _ _ _) = (T.pack name <> stepSuffix, Just $ envDecl <+> stateDecl <+> envDecl' <+> stateDecl', constructorBody)
      where
        constructorBody = T.pack name <+> envVar <+> stateVar <+> envVar' <+> stateVar'

-- | Constraint on Env expressing that the NextAddr field should be greated than
-- all addresses contained in the state
nextAddrConstraint :: T.Text
nextAddrConstraint = definition
  nextAddrConstraintType (envDecl <+> stateDecl) body
    where
      body = indent 2 $ forAll (parens ("p : address")) <+>
        (addressInType <+> "p" <+> stateVar) <+> "->" <+> ("NextAddr" <+> envVar <+> "> p")

-- | Inductive definition of step relation of 2 states
-- that takes into account transitions of the current contract type
-- and all transitions possible for contained contracts
extStep :: Id -> StorageTyping -> T.Text
extStep main store = inductive
  extStepType "" (envType <+> "->" <+> stateType <+> "->" <+> envType <+> "->" <+> stateType <+> "-> Prop") body
  where
    body =
      (extStepType <> "_" <> T.pack main, Just $ (envDecl <+> envDecl' <+> stateDecl <+> stateDecl')
      , indent 2 $ implication [localStepType main <+> envVar <+> stateVar <+> envVar' <+> stateVar', extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar'])
      : (M.elems $ M.mapMaybeWithKey substep localStore)

    localStore = contractStore main store

    substep :: Id -> (ValueType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    substep var (ValueType (TContract cid), _) = Just (extStepType <> "_" <> varp, Just (envDecl <+> stateDecl <+> envVar' <+> stateDecl'), body')
      where
        varp = T.pack var
        body' = indent 2 . implication . concat $
          [ [ nextAddrConstraintType <+> envVar <+> stateVar ]
          , [ "Origin" <+> envVar <+> "<>" <+> addrField <+> stateVar ]
          , [ "Caller" <+> envVar <+> "<>" <+> addrField <+> stateVar ]
          , [ T.pack cid <.> extStepType <+> envVar <+> parens (varp <+> stateVar) <+> envVar' <+> parens (varp <+> stateVar') ]
          , [ addrField <+> stateVar <+> "=" <+> addrField <+> stateVar' ]
          , (\var' -> parens (T.pack var' <+> stateVar) <+> "=" <+> parens (T.pack var' <+> stateVar')) <$> (filter (var /=) $ M.keys localStore)
          , [ "integerBounds" <+> stateVar ]
          , (M.elems $ M.mapMaybeWithKey (subBounds var) localStore)
          , [ extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar' ]
          ]
    substep _ _ = Nothing

    subBounds :: Id -> Id -> (ValueType, Integer) -> Maybe T.Text
    subBounds stepVar var (ValueType (TContract cid), _) | var /= stepVar = Just $ T.pack cid <.> "integerBoundsRec" <+> parens (T.pack var <+> stateVar)
    subBounds _ _ _ = Nothing
      


step :: T.Text
step =
  definition stepType (stateDecl <+> stateDecl') $
    "exists" <+> envDecl <+> envDecl' <> "," <+> extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar'

stepBefore :: T.Text
stepBefore =
  definition stepBeforeType (envDecl'' <+> stateDecl <+> stateDecl') $
    "exists" <+> envDecl <+> envDecl' <> "," <+> extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar'
    <+> "/\\" <+> "NextAddr" <+> envVar' <+> "<=" <+> "NextAddr" <+> "ENV''"


combine :: [a] -> [(a,a)]
combine lst = combine' lst []
  where
    combine' [] acc = concat acc
    combine' (x:xs) acc =
      let xcomb = [ (x, y) | y <- xs] in
      combine' xs (xcomb:acc)

-- | Predicate that holds if p is an address of known contract type
-- in the given state
contractAddressIn :: Id -> StorageTyping -> T.Text
contractAddressIn name store = inductive
  contractAddressInType "" ("Z" <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = ("addressOf_This", Just stateDecl, indent 5 $ contractAddressInType <+> parens (addrField <+> stateVar) <+> stateVar)
           : M.elems (M.mapMaybeWithKey subCAddr localStore)

    localStore = contractStore name store

    subCAddr :: Id -> (ValueType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    subCAddr var (ValueType (TContract cid), _) = Just ("addressOf_" <> varp, Just $ parens ("p : address") <+> stateDecl, body')
      where
        varp = T.pack var
        body' = indent 2 . implication $
          [ T.pack cid <.> contractAddressInType <+> "p" <+> parens (varp <+> stateVar)
          , contractAddressInType <+> "p" <+> stateVar
          ]
    subCAddr _ _ = Nothing

-- | Predicate that holds if p is an address in the given state
addressIn :: Id -> StorageTyping -> T.Text
addressIn name store = inductive
  addressInType "" ("Z" <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = ("address_addr", Just stateDecl, indent 5 $ addressInType <+> parens (addrField <+> stateVar) <+> stateVar)
           : ("address_subcontract", Just $ parens ("p : address") <+> stateDecl, indent 5 $ contractAddressInType <+> "p" <+> stateVar <+> "->" <+> addressInType <+> "p" <+> stateVar)
           : M.elems (M.mapMaybeWithKey subAddr localStore)

    localStore = contractStore name store

    subAddr :: Id -> (ValueType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    subAddr var (ValueType TAddress, _) =
      let varp = T.pack var in
      Just ("address_" <> varp, Just stateDecl, indent 5 $ addressInType <+>  parens (varp <+> stateVar) <+> stateVar)
    subAddr _ _ = Nothing

slotContractName :: ValueType -> Maybe Id
slotContractName (ValueType (TContract cid)) = Just cid
slotContractName _ = Nothing

noAliasing :: Id -> StorageTyping -> T.Text
noAliasing name store = inductive
  noAliasingType stateDecl "Prop" [("noAliasingC", Nothing, body)]
  where
    body = indent 2 . implication $
      (addressSubContractAliasing <$> storeContracts)
      <> (contractPairAliasing <$> contractPairs)
      <> (subContractAliasing <$> storeContracts)
      <> [noAliasingType <+> stateVar]

    localStore = contractStore name store
    storeContracts = M.toList $ M.mapMaybe (slotContractName . fst) localStore
    contractPairs = filter (not. uncurry (==)) $ combine storeContracts

    addressSubContractAliasing :: (Id, Id) -> T.Text
    addressSubContractAliasing (cvar, cid) =
      parens $ forAll (parens ("p : address")) <+>
        ( T.pack cid <.> contractAddressInType <+> "p" <+> parens (T.pack cvar <+> stateVar)) <+> "->"
        <+> (parens (addrField <+> stateVar) <+> "<>" <+> "p")

    contractPairAliasing :: ((Id, Id), (Id, Id)) -> T.Text
    contractPairAliasing ((cvar1, cid1), (cvar2, cid2)) =
      parens $ forAll (parens ("p p' : address")) <+>
        ( T.pack cid1 <.> contractAddressInType <+> "p" <+> parens (T.pack cvar1 <+> stateVar)) <+> "->"
        <+> ( T.pack cid2 <.> contractAddressInType <+> "p'" <+> parens (T.pack cvar2 <+> stateVar)) <+> "->"
        <+> ("p" <+> "<>" <+> "p'")

    subContractAliasing :: (Id, Id) -> T.Text
    subContractAliasing (cvar, cid) = T.pack cid <.> noAliasingType <+> parens (T.pack cvar <+> stateVar)

intBounds :: Id -> StorageTyping -> T.Text
intBounds name store = inductive
  "integerBounds" stateDecl "Prop" [("integerBoundsC", Nothing, body)]
  where
    body = indent 2 . implication $ ((M.elems $ M.mapMaybeWithKey go localStore) <> ["integerBounds" <+> stateVar])

    localStore = contractStore name store

    go :: Id -> (ValueType, Integer) -> Maybe T.Text
    go v (ValueType (TContract cid), _) = Just $
      "0 <=" <+> T.pack cid <.> addrField <+> parens (T.pack v <+> stateVar) <+> "<= UINT_MAX 160"
    go v (ValueType TAddress, _) = Just $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX 160"
    go v (ValueType (TInteger n Unsigned), _) = Just $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX" <+> T.pack (show n)
    go v (ValueType (TInteger n Signed), _) = Just $
      "INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> "<= INT_MAX" <+> T.pack (show n)
    go v (ValueType t@(TMapping _ _), _) = case unfoldMappingType t of
      (length -> i, ValueType TAddress) -> pure $ parens $
        "forall" <+> ixs i <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= UINT_MAX 160"
      (length -> i, ValueType (TInteger n Unsigned)) -> pure $ parens $
        "forall" <+> ixs i <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= UINT_MAX" <+> T.pack (show n)
      (length -> i, ValueType (TInteger n Signed)) -> pure $ parens $
        "forall" <+> ixs i <> ", INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= INT_MAX" <+> T.pack (show n)
      _ -> Nothing
    go _ _ = Nothing

    ixs n = T.unwords $ T.pack . (<>) "i" . show <$> [0..(n-1)]

intBoundsRec :: Id -> StorageTyping -> T.Text
intBoundsRec name store = inductive
  "integerBoundsRec" stateDecl "Prop" [("integerBoundsRecC", Nothing, body)]
  where
    body = indent 2 . implication . concat $ ((M.elems $ M.mapWithKey go localStore) <> [["integerBoundsRec" <+> stateVar]])

    localStore = contractStore name store

    go :: Id -> (ValueType, Integer) -> [T.Text]
    go v (ValueType (TContract cid), _) =
      [ "0 <=" <+> T.pack cid <.> addrField <+> parens (T.pack v <+> stateVar) <+> "<= UINT_MAX 160"
      , T.pack cid <.> "integerBoundsRec" <+> parens (T.pack v <+> stateVar) ]
    go v (ValueType TAddress, _) = pure $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX 160"
    go v (ValueType (TInteger n Unsigned), _) = pure $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX" <+> T.pack (show n)
    go v (ValueType (TInteger n Signed), _) = pure $
      "INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> "<= INT_MAX" <+> T.pack (show n)
    go v (ValueType t@(TMapping _ _), _) = case unfoldMappingType t of
      (length -> i, ValueType TAddress) -> pure $ parens $
        "forall" <+> ixs i <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= UINT_MAX 160"
      (length -> i, ValueType (TInteger n Unsigned)) -> pure $ parens $
        "forall" <+> ixs i <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= UINT_MAX" <+> T.pack (show n)
      (length -> i, ValueType (TInteger n Signed)) -> pure $ parens $
        "forall" <+> ixs i <> ", INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> ixs i <+> "<= INT_MAX" <+> T.pack (show n)
      _ -> []
    go _ _ = []

    ixs n = T.unwords $ T.pack . (<>) "i" . show <$> [0..(n-1)]

interfaceStateVarsConstraints :: Interface -> [T.Text]
interfaceStateVarsConstraints (Interface _ decls) = concatMap go decls
  where go (Decl (ContractArg _ cid) v) =
          [ T.pack cid <.> nextAddrConstraintType <+> envVar <+> T.pack v
          , T.pack cid <.> reachableBeforeType <+> envVar <+> T.pack v ]
        go _ = []

-- | definition of reachable states
reachable :: T.Text
reachable = definition
  reachableType args value
  where
    args = parens $ stateVar <+> ":" <+> stateType
    value = "exists" <+> stateVar' <> "," <+> initStateType <+> stateVar'
      <+> "/\\" <+> multistepType <+> stateVar' <+> stateVar

reachableBefore :: T.Text
reachableBefore = definition
  reachableBeforeType args value
  where
    args = envDecl' <+> stateDecl --parens $ stateVar <+> ":" <+> stateType
    value = "exists" <+> stateVar' <> "," <+> initStateBeforeType <+> envVar' <+> stateVar'
      <+> "/\\" <+> multistepBeforeType <+> envVar' <+> stateVar' <+> stateVar

-- | specialization of generic multistep
multistep :: T.Text
multistep = definition
  multistepType args value
  where
    args = parens $ stateVar <+> stateVar' <+> ":" <+> stateType
    value = multistepType <+> stepType <+> stateVar <+> stateVar'

multistepBefore :: T.Text
multistepBefore = definition
  multistepBeforeType args value
  where
    args = envDecl' <+> stateDecl <+> stateDecl' -- parens $ stateVar <+> stateVar' <+> ":" <+> stateType
    value = "ActLib" <.> multistepType <+> parens (stepBeforeType <+> envVar') <+> stateVar <+> stateVar'

-- | definition of reachable states from initial constructor parameters
reachableFromInit :: Constructor -> T.Text
reachableFromInit (Constructor name i _ _ _ _ ) = definition
  reachableFromInitType args value
  where
    args = envDecl <+> interface i <+> stateDecl
    value = initPrecsType <+>
      envVar <+> arguments i <+> "/\\"
      <+> "This" <+> envVar <+> "=" <+> parens (addrField <+> parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i))) <+> "/\\"
      <+> multistepType <+> parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i)) <+> stateVar





-- | definition of a base state
base :: StorageTyping -> Id -> Interface -> [StorageUpdate] -> T.Text
base store name i updates =
  let (s, bindings, finalI) = stateval True store name (\_ t -> defaultVal t) updates
  in
  definition (T.pack name) (envDecl <+> interface i)
  (foldr (\a s' -> "let" <+> a <+> "in\n" <> s') (tuple (iEnv $ finalI + 1) s) bindings)

transition :: StorageTyping -> Id -> Id -> Interface -> [StorageUpdate] -> T.Text
transition store name cname i rewrites = do
  let (s, bindings, finalI) = stateval False store cname (\r _ -> ref r) rewrites
  definition (T.pack name) (envDecl <+> stateDecl <+> interface i) $ foldr (\a s' -> "let" <+> a <+> "in\n" <> s') (tuple (iEnv finalI) s) bindings

-- | inductive definition of a return claim
-- ignores claims that do not specify a return value
retVal :: Id -> Interface -> (Exp ABoolean, ([StorageUpdate], Maybe TypedExp)) -> Fresh T.Text
retVal name i (caseCond, (_, Just ret)) = do
  name' <- fresh name
  --fresh name >>= continuation where
  return $ inductive
    (name' <> returnSuffix)
    (envDecl <+> stateDecl <+> interface i)
    (returnType ret <> " -> Prop")
    [(retname name' <> introSuffix, Nothing, body name')]
  where
    retname n = n <> returnSuffix
    body n = indent 2 . implication . concat $
      [ [n <> "_conds" <+> envVar <+> arguments i <+> stateVar]
      , [coqprop caseCond]
      , [retname n <+> envVar <+> stateVar <+> arguments i <+> typedexp ret]
      ]
retVal _ _ _ = return ""

-- | Definition of postcondition claim for constructor
postCondConstr :: Constructor -> [T.Text]
postCondConstr (Constructor cname iface _ _ postcs _) = evalSeq (go cname iface) postcs
  where
  go :: Id -> Interface -> Exp ABoolean -> Fresh T.Text
  go name i postc = do
    postName <- fresh (name <> "_post")
    return $ definition postName "" body
    where
      body = indent 2 $ T.unlines
        [ forAll $ envDecl <+> interface i <+> stateDecl'
        , implication . concat $
          [ [initPrecsType <+> envVar <+> arguments i]
          , [stateVar' <+> "=" <+> "snd" <+> parens (T.pack name <+> envVar <+> arguments i)]
          , [coqprop postc]
          ]
        ]

-- | Definition of postcondition claim for behaviour cases
postCondBehv :: Behaviour -> [T.Text]
postCondBehv (Behaviour bname _ iface _ _ postcs) = evalSeq (go bname iface) postcs
  where
  go :: Id -> Interface -> Exp ABoolean -> Fresh T.Text
  go name i postc = do
    postName <- fresh (name <> "_post")
    return $ definition postName "" (body postName)
    where
      body n = indent 2 $ T.unlines
        [ forAll $ envDecl <+> stateDecl <+> stateDecl' <+> interface i
        , implication . concat $
          [ [n <> "_conds" <+> envVar <+> arguments i <+> stateVar]
          , [reachableType <+> stateVar]
          , [stateVar' <+> "=" <+> "snd" <+> parens (n <+> envVar <+> stateVar <+> arguments i)]
          , [coqprop postc]
          ]
        ]

-- | Definition of invariant proposition
invariants :: Interface -> [Invariant] -> T.Text
invariants _ [] = ""
invariants i invs =
  definition "invariants" (envDecl <+> interface i <+> stateDecl) $ indent 2 . conjuction $ invariantProp <$> invs
  where
    invariantProp :: Invariant -> T.Text
    invariantProp (Invariant _ _ _ (PredTimed p _)) = coqprop p


-- | Definition of invariant claim at constructor poststate
invariantInit :: Constructor -> T.Text
invariantInit (Constructor name i _ _ _ _) =
  definition invInitType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [invPropVar <+> envVar <+> arguments i <+> parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i))]
        ]
      ]

-- | Definition of invariant claim for behaviour cases
invariantStep :: Constructor -> T.Text
invariantStep (Constructor _ i _ _ _ _) =
  definition invStepType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i <+> stateDecl <+> stateDecl'
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [stepType <+> stateVar <+> stateVar']
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar']
        ]
      ]

-- | Lemma extending invariant properties' hold to reachable states,
-- given proof of init and step invariance
invariantReachable :: Constructor -> T.Text
invariantReachable (Constructor _ i _ _ _ _) =
  lemma invReachType "" claim proof
  where
    claim = indent 2 $ T.unlines
      [ forAll (envDecl <+> interface i <+> stateDecl <+> invPropDecl i
        <+> parens ("HIPinvInit :" <+> invInitType <+> invPropVar) <+> parens ("HIPinvStep :" <+> invStepType <+> invPropVar))
      , implication . concat $
        [ [reachableFromInitType <+> envVar <+> arguments i <+> stateDecl]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        ]
      ]
    proof = T.unlines $
      [
        "Proof."
      , indent 2 . T.unlines $
        [ "intros" <+> envVar <+> arguments i <+> stateVar <+> invPropVar <+> "HIPinvInit HIPinvStep Hreach."
        , "unfold reachableFromInit in Hreach."
        , "destruct Hreach as [Hinit [HenvThis Hmulti]]."
        , "apply step_multi_step with (P := fun s s' =>" <+> invPropVar <+> envVar <+> arguments i <+> "s ->" <+> invPropVar <+> envVar <+> arguments i <+> "s' ) in Hmulti."
        , "- apply Hmulti."
        , "  apply HIPinvInit; assumption."
        , "- intros s s' Hstep."
        , "  apply HIPinvStep with (STATE := s) (STATE' := s') ; assumption."
        , "- unfold Relation_Definitions.reflexive."
        , "  intros."
        , "  assumption."
        , "- unfold Relation_Definitions.transitive."
        , "  intros s1 s2 s3 Ht1 Ht2 Ht3."
        , "  apply Ht2, Ht1."
        , "  assumption."
        ]
     , "Qed."
     ]

-- | produce a state value from a list of storage updates
-- 'handler' defines what to do in cases where a given name isn't updated
stateval :: Bool -> StorageTyping -> Id -> (Ref LHS -> ValueType -> T.Text) -> [StorageUpdate] -> (T.Text, [T.Text], Int)
stateval ctor store contract handler updates =
  let (texts, finalI) = runSeq (\(n, (t, _)) -> updateVar store updates handler (SVar nowhere Pre contract n) t) (M.toList store')
      (vals, bindings) = unzip texts
      bindings' = concat bindings
      finalBindings = if ctor then env1Binding : bindings' else bindings'
      env1Binding = iEnv 1 <+> ":=" <+> "NextEnv" <+> envVar
  in
  (T.unwords $ stateConstructor : addr : vals, finalBindings, finalI)
  where
    addr = if ctor then parens ("NextAddr" <+> envVar) else parens (T.pack contract <.> addrField <+> stateVar)
    store' = contractStore contract store
 -- let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <.> T.pack cid <+> iEnv i <+> T.unwords args')


contractStore :: Id -> StorageTyping -> Map Id (ValueType, Integer)
contractStore contract store = case M.lookup contract store of
  Just s -> s
  Nothing -> error "Internal error: cannot find constructor in store"


-- | Check is an update update a specific storage reference
eqRef :: Ref LHS -> StorageUpdate -> Bool
eqRef r (Update _ r' _) = r == r'

-- | Check if an update updates a location that has a given storage
-- reference as a base
baseRef :: Ref LHS -> StorageUpdate -> Bool
baseRef baseref (Update _ r _) = hasBase r
  where
    hasBase (SVar _ _ _ _) = False
    hasBase (RArrIdx _ r' _ _) = r' == baseref || hasBase r'
    --hasBase (RMapIdx _ r' _ _) = r' == baseref || hasBase r'
    hasBase (RField _ r' _ _) = r' == baseref || hasBase r'

iState :: Int -> T.Text
iState 0 = "STATE"
iState i = "STATE" <> T.pack (show i)

iEnv :: Int -> T.Text
iEnv 0 = "ENV"
iEnv i = "ENV" <> T.pack (show i)

updateExp :: Exp a -> Fresh (T.Text, [T.Text])
updateExp (Create _ cid args _) = do
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <.> T.pack cid <+> iEnv i <+> T.unwords args')
  pure (iState (i+1), bindings)
updateExp (Address _ (Create _ cid args _)) = do
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <.> T.pack cid <+> iEnv i <+> T.unwords args')
  pure (parens $ T.pack cid <.> addrField <+> iState (i+1), bindings)
updateExp e = pure (coqexp e, [])

updateExpTyped :: TypedExp -> Fresh (T.Text, [T.Text])
updateExpTyped (TExp _ te) = updateExp te

unField :: Ref LHS -> Ref LHS -> Ref LHS
unField rFocus (RField pn r cid x) | r == rFocus = SVar pn Pre cid x --TODO: Think about timing here
unField rFocus (RField pn r cid x) = RField pn (unField rFocus r) cid x
unField _ r' = r'

updateVar :: StorageTyping -> [StorageUpdate] -> (Ref LHS -> ValueType -> T.Text) -> Ref LHS -> ValueType -> Fresh (T.Text, [T.Text])
updateVar store updates handler focus t@(ValueType (TContract cid)) =
  case unsnoc groupedUpdates of
    Nothing -> pure (handler focus t, [])
    Just (_, (firstU@(Update _ _ e) NE.:| [])) | eqRef focus firstU->
      updateExp e
    Just (_, (firstU@(Update _ _ e) NE.:| nextUpdates)) | eqRef focus firstU-> do
      (newState, bindings) <- updateExp e
      (t', bindings') <- unzip <$> traverse (\(n, (t', _)) -> updateVar store nextUpdates (\r _ -> refState newState $ unField focus r) (focus' n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <.> stateConstructor) : parens (T.pack cid <.> addrField <+> newState) : t', bindings ++ concat bindings')
    Just (_, fieldUpdates) -> do
      (t', bindings') <- unzip <$> traverse (\(n, (t', _)) -> updateVar store (NE.toList fieldUpdates) handler (focus' n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <.> stateConstructor) : parens (T.pack cid <.> addrField <+> refState stateVar focus) : t', concat bindings')
  where
    focus' x = RField nowhere focus cid x
    store' = contractStore cid store

    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates
    -- `groupedUpdates` groups all relevant updates by starting a new group 
    -- when an update to the base reference is encountered. Consequently
    -- all updates before the last group will be overwritten and so can be ignored
    groupedUpdates = NE.groupBy (\_ b -> not $ eqRef focus b) focusUpdates

updateVar _ updates handler focus t@(ValueType TAddress) =
  case unsnoc focusUpdates of
    Nothing -> pure (handler focus t, [])
    Just (_, (Update _ _ e)) -> updateExp e
  where
    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates

updateVar _ updates handler focus t@(ValueType (TMapping _ _)) =
  -- Note: If creates are allowed in indices then bindings should be collected from them.
  -- The result type cannot be a contract so no creates, and thus no bindings, are present there.
  pure (foldl updatedVal (handler focus t) (filter (eqRef focus) updates), [])
    where
      updatedVal _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = mappingExp e 0

updateVar _ updates handler focus t@(ValueType _) =
  pure (foldl updatedVal (handler focus t) (filter (eqRef focus) updates), [])
    where
      updatedVal _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = coqexp e



-- | produce a block of declarations from an interface
interface :: Interface -> T.Text
interface (Interface _ decls) =
  T.unwords $ map decl decls where
  decl (Decl (AbiArg AbiAddressType) name) = parens $ T.pack name <+> ":" <+> abiType AbiAddressType
  decl (Decl (ContractArg _ cid) name) = parens $ T.pack name <+> ":" <+> T.pack cid <.> "State"
  decl (Decl (AbiArg t) name) = parens $ T.pack name <+> ":" <+> abiType t

arguments :: Interface -> T.Text
arguments (Interface _ decls) =
  T.unwords $ map (\(Decl _ name) -> T.pack name) decls

-- | coq syntax for a value type
valueType :: ValueType -> T.Text
valueType (ValueType (TContract cid)) = T.pack cid <> "." <> "State" -- the type of a contract is its state record
valueType (ValueType (TMapping k t)) = valueType k <+> "->" <+> valueType t 
valueType (ValueType t) = abiType $ toAbiType t

unfoldMappingType :: TValueType AMapping -> ([ValueType], ValueType)
unfoldMappingType mt = go (ValueType mt) []
  where
    go :: ValueType -> [ValueType] -> ([ValueType], ValueType)
    go (ValueType (TMapping key t)) keys = go t (keys ++ [key])
    go t keys = (keys, t)

-- | coq syntax for an abi type
abiType :: AbiType -> T.Text
abiType (AbiUIntType _) = "Z"
abiType (AbiIntType _) = "Z"
abiType AbiAddressType = "address"
abiType AbiStringType = strMod <.> "string"
abiType a = error $ show a

-- | coq syntax for a return type
returnType :: TypedExp -> T.Text
returnType (TExp (TInteger _ _) _) = "Z"
returnType (TExp TUnboundedInt _) = "Z"
returnType (TExp TAddress _) = "Z"
returnType (TExp TBoolean _) = "bool"
returnType (TExp (TContract _) _) = error "contracts not allowed as return types"
returnType (TExp (TMapping _ _) _) = error "mappings not supported as return types"
returnType (TExp TByteStr _) = error "bytestrings not supported"
returnType (TExp (TStruct _) _) = error "structs not supported"
returnType (TExp (TArray _ _) _) = error "arrays not supported"


-- | default value for a given type
-- this is used in cases where a value is not set in the constructor
defaultVal :: ValueType -> T.Text
defaultVal (ValueType (TMapping _ t)) = parens $
  "fun" <+> "_" <+> "=>" <+> defaultVal t
defaultVal (ValueType (TContract _)) = error "Contracts must be explicitly initialized"
defaultVal (ValueType t) = abiVal $ toAbiType t

abiVal :: AbiType -> T.Text
abiVal (AbiUIntType _) = "0"
abiVal (AbiIntType _) = "0"
abiVal AbiAddressType = "0"
abiVal AbiStringType = strMod <.> "EmptyString"
abiVal _ = error "TODO: missing default values"

-- | coq syntax for an expression
coqexp :: Exp a -> T.Text
-- booleans
coqexp (LitBool _ True)  = "true"
coqexp (LitBool _ False) = "false"
coqexp (And _ e1 e2)  = parens $ "andb"    <+> coqexp e1 <+> coqexp e2
coqexp (Or _ e1 e2)   = parens $ "orb"     <+> coqexp e1 <+> coqexp e2
coqexp (Impl _ e1 e2) = parens $ "implb"   <+> coqexp e1 <+> coqexp e2
coqexp (Eq _ _ e1 e2)   = parens $ coqexp e1  <+> "=?" <+> coqexp e2
coqexp (NEq _ _ e1 e2)  = parens $ "negb" <+> parens (coqexp e1  <+> "=?" <+> coqexp e2)
coqexp (Neg _ e)      = parens $ "negb" <+> coqexp e
coqexp (LT _ e1 e2)   = parens $ coqexp e1 <+> "<?"  <+> coqexp e2
coqexp (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=?" <+> coqexp e2
coqexp (GT _ e1 e2)   = parens $ coqexp e2 <+> "<?"  <+> coqexp e1
coqexp (GEQ _ e1 e2)  = parens $ coqexp e2 <+> "<=?" <+> coqexp e1

-- integers
coqexp (LitInt _ i) = T.pack $ show i
coqexp (Add _ e1 e2) = parens $ coqexp e1 <+> "+" <+> coqexp e2
coqexp (Sub _ e1 e2) = parens $ coqexp e1 <+> "-" <+> coqexp e2
coqexp (Mul _ e1 e2) = parens $ coqexp e1 <+> "*" <+> coqexp e2
coqexp (Div _ e1 e2) = parens $ coqexp e1 <+> "/" <+> coqexp e2
coqexp (Mod _ e1 e2) = parens $ "Z.modulo" <+> coqexp e1 <+> coqexp e2
coqexp (Exp _ e1 e2) = parens $ coqexp e1 <+> "^" <+> coqexp e2
coqexp (IntMin _ n)  = parens $ "INT_MIN"  <+> T.pack (show n)
coqexp (IntMax _ n)  = parens $ "INT_MAX"  <+> T.pack (show n)
coqexp (UIntMin _ n) = parens $ "UINT_MIN" <+> T.pack (show n)
coqexp (UIntMax _ n) = parens $ "UINT_MAX" <+> T.pack (show n)

coqexp (InRange _ vt e) = coqexp (bound vt e)

-- polymorphic
coqexp (VarRef _ _ _ r) = ref r
coqexp (ITE _ b e1 e2) = parens $ "if"
                               <+> coqexp b
                               <+> "then"
                               <+> coqexp e1
                               <+> "else"
                               <+> coqexp e2

-- environment values
-- Relies on the assumption that Coq record fields have the same name
-- as the corresponding Haskell constructor
-- coqexp (IntEnv _ This) = parens $ addrField <+> stateVar
coqexp (IntEnv _ envVal) = parens $ T.pack (show envVal) <+> envVar
-- Contracts
coqexp Create {} = error "Internal error: coqexp called for creation expression; call updateExp"
coqexp (Address _ e) = parens $ addrField <+> coqexp e

coqexp me@(Mapping _ _ _ _) = mappingExp me 0
coqexp me@(MappingUpd _ _ _ _ _) = mappingExp me 0

-- unsupported
coqexp Cat {} = error "bytestrings not supported"
coqexp Slice {} = error "bytestrings not supported"
coqexp ByStr {} = error "bytestrings not supported"
coqexp ByLit {} = error "bytestrings not supported"
coqexp ByEnv {} = error "bytestrings not supported"
coqexp Array {} = error "arrays not supported"

mappingExp :: Exp a -> Int -> T.Text
mappingExp (Mapping _ keyType valType@VType es) level =
  "fun" <+> (anon <> (T.pack $ show level)) <+> "=>" <+>
  foldr (mappingElem level keyType) (defaultVal (ValueType valType)) es
mappingExp (MappingUpd _ r keyType _ es) level =
  "fun" <+> (anon <> (T.pack $ show level)) <+> "=>" <+>
  foldr (mappingElem level keyType) (ref r) es
mappingExp e _ = coqexp e

mappingElem :: Int -> TValueType a -> (Exp a, Exp b) -> T.Text -> T.Text
mappingElem level keyType (key, ve) elseText =
  "if" <+> boolScope (parens (anon <> T.pack (show level)) <+> eqsym keyType <+> coqexp key) <+> 
  "then" <+> mappingExp ve (level + 1) <+>
  "else" <+> elseText

eqsym :: TValueType a -> T.Text
eqsym argType = case argType of
  TInteger _ _ -> "=?"
  TUnboundedInt -> "=?"
  TAddress -> "=?"
  TBoolean -> "=??"
  TMapping _ _ -> error "mapping as keys not supported"
  TByteStr -> error "bytestrings as keys not supported"
  TArray _ _ -> error "arrays as key not supported"
  TStruct _ -> error "structs as key not supported"
  TContract _ -> error "contracts as key not supported"


-- | coq syntax for a proposition
coqprop :: Exp a -> T.Text
coqprop (LitBool _ True)  = "True"
coqprop (LitBool _ False) = "False"
coqprop (And _ e1 e2)  = parens $ coqprop e1 <+> "/\\" <+> coqprop e2
coqprop (Or _ e1 e2)   = parens $ coqprop e1 <+> "\\/" <+> coqprop e2
coqprop (Impl _ e1 e2) = parens $ coqprop e1 <+> "->"  <+> coqprop e2
coqprop (Neg _ e)      = parens $ "not" <+> coqprop e
coqprop (Eq _ _ e1 e2)   = parens $ coqexp e1 <+> "="  <+> coqexp e2
coqprop (NEq _ _ e1 e2)  = parens $ coqexp e1 <+> "<>" <+> coqexp e2
coqprop (LT _ e1 e2)   = parens $ coqexp e1 <+> "<"  <+> coqexp e2
coqprop (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=" <+> coqexp e2
coqprop (GT _ e1 e2)   = parens $ coqexp e1 <+> ">"  <+> coqexp e2
coqprop (GEQ _ e1 e2)  = parens $ coqexp e1 <+> ">=" <+> coqexp e2
coqprop (InRange _ t e) = coqprop (bound t e)

coqprop e = error "ill formed proposition:" <+> T.pack (show e)

-- | coq syntax for a typed expression
typedexp :: TypedExp -> T.Text
typedexp (TExp _ e) = coqexp e

ref :: Ref k -> T.Text
ref (SVar _ Pre cid name) = parens $ T.pack cid <.> T.pack name <+> stateVar
ref (SVar _ Post cid name) = parens $ T.pack cid <.> T.pack name <+> stateVar'
ref (CVar _ _ name) = T.pack name
ref (RArrIdx _ r _ ixs) = parens $ ref r <+> coqargs (fst <$> ixs)
ref (RMapIdx _ r _ ixs) = parens $ ref r <+> coqargs ixs
ref (RField _ r cid name) = parens $ T.pack cid <.> T.pack name <+> ref r

refState :: T.Text -> Ref k -> T.Text
refState s (SVar _ _ cid name) = parens $ T.pack cid <.> T.pack name <+> s
refState _ (CVar _ _ name) = T.pack name
refState s (RArrIdx _ r _ ixs) = parens $ refState s r <+> coqargs (fst <$> ixs)
refState s (RMapIdx _ r _ ixs) = parens $ refState s r <+> coqargs ixs
refState s (RField _ r cid name) = parens $ T.pack cid <.> T.pack name <+> refState s r

-- | coq syntax for a list of arguments
coqargs :: [TypedExp] -> T.Text
coqargs es = T.unwords (map typedexp es)

fresh :: Id -> Fresh T.Text
fresh name = state $ \s -> (T.pack (name <> show s), s + 1)

freshId :: Id -> Fresh Id
freshId name = state $ \s -> (name <> show s, s + 1)

getIncr :: Fresh Int
getIncr = state $ \s -> (s + 1, s + 1)

evalSeq :: Traversable t => (a -> Fresh b) -> t a -> t b
evalSeq f xs = evalState (sequence (f <$> xs)) 0

runSeq :: Traversable t => (a -> Fresh b) -> t a -> (t b, Int)
runSeq f xs = runState (sequence (f <$> xs)) 0

--- text manipulation ---

definition :: T.Text -> T.Text -> T.Text -> T.Text
definition name args value = T.unlines
  [ "Definition" <+> name <+> args <+> ":="
  , value <> "."
  ]

inductive :: T.Text -> T.Text -> T.Text -> [(T.Text, Maybe T.Text, T.Text)] -> T.Text
inductive name args indices constructors = T.unlines
  [ "Inductive" <+> name <+> args <+> ":" <+> indices <+> ":="
  , T.unlines (((<>) "| " . uncurry3 inductiveConstructor) <$> constructors) <> "."
  ]

inductiveConstructor :: T.Text -> Maybe T.Text -> T.Text -> T.Text
inductiveConstructor ctorName Nothing body =
     ctorName <+> ":\n" <> body
inductiveConstructor ctorName (Just bindings) body =
     ctorName <+> ":" <+> forAll bindings <> "\n" <> body

lemma :: T.Text -> T.Text -> T.Text -> T.Text -> T.Text
lemma name args claim proof = T.unlines
  [ "Lemma" <+> name <+> args <+> ":"
  , claim <> "."
  , proof
  ]


-- | forall bindings
forAll :: T.Text -> T.Text
forAll bindings = "forall" <+> bindings <> ","

-- | multiline implication
implication :: [T.Text] -> T.Text
implication xs = "   " <> T.intercalate "\n-> " xs

-- | multiline conjuction
conjuction :: [T.Text] -> T.Text
conjuction [] = "   True"
conjuction xs = "   " <> T.intercalate "\n/\\ " xs

-- | wrap text in parentheses
parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

tuple :: T.Text -> T.Text -> T.Text
tuple a b = "(" <> a <> ", " <> b <> ")"

boolScope :: T.Text -> T.Text
boolScope s = "(" <> s <> ")%bool"

indent :: Int -> T.Text -> T.Text
indent n = T.unlines . fmap (T.replicate n " " <>) . T.lines

(<+>) :: T.Text -> T.Text -> T.Text
"" <+> t2 = t2
t1 <+> "" = t1
t1 <+> t2 = t1 <> " " <> t2

(<.>) :: T.Text -> T.Text -> T.Text
t1 <.> t2 = t1 <> "." <> t2

--- constants ---

-- | string module name
strMod :: T.Text
strMod  = "Str"

-- | base state name
baseVar :: T.Text
baseVar = "BASE"

stateType :: T.Text
stateType = "State"

stateVar :: T.Text
stateVar = "STATE"

stateVar' :: T.Text
stateVar' = "STATE'"

nextVar :: T.Text
nextVar = "NEXT"

stateDecl :: T.Text
stateDecl = parens $ stateVar <+> ":" <+> stateType

stateDecl' :: T.Text
stateDecl' = parens $ stateVar' <+> ":" <+> stateType

stateConstructor :: T.Text
stateConstructor = "state"

addrField :: T.Text
addrField = "addr"

addrFieldDecl :: T.Text
addrFieldDecl = addrField <> " : address"

returnSuffix :: T.Text
returnSuffix = "_ret"

postSuffix :: T.Text
postSuffix = "_post"

invInitType :: T.Text
invInitType  = "invariantInit"

invStepType :: T.Text
invStepType  = "invariantStep"

invReachType :: T.Text
invReachType  = "invariantReachable"

baseSuffix :: T.Text
baseSuffix = "_base"

stepSuffix :: T.Text
stepSuffix = "_step"

introSuffix :: T.Text
introSuffix = "_intro"

localStepType :: Id -> T.Text
localStepType name = T.pack name <> "_step"

stepType :: T.Text
stepType = "step"

stepBeforeType :: T.Text
stepBeforeType = "stepBefore"

extStepType :: T.Text
extStepType = "extStep"

addressInType :: T.Text
addressInType = "addressIn"

contractAddressInType :: T.Text
contractAddressInType = "contractAddressIn"

noAliasingType :: T.Text
noAliasingType = "noAliasing"

nextAddrConstraintType :: T.Text
nextAddrConstraintType = "nextAddrConstraint"

initStateType :: T.Text
initStateType = "init"

initStateBeforeType :: T.Text
initStateBeforeType = "initBefore"

invPropVar :: T.Text
invPropVar = "IP"

invPropType :: Interface -> T.Text
invPropType (Interface _ decls) = T.intercalate " -> " $ concat [[envType], map decl' decls, [stateType, "Prop"]]
  where
  decl' (Decl (ContractArg _ cid) _) = T.pack cid <> ".State"
  decl' (Decl (AbiArg t) _) = abiType t

invPropDecl :: Interface -> T.Text
invPropDecl i = parens $ invPropVar <+> ":" <+> invPropType i

initPrecsType :: T.Text
initPrecsType = "initPreconds"

behvPrecsType :: T.Text
behvPrecsType = "behvPrecs"

multistepType :: T.Text
multistepType = "multistep"

multistepBeforeType :: T.Text
multistepBeforeType = "multistepBefore"

reachableType :: T.Text
reachableType = "reachable"

reachableBeforeType :: T.Text
reachableBeforeType = "reachableBefore"

reachableFromInitType :: T.Text
reachableFromInitType = "reachableFromInit"

reachStep:: T.Text
reachStep= "reach_step"

envType :: T.Text
envType = "Env"

envVar :: T.Text
envVar = "ENV"

envVar' :: T.Text
envVar' = "ENV'"

envDecl :: T.Text
envDecl = parens $ envVar <+> ":" <+> envType

envDecl' :: T.Text
envDecl' = parens $ envVar' <+> ":" <+> envType

envDecl'' :: T.Text
envDecl'' = parens $ "ENV''" <+> ":" <+> envType

anon :: T.Text
anon = "_binding_"
