{-
 -
 - coq backend for act
 -
 - unsupported features:
 - + bytestrings
 - + external storage
 - + casting from addresses to contract
 -
 -}

{-# Language OverloadedStrings #-}
{-# Language RecordWildCards #-}
{-# LANGUAGE GADTs #-}
{-# Language DataKinds #-}
{-# Language ViewPatterns #-}


module Act.Coq where

import Prelude hiding (GT, LT)

import Data.Map.Strict (Map)
import Data.Maybe
import Data.Tuple.Extra
import qualified Data.Map.Strict    as M
import qualified Data.List.NonEmpty as NE
import qualified Data.Text          as T
import Data.List (groupBy)
import Data.List.Extra (snoc, unsnoc)
import Control.Monad.State

import EVM.ABI
import Act.Syntax
import Act.Syntax.TypedExplicit
import Act.Syntax.Timing (Time(..), Timing(..))

type Fresh = State Int

header :: T.Text
header = T.unlines
  [ "(* --- GENERATED BY ACT --- *)\n"
  , "Require Import Stdlib.ZArith.ZArith."
  , "Require Import ActLib.ActLib."
  , "Require Stdlib.Strings.String.\n"
  , "Module " <> strMod <> " := Stdlib.Strings.String."
  , "Open Scope Z_scope.\n"
  ]

-- | produce a coq representation of a specification
coq :: Act -> T.Text
coq (Act store contracts) =
  header <> (T.intercalate "\n\n" $ contractCode store <$> contracts)

contractCode :: Store -> Contract -> T.Text
contractCode store (Contract ctor@Constructor{..} behvs) = T.unlines $
  [ "Module " <> T.pack _cname <> ".\n" ]
  <> [ stateRecord ]
  <> [ contractAddressIn _cname store ]
  <> [ addressIn _cname store ]
  <> [ noAliasing _cname store ]
  <> [ intBounds _cname store ]
  <> [ intBoundsRec _cname store ]
  <> [ nextAddrConstraint ]
  <> [ base store ctor ]
  <> [ initPrecs ctor ]
  <> (filter ((/=) "") [ postCondConstr ctor ])
  <> [ invariants ctor ]
  <> (concatMap (evalSeq behvConds) (groups behvs))
  <> (concatMap (evalSeq (transition store)) (groups behvs))
  <> (filter ((/=) "") $ concatMap (evalSeq retVal) (groups behvs))
  <> [ localStep _cname (groups behvs)]
  <> [ extStep _cname store ]
  <> [ step ]
  <> [ initState ctor ]
  <> [ multistep ]
  <> [ reachable ]
  <> [ reachableFromInit ctor]
  <> [ initStateBefore ctor ]
  <> [ stepBefore ]
  <> [ multistepBefore ]
  <> [ reachableBefore ]
  <> (filter ((/=) "") $ concatMap (evalSeq postCondBehv) (groups behvs))
  <> [ invariantInit ctor ]
  <> [ invariantStep ctor ]
  <> [ invariantReachable ctor]
  <> [ "End " <> T.pack _cname <> "." ]
  where
    groups = groupBy (\b b' -> _name b == _name b')

    stateRecord = T.unlines

      [ "Record" <+> stateType <+> ": Set :=" <+> stateConstructor
      , "{ " <> T.intercalate ("\n" <> "; ") (addrFieldDecl : map decl (M.toList store'))
      , "}."
      ]

    decl (n, (s, _)) = (T.pack n) <> " : " <> slotType s

    store' = contractStore _cname store

-- | Inductive definition of step relation of 2 states
-- that takes into account only transitions of the current contract type
localStep :: Id -> [[Behaviour]] -> T.Text
localStep contract behvs = inductive
  (localStepType contract) "" (envType <+> "->" <+> stateType <+> "->" <+> envType <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = concat (evalSeq stepBehv <$> behvs)

    -- | constructor for the step relation
    stepBehv :: Behaviour -> Fresh (T.Text, Maybe T.Text, T.Text)
    stepBehv (Behaviour name _ i _ _ _ _ _) =
      fresh name >>= continuation where
      continuation name' =
        return (name' <> stepSuffix, Just $ envDecl <+> interface i <+> stateDecl, constructorBody)
        where
          constructorBody = (indent 2) . implication $
            [ name' <> "_conds" <+> envVar <+> arguments i <+> stateVar
            , "This" <+> envVar <+> "=" <+> addrField <+> stateVar
            , (localStepType contract) <+> envVar <+> stateVar <+> parens ("fst" <+> parens ( name' <+> envVar <+> stateVar <+> arguments i))
                                                               <+> parens ("snd" <+> parens ( name' <+> envVar <+> stateVar <+> arguments i))]

-- | Constraint on Env expressing that the NextAddr field should be greated than
-- all addresses contained in the state
nextAddrConstraint :: T.Text
nextAddrConstraint = definition
  nextAddrConstraintType (envDecl <+> stateDecl) body
    where
      body = indent 2 $ forAll (parens ("p : address")) <+>
        (addressInType <+> "p" <+> stateVar) <+> "->" <+> ("NextAddr" <+> envVar <+> "> p")

-- | Inductive definition of step relation of 2 states
-- that takes into account transitions of the current contract type
-- and all transitions possible for contained contracts
extStep :: Id -> Store -> T.Text
extStep main store = inductive
  extStepType "" (envType <+> "->" <+> stateType <+> "->" <+> envType <+> "->" <+> stateType <+> "-> Prop") body
  where
    body =
      (extStepType <> "_" <> T.pack main, Just $ (envDecl <+> envDecl' <+> stateDecl <+> stateDecl')
      , indent 2 $ implication [localStepType main <+> envVar <+> stateVar <+> envVar' <+> stateVar', extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar'])
      : (M.elems $ M.mapMaybeWithKey substep localStore)

    localStore = contractStore main store

    substep :: Id -> (SlotType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    substep var (StorageValue (ContractType cid), _) = Just (extStepType <> "_" <> varp, Just (envDecl <+> stateDecl <+> envVar' <+> stateDecl'), body')
      where
        varp = T.pack var
        body' = indent 2 . implication . concat $
          [ [ nextAddrConstraintType <+> envVar <+> stateVar ]
          , [ "Origin" <+> envVar <+> "<>" <+> addrField <+> stateVar ]
          , [ "Caller" <+> envVar <+> "<>" <+> addrField <+> stateVar ]
          , [ T.pack cid <.> extStepType <+> envVar <+> parens (varp <+> stateVar) <+> envVar' <+> parens (varp <+> stateVar') ]
          , [ addrField <+> stateVar <+> "=" <+> addrField <+> stateVar' ]
          , (\var' -> parens (T.pack var' <+> stateVar) <+> "=" <+> parens (T.pack var' <+> stateVar')) <$> (filter (var /=) $ M.keys localStore)
          , [ "integerBounds" <+> stateVar ]
          , (M.elems $ M.mapMaybeWithKey (subBounds var) localStore)
          , [ extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar' ]
          ]
    substep _ _ = Nothing

    subBounds :: Id -> Id -> (SlotType, Integer) -> Maybe T.Text
    subBounds stepVar var (StorageValue (ContractType cid), _) | var /= stepVar = Just $ T.pack cid <.> "integerBoundsRec" <+> parens (T.pack var <+> stateVar)
    subBounds _ _ _ = Nothing
      


step :: T.Text
step =
  definition stepType (stateDecl <+> stateDecl') $
    "exists" <+> envDecl <+> envDecl' <> "," <+> extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar'

stepBefore :: T.Text
stepBefore =
  definition stepBeforeType (envDecl'' <+> stateDecl <+> stateDecl') $
    "exists" <+> envDecl <+> envDecl' <> "," <+> extStepType <+> envVar <+> stateVar <+> envVar' <+> stateVar'
    <+> "/\\" <+> "NextAddr" <+> envVar' <+> "<=" <+> "NextAddr" <+> "ENV''"


combine :: [a] -> [(a,a)]
combine lst = combine' lst []
  where
    combine' [] acc = concat acc
    combine' (x:xs) acc =
      let xcomb = [ (x, y) | y <- xs] in
      combine' xs (xcomb:acc)

-- | Predicate that holds if p is an address of known contract type
-- in the given state
contractAddressIn :: Id -> Store -> T.Text
contractAddressIn name store = inductive
  contractAddressInType "" ("Z" <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = ("addressOf_This", Just stateDecl, indent 5 $ contractAddressInType <+> parens (addrField <+> stateVar) <+> stateVar)
           : M.elems (M.mapMaybeWithKey subCAddr localStore)

    localStore = contractStore name store

    subCAddr :: Id -> (SlotType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    subCAddr var (StorageValue (ContractType cid), _) = Just ("addressOf_" <> varp, Just $ parens ("p : address") <+> stateDecl, body')
      where
        varp = T.pack var
        body' = indent 2 . implication $
          [ T.pack cid <.> contractAddressInType <+> "p" <+> parens (varp <+> stateVar)
          , contractAddressInType <+> "p" <+> stateVar
          ]
    subCAddr _ _ = Nothing

-- | Predicate that holds if p is an address in the given state
addressIn :: Id -> Store -> T.Text
addressIn name store = inductive
  addressInType "" ("Z" <+> "->" <+> stateType <+> "-> Prop") body
  where
    body = ("address_addr", Just stateDecl, indent 5 $ addressInType <+> parens (addrField <+> stateVar) <+> stateVar)
           : ("address_subcontract", Just $ parens ("p : address") <+> stateDecl, indent 5 $ contractAddressInType <+> "p" <+> stateVar <+> "->" <+> addressInType <+> "p" <+> stateVar)
           : M.elems (M.mapMaybeWithKey subAddr localStore)

    localStore = contractStore name store

    subAddr :: Id -> (SlotType, Integer) -> Maybe (T.Text, Maybe T.Text, T.Text)
    subAddr var (StorageValue (PrimitiveType AbiAddressType), _) =
      let varp = T.pack var in
      Just ("address_" <> varp, Just stateDecl, indent 5 $ addressInType <+>  parens (varp <+> stateVar) <+> stateVar)
    subAddr _ _ = Nothing

slotContractName :: SlotType -> Maybe Id
slotContractName (StorageValue (ContractType cid)) = Just cid
slotContractName _ = Nothing

noAliasing :: Id -> Store -> T.Text
noAliasing name store = inductive
  noAliasingType stateDecl "Prop" [("noAliasingC", Nothing, body)]
  where
    body = indent 2 . implication $
      (addressSubContractAliasing <$> storeContracts)
      <> (contractPairAliasing <$> contractPairs)
      <> (subContractAliasing <$> storeContracts)
      <> [noAliasingType <+> stateVar]

    localStore = contractStore name store
    storeContracts = M.toList $ M.mapMaybe (slotContractName . fst) localStore
    contractPairs = filter (not. uncurry (==)) $ combine storeContracts

    addressSubContractAliasing :: (Id, Id) -> T.Text
    addressSubContractAliasing (cvar, cid) =
      parens $ forAll (parens ("p : address")) <+>
        ( T.pack cid <.> contractAddressInType <+> "p" <+> parens (T.pack cvar <+> stateVar)) <+> "->"
        <+> (parens (addrField <+> stateVar) <+> "<>" <+> "p")

    contractPairAliasing :: ((Id, Id), (Id, Id)) -> T.Text
    contractPairAliasing ((cvar1, cid1), (cvar2, cid2)) =
      parens $ forAll (parens ("p p' : address")) <+>
        ( T.pack cid1 <.> contractAddressInType <+> "p" <+> parens (T.pack cvar1 <+> stateVar)) <+> "->"
        <+> ( T.pack cid2 <.> contractAddressInType <+> "p'" <+> parens (T.pack cvar2 <+> stateVar)) <+> "->"
        <+> ("p" <+> "<>" <+> "p'")

    subContractAliasing :: (Id, Id) -> T.Text
    subContractAliasing (cvar, cid) = T.pack cid <.> noAliasingType <+> parens (T.pack cvar <+> stateVar)

intBounds :: Id -> Store -> T.Text
intBounds name store = inductive
  "integerBounds" stateDecl "Prop" [("integerBoundsC", Nothing, body)]
  where
    body = indent 2 . implication $ ((M.elems $ M.mapMaybeWithKey go localStore) <> ["integerBounds" <+> stateVar])

    localStore = contractStore name store

    go :: Id -> (SlotType, Integer) -> Maybe T.Text
    go v (StorageValue (ContractType cid), _) = Just $
      "0 <=" <+> T.pack cid <.> addrField <+> parens (T.pack v <+> stateVar) <+> "<= UINT_MAX 160"
    go v (StorageValue (PrimitiveType (AbiUIntType n)), _) = Just $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX" <+> T.pack (show n)
    go v (StorageValue (PrimitiveType (AbiIntType n)), _) = Just $
      "INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> "<= INT_MAX" <+> T.pack (show n)
    go v (StorageValue (PrimitiveType (AbiBytesType n)), _) = Just $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX" <+> T.pack (show (8*n))
    go v (StorageMapping is (ContractType cid), _) = Just $ parens $
      "forall" <+> ixs (length is) <> ", 0 <=" <+> T.pack cid <.> addrField <+> parens (T.pack v <+> stateVar <+> ixs (length is)) <+> "<= UINT_MAX 160"
    go v (StorageMapping is (PrimitiveType (AbiUIntType n)), _) = Just $ parens $
      "forall" <+> ixs (length is) <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs (length is) <+> "<= UINT_MAX" <+> T.pack (show n)
    go v (StorageMapping is (PrimitiveType (AbiIntType n)), _) = Just $ parens $
      "forall" <+> ixs (length is) <> ", INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> ixs (length is) <+> "<= INT_MAX" <+> T.pack (show n)
    go v (StorageMapping is (PrimitiveType (AbiBytesType n)), _) = Just $ parens $
      "forall" <+> ixs (length is) <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs (length is) <+> "<= UINT_MAX" <+> T.pack (show (n * 8))
    go _ _ = Nothing

    ixs n = T.unwords $ T.pack . (<>) "i" . show <$> [0..(n-1)]

intBoundsRec :: Id -> Store -> T.Text
intBoundsRec name store = inductive
  "integerBoundsRec" stateDecl "Prop" [("integerBoundsRecC", Nothing, body)]
  where
    body = indent 2 . implication . concat $ ((M.elems $ M.mapWithKey go localStore) <> [["integerBoundsRec" <+> stateVar]])

    localStore = contractStore name store

    go :: Id -> (SlotType, Integer) -> [T.Text]
    go v (StorageValue (ContractType cid), _) =
      [ "0 <=" <+> T.pack cid <.> addrField <+> parens (T.pack v <+> stateVar) <+> "<= UINT_MAX 160"
      , T.pack cid <.> "integerBoundsRec" <+> parens (T.pack v <+> stateVar) ]
    go v (StorageValue (PrimitiveType (AbiUIntType n)), _) = pure $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX" <+> T.pack (show n)
    go v (StorageValue (PrimitiveType (AbiIntType n)), _) = pure $
      "INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> "<= INT_MAX" <+> T.pack (show n)
    go v (StorageValue (PrimitiveType (AbiBytesType n)), _) = pure $
      "0 <=" <+> T.pack v <+> stateVar <+> "<= UINT_MAX" <+> T.pack (show (8*n))
    go v (StorageMapping is (ContractType cid), _) =
      [ parens $ "forall" <+> ixs (length is) <> ", 0 <=" <+> T.pack cid <.> addrField <+> parens (T.pack v <+> stateVar <+> ixs (length is)) <+> "<= UINT_MAX 160"
      , parens $ "forall" <+> ixs (length is) <> "," <+> T.pack cid <.> "integerBoundsRec" <+> parens (T.pack v <+> stateVar <+> ixs (length is)) ]
    go v (StorageMapping is (PrimitiveType (AbiUIntType n)), _) = pure $ parens $
      "forall" <+> ixs (length is) <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs (length is) <+> "<= UINT_MAX" <+> T.pack (show n)
    go v (StorageMapping is (PrimitiveType (AbiIntType n)), _) = pure $ parens $
      "forall" <+> ixs (length is) <> ", INT_MIN" <+> T.pack (show n) <+> "<=" <+> T.pack v <+> stateVar <+> ixs (length is) <+> "<= INT_MAX" <+> T.pack (show n)
    go v (StorageMapping is (PrimitiveType (AbiBytesType n)), _) = pure $ parens $
      "forall" <+> ixs (length is) <> ", 0 <=" <+> T.pack v <+> stateVar <+> ixs (length is) <+> "<= UINT_MAX" <+> T.pack (show (n * 8))
    go _ _ = []

    ixs n = T.unwords $ T.pack . (<>) "i" . show <$> [0..(n-1)]


-- | definition of reachable states
reachable :: T.Text
reachable = definition
  reachableType args value
  where
    args = parens $ stateVar <+> ":" <+> stateType
    value = "exists" <+> stateVar' <> "," <+> initStateType <+> stateVar'
      <+> "/\\" <+> multistepType <+> stateVar' <+> stateVar

reachableBefore :: T.Text
reachableBefore = definition
  reachableBeforeType args value
  where
    args = envDecl' <+> stateDecl --parens $ stateVar <+> ":" <+> stateType
    value = "exists" <+> stateVar' <> "," <+> initStateBeforeType <+> envVar' <+> stateVar'
      <+> "/\\" <+> multistepBeforeType <+> envVar' <+> stateVar' <+> stateVar

-- | specialization of generic multistep
multistep :: T.Text
multistep = definition
  multistepType args value
  where
    args = parens $ stateVar <+> stateVar' <+> ":" <+> stateType
    value = multistepType <+> stepType <+> stateVar <+> stateVar'

multistepBefore :: T.Text
multistepBefore = definition
  multistepBeforeType args value
  where
    args = envDecl' <+> stateDecl <+> stateDecl' -- parens $ stateVar <+> stateVar' <+> ":" <+> stateType
    value = "ActLib" <.> multistepType <+> parens (stepBeforeType <+> envVar') <+> stateVar <+> stateVar'

-- | definition of reachable states from initial constructor parameters
reachableFromInit :: Constructor -> T.Text
reachableFromInit (Constructor name i _ _ _ _ ) = definition
  reachableFromInitType args value
  where
    args = envDecl <+> interface i <+> stateDecl
    value = initPrecsType <+>
      envVar <+> arguments i <+> "/\\"
      <+> "This" <+> envVar <+> "=" <+> parens (addrField <+> parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i))) <+> "/\\"
      <+> multistepType <+> parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i)) <+> stateVar

-- | definition of constructor preconditions
initPrecs :: Constructor -> T.Text
initPrecs (Constructor name i conds _ _ _ ) = inductive
  initPrecsType (envDecl <+> interface i) "Prop" [("ctorPreconds", Nothing, body)]
  where
    body = indent 2 . implication . concat $
      [ coqprop <$> conds
      , interfaceStateVars i
      , ["Caller" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["Origin" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Caller" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Origin" <+> envVar]
      , ["This" <+> envVar <+> "=" <+> "NextAddr" <+> envVar] -- addrField <+> parens ("snd" <+> parens (T.pack name <+> envVar)) ]
      , [ initPrecsType <+> envVar <+> arguments i ]
      ]

    interfaceStateVars :: Interface -> [T.Text]
    interfaceStateVars (Interface _ decls) = concatMap go decls
      where go (Decl (ContractArg _ cid) v) =
              [ T.pack cid <.> nextAddrConstraintType <+> envVar <+> T.pack v
              , T.pack cid <.> reachableBeforeType <+> envVar <+> T.pack v ]
            go (Decl (AbiArg AbiAddressType) v) = pure $ T.pack v <+> "<" <+> "NextAddr" <+> envVar
            go _ = []

-- | definition of behaviour-case conditions
behvConds :: Behaviour -> Fresh T.Text
behvConds (Behaviour name _ i conds casecs _ _ _) = do
  name' <- fresh name
  pure $ inductive
    (name' <> "_conds") (envDecl <+> interface i <+> stateDecl) "Prop" [((name' <> "_condsC"), Nothing, body name')]
  where
    body n = indent 2 . implication . concat $
      [ coqprop <$> (conds <> casecs)
      , [ nextAddrConstraintType <+> envVar <+> stateVar ]
      , interfaceStateVars i
      , ["This" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["Caller" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["Origin" <+> envVar <+> "<" <+> "NextAddr" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Caller" <+> envVar]
      , ["This" <+> envVar <+> "<>" <+> "Origin" <+> envVar]
      , ["This" <+> envVar <+> "=" <+> addrField <+> stateVar ]
      , [ (n <> "_conds") <+> envVar <+> arguments i <+> stateVar ]
      ]

    interfaceStateVars :: Interface -> [T.Text]
    interfaceStateVars (Interface _ decls) = mapMaybe go decls
      where go (Decl (ContractArg _ cid) v) = Just $ T.pack cid <.> nextAddrConstraintType <+> envVar <+> T.pack v
            go (Decl (AbiArg AbiAddressType) v) = Just $ T.pack v <+> "<" <+> "NextAddr" <+> envVar
            go _ = Nothing

-- | predicate characterizing all initial (post constructor) states
initState :: Constructor -> T.Text
initState (Constructor name i _ _ _ _) = inductive
  initStateType "" (stateType <+> "->" <+> "Prop") [("InitState", Just $ envDecl <+> interface i, constructorBody)]
  where
    baseval = parens $ "snd" <+> parens (T.pack name <+> envVar <+> arguments i)
    constructorBody = (indent 2) . implication . concat $
      [ [initPrecsType <+> envVar <+> arguments i]
      , ["This" <+> envVar <+> "=" <+> addrField <+> baseval]
      , [initStateType <+> baseval]
      ]

-- | predicate characterizing all initial (post constructor) states that can be instantiated before a given environment
initStateBefore :: Constructor -> T.Text
initStateBefore (Constructor name i _ _ _ _) = inductive
  initStateBeforeType "" (envType <+> "->" <+> stateType <+> "->" <+> "Prop")
  [("InitStateBefore", Just $ envDecl <+> interface i <+> envDecl' <+> fenvDecl <+> stateDecl , constructorBody)]
  where
    baseval = parens $ "snd" <+> parens (T.pack name <+> envVar <+> arguments i)
    constructorBody = (indent 2) . implication . concat $
      [ [initPrecsType <+> envVar <+> arguments i]
      , [tuple envVar' stateVar <+> "=" <+> T.pack name <.> T.pack name <+> envVar <+> arguments i]
      , ["This" <+> envVar <+> "=" <+> addrField <+> stateDecl]
      , ["NextAddr" <+> envVar' <+> "<=" <+> "NextAddr" <+> fenvVar]
      , [initStateBeforeType <+> fenvVar <+> baseval]
      ]

    fenvVar = "FENV" :: T.Text
    fenvDecl :: T.Text
    fenvDecl = parens $ fenvVar <+> ":" <+> envType

-- | definition of a base state
base :: Store -> Constructor -> T.Text
base store (Constructor name i _ _ _ updates) =
  let (s, bindings, finalI) = stateval True store name (\_ t -> defaultSlotValue t) updates
  in
  definition (T.pack name) (envDecl <+> interface i)
  (foldr (\a s' -> "let" <+> a <+> "in\n" <> s') (tuple (iEnv $ finalI + 1) s) bindings)

transition :: Store -> Behaviour -> Fresh T.Text
transition store (Behaviour name cname i _ _ _ rewrites _) = do
  name' <- fresh name
  let (s, bindings, finalI) = stateval False store cname (\r _ -> ref stateVar r) rewrites
  return $ definition name' (envDecl <+> stateDecl <+> interface i) $ foldr (\a s' -> "let" <+> a <+> "in\n" <> s') (tuple (iEnv finalI) s) bindings

-- | inductive definition of a return claim
-- ignores claims that do not specify a return value
retVal :: Behaviour -> Fresh T.Text
retVal (Behaviour name _ i _ cases _ _ (Just r)) =
  fresh name >>= continuation where
  continuation name' = return $ inductive
    (name' <> returnSuffix)
    (envDecl <+> stateDecl <+> interface i)
    (returnType r <> " -> Prop")
    [(retname <> introSuffix, Nothing, body)] where

    retname = name' <> returnSuffix
    body = indent 2 . implication . concat $
      [ [name' <> "_conds" <+> envVar <+> arguments i <+> stateVar]
      , coqprop <$> cases
      , [retname <+> envVar <+> stateVar <+> arguments i <+> typedexp r]
      ]

retVal _ = return ""

-- | Definition of postcondition claim for constructor
postCondConstr :: Constructor -> T.Text
postCondConstr (Constructor _ _ _ [] _ _) = ""
postCondConstr (Constructor name i _ postcs _ _) =
  T.intercalate "\n\n" $ evalSeq post postcs
    where
    post :: Exp ABoolean -> Fresh T.Text
    post pc =
      fresh (name <> T.unpack postSuffix) >>= continuation where
      continuation postName = return $ definition postName "" body
      body = indent 2 $ T.unlines
        [ forAll $ envDecl <+> interface i <+> stateDecl'
        , implication . concat $
          [ [initPrecsType <+> envVar <+> arguments i]
          , [stateVar' <+> "=" <+> "snd" <+> parens (T.pack name <+> envVar <+> arguments i)]
          , [coqprop pc]
          ]
        ]

-- | Definition of postcondition claim for behaviour cases
postCondBehv :: Behaviour -> Fresh T.Text
postCondBehv (Behaviour _ _ _ _ _ [] _ _) = return ""
postCondBehv (Behaviour name _ i _ _ postcs _ _) =
  fresh name >>= continuation where
  continuation name' = return $ T.intercalate "\n\n" $ evalSeq (post name') postcs
    where
      post :: T.Text -> Exp ABoolean -> Fresh T.Text
      post case_name pc =
        fresh (T.unpack $ case_name <> postSuffix) >>= continuation' where
        continuation' postName = return $ definition postName "" body
        body = indent 2 $ T.unlines
          [ forAll $ envDecl <+> stateDecl <+> stateDecl' <+> interface i
          , implication . concat $
            [ [name' <> "_conds" <+> envVar <+> arguments i <+> stateVar]
            , [reachableType <+> stateVar]
            , [stateVar' <+> "=" <+> "snd" <+> parens (name' <+> envVar <+> stateVar <+> arguments i)]
            , [coqprop pc]
            ]
          ]

-- | Definition of invariant proposition
invariants :: Constructor -> T.Text
invariants (Constructor _ _ _ _ [] _) = ""
invariants (Constructor _ i _ _ invs _) =
  definition "invariants" (envDecl <+> interface i <+> stateDecl) $ indent 2 . conjuction $ invariantProp <$> invs
  where
    invariantProp :: Invariant -> T.Text
    invariantProp (Invariant _ _ _ (PredTimed p _)) = coqprop p


-- | Definition of invariant claim at constructor poststate
invariantInit :: Constructor -> T.Text
invariantInit (Constructor name i _ _ _ _) =
  definition invInitType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [invPropVar <+> envVar <+> arguments i <+> parens ("snd" <+> parens (T.pack name <+> envVar <+> arguments i))]
        ]
      ]

-- | Definition of invariant claim for behaviour cases
invariantStep :: Constructor -> T.Text
invariantStep (Constructor _ i _ _ _ _) =
  definition invStepType (invPropDecl i) claim
  where
    claim = indent 2 $ T.unlines
      [ forAll $ envDecl <+> interface i <+> stateDecl <+> stateDecl'
      , implication . concat $
        [ [initPrecsType <+> envVar <+> arguments i]
        , [stepType <+> stateVar <+> stateVar']
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar']
        ]
      ]

-- | Lemma extending invariant properties' hold to reachable states,
-- given proof of init and step invariance
invariantReachable :: Constructor -> T.Text
invariantReachable (Constructor _ i _ _ _ _) =
  lemma invReachType "" claim proof
  where
    claim = indent 2 $ T.unlines
      [ forAll (envDecl <+> interface i <+> stateDecl <+> invPropDecl i
        <+> parens ("HIPinvInit :" <+> invInitType <+> invPropVar) <+> parens ("HIPinvStep :" <+> invStepType <+> invPropVar))
      , implication . concat $
        [ [reachableFromInitType <+> envVar <+> arguments i <+> stateDecl]
        , [invPropVar <+> envVar <+> arguments i <+> stateVar]
        ]
      ]
    proof = T.unlines $
      [
        "Proof."
      , indent 2 . T.unlines $
        [ "intros" <+> envVar <+> arguments i <+> stateVar <+> invPropVar <+> "HIPinvInit HIPinvStep Hreach."
        , "unfold reachableFromInit in Hreach."
        , "destruct Hreach as [Hinit [HenvThis Hmulti]]."
        , "apply step_multi_step with (P := fun s s' =>" <+> invPropVar <+> envVar <+> arguments i <+> "s ->" <+> invPropVar <+> envVar <+> arguments i <+> "s' ) in Hmulti."
        , "- apply Hmulti."
        , "  apply HIPinvInit; assumption."
        , "- intros s s' Hstep."
        , "  apply HIPinvStep with (STATE := s) (STATE' := s') ; assumption."
        , "- unfold Relation_Definitions.reflexive."
        , "  intros."
        , "  assumption."
        , "- unfold Relation_Definitions.transitive."
        , "  intros s1 s2 s3 Ht1 Ht2 Ht3."
        , "  apply Ht2, Ht1."
        , "  assumption."
        ]
     , "Qed."
     ]

-- | produce a state value from a list of storage updates
-- 'handler' defines what to do in cases where a given name isn't updated
stateval :: Bool -> Store -> Id -> (Ref Storage -> SlotType -> T.Text) -> [StorageUpdate] -> (T.Text, [T.Text], Int)
stateval ctor store contract handler updates =
  let (texts, finalI) = runSeq (\(n, (t, _)) -> updateVar store updates handler (SVar nowhere contract n) t) (M.toList store')
      (vals, bindings) = unzip texts
      bindings' = concat bindings
      finalBindings = if ctor then env1Binding : bindings' else bindings'
      env1Binding = iEnv 1 <+> ":=" <+> "NextEnv" <+> envVar
  in
  (T.unwords $ stateConstructor : addr : vals, finalBindings, finalI)
  where
    addr = if ctor then parens ("NextAddr" <+> envVar) else parens (T.pack contract <.> addrField <+> stateVar)
    store' = contractStore contract store
 -- let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <.> T.pack cid <+> iEnv i <+> T.unwords args')


contractStore :: Id -> Store -> Map Id (SlotType, Integer)
contractStore contract store = case M.lookup contract store of
  Just s -> s
  Nothing -> error "Internal error: cannot find constructor in store"


-- | Check is an update update a specific storage reference
eqRef :: Ref Storage -> StorageUpdate -> Bool
eqRef r (Update _ (Item _ r') _) = r == r'

-- | Check if an update updates a location that has a given storage
-- reference as a base
baseRef :: Ref Storage -> StorageUpdate -> Bool
baseRef baseref (Update _ (Item _ r) _) = hasBase r
  where
    hasBase (SVar _ _ _) = False
    hasBase (SArray _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SMapping _ r' _ _) = r' == baseref || hasBase r'
    hasBase (SField _ r' _ _) = r' == baseref || hasBase r'

iState :: Int -> T.Text
iState 0 = "STATE"
iState i = "STATE" <> T.pack (show i)

iEnv :: Int -> T.Text
iEnv 0 = "ENV"
iEnv i = "ENV" <> T.pack (show i)

updateExp :: Exp a -> Fresh (T.Text, [T.Text])
updateExp (Create _ cid args) = do
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <.> T.pack cid <+> iEnv i <+> T.unwords args')
  pure (iState (i+1), bindings)
updateExp (Address _ (Create _ cid args)) = do
  (args', argBindings) <- unzip <$> mapM updateExpTyped args
  i <- getIncr
  let bindings = snoc (concat argBindings) (tuple (iEnv (i+1)) (iState (i+1)) <+> ":=" <+> T.pack cid <.> T.pack cid <+> iEnv i <+> T.unwords args')
  pure (parens $ T.pack cid <.> addrField <+> iState (i+1), bindings)
updateExp e = pure (coqexp e, [])

updateExpTyped :: TypedExp -> Fresh (T.Text, [T.Text])
updateExpTyped (TExp _ _ te) = updateExp te

unField :: Ref Storage -> Ref Storage -> Ref Storage
unField rFocus (SField pn r cid x) | r == rFocus = SVar pn cid x
unField rFocus (SField pn r cid x) = SField pn (unField rFocus r) cid x
unField _ r' = r'

updateVar :: Store -> [StorageUpdate] -> (Ref Storage -> SlotType -> T.Text) -> Ref Storage -> SlotType -> Fresh (T.Text, [T.Text])
updateVar store updates handler focus t@(StorageValue (ContractType cid)) =
  case unsnoc groupedUpdates of
    Nothing -> pure (handler focus t, [])
    Just (_, (firstU@(Update _ _ e) NE.:| [])) | eqRef focus firstU->
      updateExp e
    Just (_, (firstU@(Update _ _ e) NE.:| nextUpdates)) | eqRef focus firstU-> do
      (newState, bindings) <- updateExp e
      (t', bindings') <- unzip <$> traverse (\(n, (t', _)) -> updateVar store nextUpdates (\r _ -> ref newState $ unField focus r) (focus' n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <.> stateConstructor) : parens (T.pack cid <.> addrField <+> newState) : t', bindings ++ concat bindings')
    Just (_, fieldUpdates) -> do
      (t', bindings') <- unzip <$> traverse (\(n, (t', _)) -> updateVar store (NE.toList fieldUpdates) handler (focus' n) t') (M.toList store')
      pure (parens $ T.unwords $ (T.pack cid <.> stateConstructor) : parens (T.pack cid <.> addrField <+> ref stateVar focus) : t', concat bindings')
  where
    focus' x = SField nowhere focus cid x
    store' = contractStore cid store

    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates
    -- `groupedUpdates` groups all relevant updates by starting a new group 
    -- when an update to the base reference is encountered. Consequently
    -- all updates before the last group will be overwritten and so can be ignored
    groupedUpdates = NE.groupBy (\_ b -> not $ eqRef focus b) focusUpdates

updateVar _ updates handler focus t@(StorageValue (PrimitiveType AbiAddressType)) =
  case unsnoc focusUpdates of
    Nothing -> pure (handler focus t, [])
    Just (_, (Update _ _ e)) -> updateExp e
  where
    focusUpdates = filter (\u -> eqRef focus u || baseRef focus u) updates

updateVar _ updates handler focus t@(StorageValue (PrimitiveType _)) =
  pure (foldl updatedVal (handler focus t) (filter (eqRef focus) updates), [])
    where
      updatedVal _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedVal _ (Update _ _ e) = coqexp e

updateVar _ updates handler focus t@(StorageMapping xs _) = pure (parens $
  -- Note: If creates are allowed in indices then bindings should be collected from them.
  -- Note: If creates are allowed in indices then bindings should be collected from them.
  -- The result type cannot be a contract so no creates, and thus no bindings, are present there.
  -- The result type cannot be a contract so no creates, and thus no bindings, are present there.

  -- Note: If creates are allowed in indices then bindings should be collected from them.
  -- The result type cannot be a contract so no creates, and thus no bindings, are present there.
  lambda n <+> foldl updatedMap prestate (filter (baseRef focus) updates), [])
    where
      prestate = parens $ handler focus t <+> lambdaArgs n
      n = length xs

      updatedMap _ (Update TByteStr _ _) = error "bytestrings not supported"
      updatedMap prestate' (Update _ item e) =
        let ixs = ixsFromItem item in
        "if" <+> boolScope (T.intercalate " && " (map cond (zip ixs ([0..] :: [Int]))))
        <+> "then" <+> coqexp e
        <+> "else" <+> prestate'

      cond (TExp argType arg, i) = parens $ anon <> T.pack (show i) <> eqsym argType <> coqexp arg

      lambda i = if i >= 0 then "fun" <+> lambdaArgs i <+> "=>" else ""

      lambdaArgs i = T.unwords $ map (\a -> anon <> T.pack (show a)) ([0..i-1] :: [Int])

      eqsym :: TValueType a -> T.Text
      eqsym argType = case argType of
        TInteger _ _ -> "=?"
        TAddress -> "=?"
        TBoolean -> "=??"
        TByteStr -> error "bytestrings not supported"
        TArray _ _ -> error "arrays not supported"
        TStruct _ -> error "structs not supported"
        TContract _ -> error "contracts not supported" --TODO


-- | produce a block of declarations from an interface
interface :: Interface -> T.Text
interface (Interface _ decls) =
  T.unwords $ map decl decls where
  decl (Decl (AbiArg AbiAddressType) name) = parens $ T.pack name <+> ":" <+> abiType AbiAddressType
  decl (Decl (ContractArg _ cid) name) = parens $ T.pack name <+> ":" <+> T.pack cid <.> "State"
  decl (Decl (AbiArg t) name) = parens $ T.pack name <+> ":" <+> abiType t

arguments :: Interface -> T.Text
arguments (Interface _ decls) =
  T.unwords $ map (\(Decl _ name) -> T.pack name) decls

-- | coq syntax for a slot type
slotType :: SlotType -> T.Text
slotType (StorageMapping xs t) =
  T.intercalate " -> " (map mappingIdxType (NE.toList xs ++ [t]))
slotType (StorageValue val) = valueType val

valueType :: ValueType -> T.Text
valueType (ValueType (TContract cid)) = T.pack cid <> "." <> "State" -- the type of a contract is its state record
valueType (ValueType t) = abiType $ toAbiType t

mappingIdxType :: ValueType -> T.Text
mappingIdxType (PrimitiveType t) = abiType t
mappingIdxType (ContractType _) = "address" -- index by addresses, not contents of states

-- | coq syntax for an abi type
abiType :: AbiType -> T.Text
abiType (AbiUIntType _) = "Z"
abiType (AbiIntType _) = "Z"
abiType AbiAddressType = "address"
abiType AbiStringType = strMod <.> "string"
abiType a = error $ show a

-- | coq syntax for a return type
returnType :: TypedExp -> T.Text
returnType (TExp (TInteger _ _) _) = "Z"
returnType (TExp TAddress _) = "Z"
returnType (TExp TBoolean _) = "bool"
returnType (TExp TByteStr _) = error "bytestrings not supported"
returnType (TExp (TStruct _) _) = error "structs not supported"
returnType (TExp (TContract _) _) = error "contracts not allowed as return types"
returnType (TExp (TArray _ _) _) = error "arrays not supported"

-- | default value for a given type
-- this is used in cases where a value is not set in the constructor
defaultSlotValue :: SlotType -> T.Text
defaultSlotValue (StorageMapping xs t) = parens $
  "fun"
  <+> T.unwords (replicate (length (NE.toList xs)) "_")
  <+> "=>"
  <+> defaultVal t
defaultSlotValue (StorageValue t) = defaultVal t

defaultVal :: ValueType -> T.Text
defaultVal (ValueType (TContract _)) = error "Contracts must be explicitly initialized"
defaultVal (ValueType t) = abiVal $ toAbiType t

abiVal :: AbiType -> T.Text
abiVal (AbiUIntType _) = "0"
abiVal (AbiIntType _) = "0"
abiVal AbiAddressType = "0"
abiVal AbiStringType = strMod <.> "EmptyString"
abiVal _ = error "TODO: missing default values"

-- | coq syntax for an expression
coqexp :: Exp a -> T.Text
-- booleans
coqexp (LitBool _ True)  = "true"
coqexp (LitBool _ False) = "false"
coqexp (And _ e1 e2)  = parens $ "andb"    <+> coqexp e1 <+> coqexp e2
coqexp (Or _ e1 e2)   = parens $ "orb"     <+> coqexp e1 <+> coqexp e2
coqexp (Impl _ e1 e2) = parens $ "implb"   <+> coqexp e1 <+> coqexp e2
coqexp (Eq _ _ e1 e2)   = parens $ coqexp e1  <+> "=?" <+> coqexp e2
coqexp (NEq _ _ e1 e2)  = parens $ "negb" <+> parens (coqexp e1  <+> "=?" <+> coqexp e2)
coqexp (Neg _ e)      = parens $ "negb" <+> coqexp e
coqexp (LT _ e1 e2)   = parens $ coqexp e1 <+> "<?"  <+> coqexp e2
coqexp (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=?" <+> coqexp e2
coqexp (GT _ e1 e2)   = parens $ coqexp e2 <+> "<?"  <+> coqexp e1
coqexp (GEQ _ e1 e2)  = parens $ coqexp e2 <+> "<=?" <+> coqexp e1

-- integers
coqexp (LitInt _ i) = T.pack $ show i
coqexp (Add _ e1 e2) = parens $ coqexp e1 <+> "+" <+> coqexp e2
coqexp (Sub _ e1 e2) = parens $ coqexp e1 <+> "-" <+> coqexp e2
coqexp (Mul _ e1 e2) = parens $ coqexp e1 <+> "*" <+> coqexp e2
coqexp (Div _ e1 e2) = parens $ coqexp e1 <+> "/" <+> coqexp e2
coqexp (Mod _ e1 e2) = parens $ "Z.modulo" <+> coqexp e1 <+> coqexp e2
coqexp (Exp _ e1 e2) = parens $ coqexp e1 <+> "^" <+> coqexp e2
coqexp (IntMin _ n)  = parens $ "INT_MIN"  <+> T.pack (show n)
coqexp (IntMax _ n)  = parens $ "INT_MAX"  <+> T.pack (show n)
coqexp (UIntMin _ n) = parens $ "UINT_MIN" <+> T.pack (show n)
coqexp (UIntMax _ n) = parens $ "UINT_MAX" <+> T.pack (show n)

coqexp (InRange _ vt e) = coqexp (bound vt e)

-- polymorphic
coqexp (VarRef _ whn _ i) = entry whn i
coqexp (ITE _ b e1 e2) = parens $ "if"
                               <+> coqexp b
                               <+> "then"
                               <+> coqexp e1
                               <+> "else"
                               <+> coqexp e2

-- environment values
-- Relies on the assumption that Coq record fields have the same name
-- as the corresponding Haskell constructor
-- coqexp (IntEnv _ This) = parens $ addrField <+> stateVar
coqexp (IntEnv _ envVal) = parens $ T.pack (show envVal) <+> envVar
-- Contracts
coqexp Create {} = error "Internal error: coqexp called for creation expression; call updateExp"
coqexp (Address cid e) = parens $ T.pack cid <.> addrField <+> coqexp e
-- unsupported
coqexp Cat {} = error "bytestrings not supported"
coqexp Slice {} = error "bytestrings not supported"
coqexp ByStr {} = error "bytestrings not supported"
coqexp ByLit {} = error "bytestrings not supported"
coqexp ByEnv {} = error "bytestrings not supported"
coqexp Array {} = error "arrays not supported"

-- | coq syntax for a proposition
coqprop :: Exp a -> T.Text
coqprop (LitBool _ True)  = "True"
coqprop (LitBool _ False) = "False"
coqprop (And _ e1 e2)  = parens $ coqprop e1 <+> "/\\" <+> coqprop e2
coqprop (Or _ e1 e2)   = parens $ coqprop e1 <+> "\\/" <+> coqprop e2
coqprop (Impl _ e1 e2) = parens $ coqprop e1 <+> "->"  <+> coqprop e2
coqprop (Neg _ e)      = parens $ "not" <+> coqprop e
coqprop (Eq _ _ e1 e2)   = parens $ coqexp e1 <+> "="  <+> coqexp e2
coqprop (NEq _ _ e1 e2)  = parens $ coqexp e1 <+> "<>" <+> coqexp e2
coqprop (LT _ e1 e2)   = parens $ coqexp e1 <+> "<"  <+> coqexp e2
coqprop (LEQ _ e1 e2)  = parens $ coqexp e1 <+> "<=" <+> coqexp e2
coqprop (GT _ e1 e2)   = parens $ coqexp e1 <+> ">"  <+> coqexp e2
coqprop (GEQ _ e1 e2)  = parens $ coqexp e1 <+> ">=" <+> coqexp e2
coqprop (InRange _ t e) = coqprop (bound t e)

coqprop e = error "ill formed proposition:" <+> T.pack (show e)

-- | coq syntax for a typed expression
typedexp :: TypedExp -> T.Text
typedexp (TExp _ e) = coqexp e

entry :: Time 'Timed -> TItem k a -> T.Text
entry _ (Item TByteStr _) = error "bytestrings not supported"
entry whn (Item _ r) = ref whn r

ref :: T.Text -> Ref k -> T.Text
ref refState (SVar _ cid name) = parens $ T.pack cid <.> T.pack name <+> refState
ref _ (CVar _ _ name) = T.pack name
ref refState (SArray _ r _ ixs) = parens $ ref refState r <+> coqargs (fst <$> ixs)
ref refState (SMapping _ r _ ixs) = parens $ ref refState r <+> coqargs ixs
ref refState (SField _ r cid name) = parens $ T.pack cid <.> T.pack name <+> ref refState r

-- | coq syntax for a list of arguments
coqargs :: [TypedExp] -> T.Text
coqargs es = T.unwords (map typedexp es)

fresh :: Id -> Fresh T.Text
fresh name = state $ \s -> (T.pack (name <> show s), s + 1)

getIncr :: Fresh Int
getIncr = state $ \s -> (s + 1, s + 1)

evalSeq :: Traversable t => (a -> Fresh b) -> t a -> t b
evalSeq f xs = evalState (sequence (f <$> xs)) 0

runSeq :: Traversable t => (a -> Fresh b) -> t a -> (t b, Int)
runSeq f xs = runState (sequence (f <$> xs)) 0

--- text manipulation ---

definition :: T.Text -> T.Text -> T.Text -> T.Text
definition name args value = T.unlines
  [ "Definition" <+> name <+> args <+> ":="
  , value <> "."
  ]

inductive :: T.Text -> T.Text -> T.Text -> [(T.Text, Maybe T.Text, T.Text)] -> T.Text
inductive name args indices constructors = T.unlines
  [ "Inductive" <+> name <+> args <+> ":" <+> indices <+> ":="
  , T.unlines (((<>) "| " . uncurry3 inductiveConstructor) <$> constructors) <> "."
  ]

inductiveConstructor :: T.Text -> Maybe T.Text -> T.Text -> T.Text
inductiveConstructor ctorName Nothing body =
     ctorName <+> ":\n" <> body
inductiveConstructor ctorName (Just bindings) body =
     ctorName <+> ":" <+> forAll bindings <> "\n" <> body

lemma :: T.Text -> T.Text -> T.Text -> T.Text -> T.Text
lemma name args claim proof = T.unlines
  [ "Lemma" <+> name <+> args <+> ":"
  , claim <> "."
  , proof
  ]


-- | forall bindings
forAll :: T.Text -> T.Text
forAll bindings = "forall" <+> bindings <> ","

-- | multiline implication
implication :: [T.Text] -> T.Text
implication xs = "   " <> T.intercalate "\n-> " xs

-- | multiline conjuction
conjuction :: [T.Text] -> T.Text
conjuction [] = "   True"
conjuction xs = "   " <> T.intercalate "\n/\\ " xs

-- | wrap text in parentheses
parens :: T.Text -> T.Text
parens s = "(" <> s <> ")"

tuple :: T.Text -> T.Text -> T.Text
tuple a b = "(" <> a <> ", " <> b <> ")"

boolScope :: T.Text -> T.Text
boolScope s = "(" <> s <> ")%bool"

indent :: Int -> T.Text -> T.Text
indent n = T.unlines . fmap (T.replicate n " " <>) . T.lines

(<+>) :: T.Text -> T.Text -> T.Text
"" <+> t2 = t2
t1 <+> "" = t1
t1 <+> t2 = t1 <> " " <> t2

(<.>) :: T.Text -> T.Text -> T.Text
t1 <.> t2 = t1 <> "." <> t2

--- constants ---

-- | string module name
strMod :: T.Text
strMod  = "Str"

-- | base state name
baseVar :: T.Text
baseVar = "BASE"

stateType :: T.Text
stateType = "State"

stateVar :: T.Text
stateVar = "STATE"

stateVar' :: T.Text
stateVar' = "STATE'"

nextVar :: T.Text
nextVar = "NEXT"

stateDecl :: T.Text
stateDecl = parens $ stateVar <+> ":" <+> stateType

stateDecl' :: T.Text
stateDecl' = parens $ stateVar' <+> ":" <+> stateType

stateConstructor :: T.Text
stateConstructor = "state"

addrField :: T.Text
addrField = "addr"

addrFieldDecl :: T.Text
addrFieldDecl = addrField <> " : address"

returnSuffix :: T.Text
returnSuffix = "_ret"

postSuffix :: T.Text
postSuffix = "_post"

invInitType :: T.Text
invInitType  = "invariantInit"

invStepType :: T.Text
invStepType  = "invariantStep"

invReachType :: T.Text
invReachType  = "invariantReachable"

baseSuffix :: T.Text
baseSuffix = "_base"

stepSuffix :: T.Text
stepSuffix = "_step"

introSuffix :: T.Text
introSuffix = "_intro"

localStepType :: Id -> T.Text
localStepType name = T.pack name <> "_step"

stepType :: T.Text
stepType = "step"

stepBeforeType :: T.Text
stepBeforeType = "stepBefore"

extStepType :: T.Text
extStepType = "extStep"

addressInType :: T.Text
addressInType = "addressIn"

contractAddressInType :: T.Text
contractAddressInType = "contractAddressIn"

noAliasingType :: T.Text
noAliasingType = "noAliasing"

nextAddrConstraintType :: T.Text
nextAddrConstraintType = "nextAddrConstraint"

initStateType :: T.Text
initStateType = "init"

initStateBeforeType :: T.Text
initStateBeforeType = "initBefore"

invPropVar :: T.Text
invPropVar = "IP"

invPropType :: Interface -> T.Text
invPropType (Interface _ decls) = T.intercalate " -> " $ concat [[envType], map decl' decls, [stateType, "Prop"]]
  where
  decl' (Decl (ContractArg _ cid) _) = T.pack cid <> ".State"
  decl' (Decl (AbiArg t) _) = abiType t

invPropDecl :: Interface -> T.Text
invPropDecl i = parens $ invPropVar <+> ":" <+> invPropType i

initPrecsType :: T.Text
initPrecsType = "initPreconds"

behvPrecsType :: T.Text
behvPrecsType = "behvPrecs"

multistepType :: T.Text
multistepType = "multistep"

multistepBeforeType :: T.Text
multistepBeforeType = "multistepBefore"

reachableType :: T.Text
reachableType = "reachable"

reachableBeforeType :: T.Text
reachableBeforeType = "reachableBefore"

reachableFromInitType :: T.Text
reachableFromInitType = "reachableFromInit"

reachStep:: T.Text
reachStep= "reach_step"

envType :: T.Text
envType = "Env"

envVar :: T.Text
envVar = "ENV"

envVar' :: T.Text
envVar' = "ENV'"

envDecl :: T.Text
envDecl = parens $ envVar <+> ":" <+> envType

envDecl' :: T.Text
envDecl' = parens $ envVar' <+> ":" <+> envType

envDecl'' :: T.Text
envDecl'' = parens $ "ENV''" <+> ":" <+> envType

anon :: T.Text
anon = "_binding_"
