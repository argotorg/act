# How to Write Your Own Spec

This section provides a step-by-step guide on writing your own Act specification for an Ethereum smart contract. We will cover the essential components, best practices, and common patterns to help you get started quickly.

<!--  
- inrange - > for every arithmetic operation that can overflow or underflow, add - an inrange check before it. See Arithmetic Safety for more details.
- transitions -> also getter functions have to be considered
- require -> precondition
- inline function calls
- overview of from general to specific in updates
- initialize balance? -->

## Overview: From Solidity to Act

The general process of writing an Act specification involves: EDIT AFTERWARDS

1. **Identify the storage**: What state variables does your contract have?
2. **Write the constructor**: Define the constructor to initialize all storage variables.
3. **Declare storage in the constructor**: Initialize all storage variables with their initial values.
4. **Specify each external function as a transition**: For each function (including getters), write a transition that documents its preconditions and effects.
5. **Write preconditions** including : Convert Solidity's `require` statements to Act's `iff` preconditions. **Add safety checks**: Use `inRange` checks to prevent arithmetic overflow/underflow where needed.
6. **Describe storage updates**: Use `case` blocks to handle different execution paths and specify simultaneous storage updates.

We will use a running example, that was introduced in [Storage Updates](./transitions.md#storage-updates), to illustrate the steps. Imagine we have the follwing solidity code declaring two contracts, which we want to specify in Act:

```solidity
pragma solidity >=0.8.0;

contract Admins {
    address public admin1;
    address public admin2;

    constructor(address _admin1) {
        admin1 = _admin1;
        admin2 = tx.origin;
    }

    function set_admin2(address new_admin2){
        admin2 = new_admin2;
    }

}

contract Asset {
    uint256 public value;
    Admins admins;
    mapping (address => uint256) public balanceOf;

    constructor(uint256 _value) {
        value = _value;
        admins = Admins(msg.sender);
        balanceOf[address(this)] = _value;
    }

    function assetTransfer(uint256 amt, address to) public returns (bool) {
        require (msg.sender == admins.admin1 || msg.sender == admins.admin2);

        balanceOf[address(this)] = balanceOf[address(this)] - amt;
        balanceOf[to] = balanceOf[to] + amt;

        return true;
    }

    function setAdmins(address new_admin1, address new_admin2) public {
        if (msg.sender == admins.admin1 || msg.sender == admins.admin2) {
            admins = Admins(new_admin1);
            admins.admin2 = new_admin2;
        }
    }
}
```

## Step 1: Understand the Contract Structure

Begin by analyzing your Solidity contract:
- Identify the **contract name** and specify it in Act using the `contract` keyword.
- Specify the **constructor**: Look for the constructor function and note its parameters. Specify it using the `constructor` keyword and copy the constructor parameters. Leave the `iff` blank for now.
- Identify all **public state variables**. These become storage in Act and will be initialized in the constructor. In solidity they are listed at the top of the contract. List them in the constructor's `creates` block: Specify the **type** and **name** of each storage variable.
- List all **external and public functions**. These become transitions. Also the getter functions for public state variables which are automatically generated by Solidity have to be listed as transitions. Specify the transitions after the constructor using the `transition` keyword, copy the parameters from the source code. If a function has a return value, specify its type after the parameter list using `: <return_type>`.

What we would have at this point for our example:

```act
contract Admins
 
constructor(address _admin1)
iff <todo>

creates
    address admin1 := <todo>
    address admin2 := <todo>

transition set_admin2(address new_admin2)
<todo>

transition admin1() : address
<todo>

transition admin2() : address
<todo>


contract Asset

constructor(uint256 _value)
iff <todo>
creates
    uint256 value := <todo>
    Admins admins := <todo>
    mapping(address => uint256) balanceOf := <todo>

transition assetTransfer(uint256 amt, address to)
<todo>

transition setAdmins(address new_admin1, address new_admin2)
<todo>

transition value() : uint256
<todo>

transition balanceOf(address account) : uint256
<todo>
```



## Step 2: Establish Preconditions

The preconditions of a transition are specified in the `iff` block. They define the conditions that must hold true for the transition to execute successfully. It combines explicit and implicit requirements:
- **Explicit requirements**: These are conditions that are explicitly checked in the Solidity code using `require` statements. Each `require` statement translates to a line in the `iff` block.
- **Implicit requirements**: These are conditions that are not explicitly listed in the code but are necessary for the correct execution of the transition. For example, checks to prevent arithmetic overflow/underflow. <span style="color:red">Can this be anything else other than requires and inranges? </span> Arithmetic safety is addressed using the `inRange` expression. To ensure every arithmetic operation is safe, an `inRange` check has to be added for every occurring operation. 

**Guidelines:**
- Convert each `require(condition)` to a line in the `iff` block
- Multiple conditions are implicitly conjunctive (all must be true)
- Each arithmetic operation that can overflow/underflow must have a corresponding `inRange` check (Syntax `inRange(<type>, <expression>)`)
- Use logical operators (`and`, `or`, `==>` (implication), etc.) as needed. Full list of operators can be found in [Base Expressions](./store_type.md#base-expressions)
- The syntax to access fields of a mapping is `mapping_name[key]`.
- When accessing fields of other contracts, use dot notation: `contract_instance.field_name`
- Use the special variables to describe EVM environment:
    - `CALLER` instead of `msg.sender`
    - `CALLVALUE` for the amount of Ether sent
    - `THIS` for the contract's own address
    - `ORIGIN` for `tx.origin`



Our example specification would look like this after adding the preconditions. In practice one would fill on transition at a time. But for clarity we follow each step for the whole spec.:

```act
contract Admins
 
constructor(address _admin1)
iff true

creates
    address admin1 := <todo>
    address admin2 := <todo>

transition set_admin2(address new_admin2)
iff true
<todo>

transition admin1() : address
iff true
<todo>

transition admin2() : address
iff true
<todo>

contract Asset

constructor(uint256 _value)
iff true
creates
    uint256 value := <todo>
    Admins admins := <todo>
    mapping(address => uint256) balanceOf := <todo>

transition assetTransfer(uint256 amt, address to)
iff CALLER == admins.admin1 or CALLER == admins.admin2
    inRange(uint256, balanceOf[THIS] - amt)
    THIS != to ==> inRange(uint256, balanceOf[to] + amt)
<todo>

transition setAdmins(address new_admin1, address new_admin2)
iff true
<todo>

transition value() : uint256
iff true
<todo>

transition balanceOf(address account) : uint256
iff true
<todo>
```
The only interesting precondition is in the `assetTransfer` transition, which corresponds to the `require` statement in the Solidity code and two `inRange` checks. The other transitions have trivial preconditions (`iff true`).
Let us look closer into the `inRange` checks:
- In the Solidity function `assetTransfer`, the line `balanceOf[address(this)] = balanceOf[address(this)] - amt;` performs a subtraction. To ensure that this subtraction does not underflow, we add the precondition `inRange(uint256, balanceOf[THIS] - amt)`.
- If the previous line did not revert, the code proceeds to the line `balanceOf[to] = balanceOf[to] + amt;`, where it performs an addition. If `to` is different from `this`, this addition could overflow, otherwise (if `to == this`) it will just go back to its original value.
To ensure that this addition does not overflow, we add the precondition `THIS != to ==> inRange(uint256, balanceOf[to] + amt)`.


## Step 3: Define the `case` Blocks

If the constructor or a transition has multiple paths either explicit, through e.g. an `if then else` or implicit where the transition's behavior changes depending on something (e.g. whether `THIS == to` in the step above), `case` blocks have to be used to separate these paths. Each `case` block has a condition and the corresponding storage initialization or updates.

To paraphrase, within each `case` block the what happens to the storage of the contract can be defined through the same set of equations that hold after the execution of the function in this particular case. This set of equations is defined in the `creates` block for constructors and in the `updates` block for transitions.

When there is just one single path in a constructor or transition, no `case` block is needed. Proceed to step 4 in this case.

**Common Patterns for `case` Blocks**
- **If-then-else**: When there are two or more paths (e.g., an `if-else`), use `case` blocks with complementary conditions.
- **Changing Values of Mappings**: When two or more keys of a mapping are assigned new values, the end state of the mapping depend on if some of the keys were equal or not. Use `case` blocks to separate these scenarios.
-  **Function Calls**: As mentioned before: Act describes the impact a function has on a contract's storage. Hence, if within a Solidity function, another function is called, this has to be **"inlined"** in the act specification. That means the called function's logic has to be flattened into the current one's. Which most likely leads to `case` blocks. Details below in section [Inline Function Calls](./how_to.md#inline-funcion-calls). Note that this **only** applies to transitions, constructors **can** in fact be called in Act without inlining. 


**Guidelines:**
- Conditions of the `case` blocks must be mutually exclusive and exhaustive
- Multiple conditions are implicitly conjunctive (all must be true)
- Use logical operators (`and`, `or`, `==>` (implication), `==`, `!=`, etc.) as needed. Full list of operators can be found in [Base Expressions](./store_type.md#base-expressions)
- The syntax to access fields of a mapping is `mapping_name[key]`.
- When accessing fields of other contracts, use dot notation: `contract_instance.field_name`
- Use the special variables to describe EVM environment:
    - `CALLER` instead of `msg.sender`
    - `CALLVALUE` for the amount of Ether sent
    - `THIS` for the contract's own address
    - `ORIGIN` for `tx.origin`


After considering this step the specification of the running example only the transiitons `assetTransfer` and `setAdmins` changed, since all other transitions and constructors hve only one path. The transitions with `case` blocks look like this:

```act

transition assetTransfer(uint256 amt, address to)
iff CALLER == admins.admin1 or CALLER == admins.admin2
    inRange(uint256, balanceOf[THIS] - amt)
    THIS != to ==> inRange(uint256, balanceOf[to] + amt)

case THIS != to
<todo>

case THIS == to
<todo>



transition setAdmins(address new_admin1, address new_admin2)
iff true

case  CALLER == admins.admin1 or CALLER == admins.admin2
<todo>

case !(CALLER == admins.admin1 or CALLER == admins.admin2)
<todo>

```

In the `assetTransfer` function, the values of `THIS` and `to` of the `balanceOf` mapping are changed. Which equations are true afterwards depend on whether `THIS` and `to` are identical.

In `setAdmins`, there is a simple `if` that splits two paths, hence also in the Act spec we have two paths accordingly.


## Step 4: Initialize Storage in the Constructor

The constructor initializes all storage variables. Every storage variable must be initialized in every execution path (i.e. in every `case` block).
This has been prepared already in step 1.
What is left to do is copy the behavior of Solidity's constructors while considering the following guidelines.

**Guidelines:**
- Use `:=` to assign the initial value
- For mappings, use `[]` for empty mappings or `[<key> => <value>, ...]` to initialize specific entries. Entries that are not specified are set to the type's default value.
- In every `case` block  **all** storage variables must be initialized.
- As in Solidity, **constructors** of other contracts can be called and assigned.
- Use the special variables to describe EVM environment:
    - `CALLER` instead of `msg.sender`
    - `CALLVALUE` for the amount of Ether sent
    - `THIS` for the contract's own address
    - `ORIGIN` for `tx.origin`


In our example the constructors of the two contracts have this final form:

```act
contract Admins

constructor(address _admin1)
iff true

creates
   address admin1 := _admin1
   address admin2 := ORIGIN

...

contract Asset

constructor(uint256 _value)
iff true
creates
    uint256 value := _value
    Admins admins := Admins(CALLER)
    mapping(address => uint256) balanceOf := [THIS => _value]
```



## Step 5: Specify Storage Updates and Return Values

What is left to do now, is to explicitly list all storage slots that were updated in each transition and each `case` block. As well as specify the return value if there is a return type in the transition signature. 
We start with the **storage updates**. 

### Storage Updates

If for a transition and `case` no storage slot was changed, then the `updates` block is skipped. A common example for such a case are getter functions.

For all other transitions and `case` blocks, there has to be an `updates` block. The updated storage slots are listed after the keyword; one update per line.
The syntax to update a storage slot is `<storage_slot> := <new_value>`. 

Be aware that **Storage updates are simultaneous!** That means that all right-hand sides of the updates are evaluated in the pre-state (before the function call). This avoids order-dependence and makes transitions suitable for formal reasoning. As mentioned before,
these update statements serve as a set of equations that hold after execution. They are not to be seen as assignments. 

Consequently, every storage slot can be mentioned within the same `case` block at most once (except for the *special case* explained below).  Further, mappings are updated as a whole in one single statement, not one update per mapping entry. 

There is one  **special case** about updates. If a contract uses an instance of another contract in its storage, as the `Asset` contract contains an instance of the `Admins` contract in our example, which is called `admins`; and if now, within one transition and `case` block, the entire `admins` contract instance is updated and also one of `admins`'  fields is updated, the more general update has to be stated before the more specific one. For details see [Storage Updates Ordering](./transitions.md#storage-updates-are-partially-ordered).

**Guidelines:**
- The syntax for updating a mapping is : `mapping_name := mapping_name[key1 => new_value1, key2 => new_value2]`
- All right-hand sides use **pre-state values** (e.g., `balanceOf[CALLER] - value` subtracts from the old balance)
- Right-hand-sides of updates **cannot** be transition calls. Transition calls have to be inlined as described in step 3
-  Consider the special case: state more general updates before more specific ones

### Return values

For each transition where the signature specifies a return type,  `returns <expr>` has to be present for each `case` block. The returned expression can reference storage and parameters but always refers to the pre-state.

**Guidelines:**
- Use `returns expression` to specify the return value
- The return value can reference storage and parameters but always refers to the pre-state


The final act specification of the Solidity code at the beginning of this page is the following:

```act
contract Admins

constructor(address _admin1)
iff true

creates
   address admin1 := _admin1
   address admin2 := ORIGIN

transition set_admin2(address new_admin2)
iff true
updates
   admin2 := new_admin2

transition admin1() : address
iff true
returns admin1

transition admin2() : address
iff true
returns admin2





contract Asset

constructor(uint256 _value)
iff true
creates
    uint256 value := _value
    Admins admins := Admins(CALLER)
    mapping(address => uint256) balanceOf := [THIS => _value]


transition assetTransfer(uint256 amt, address to) 

iff CALLER == admins.admin1 or CALLER == admins.admin2
    inRange(uint256, balanceOf[THIS] - amt)
    THIS != to ==> inRange(uint256, balanceOf[to] + amt)

case THIS != to

updates
   balanceOf := balanceOf[
                  THIS => balanceOf[THIS] - amt,
                  to   => balanceOf[to]   + amt ]

case THIS == to



transition setAdmins(address new_admin1, address new_admin2)

iff true

case CALLER == admins.admin1 or CALLER == admins.admin2

updates
   admins := Admins(new_admin1)
   admins.admin2 := new_admin2

case !(CALLER == admins.admin1 or CALLER == admins.admin2)


transition value() : uint256
iff true
returns value

transition balanceOf(address idx) : uint256
iff true
returns balanceOf[idx]

```

Note that in `setAdmins`, we are in this special case where a contract instance and one of its fields are updated in the same `updates` block. So the general update of `admins` comes first, and the update of `admins.admin2` comes second.


## Summary

1. **Be explicit about control flow**: Use `case` blocks liberally to avoid ambiguity
2. **Check arithmetic safety**: Use `inRange` for every operation that could overflow/underflow and add it to `iff`
3. **Remember updates are simultaneous**: All right-hand sides refer to the pre-state
4. **Initialize all storage variables**: Every storage variable must appear in every `creates` block (in the constructor).
5. **Make conditions exhaustive**: Each set of cases must cover all possibilities
6. **Convert all requirements**: Every Solidity `require` becomes an `iff` condition or implicit in a case
7. **Specify getters**: Even view functions need to be specified as transitions
8. **Use meaningful variable names**: Match your Solidity code for clarity
9. **Inline transition calls**: A storage update cannot be a transition call, it's logic and affects have to be embedded as case blocks.
10. **Be aware of ordered updates**: When storage updates a contract instance and a field of that contract instance, the contract instance itslef has to be listed first in the `updates` block
10. **Reference the documentation**: Consult the [Storage and Typing](./store_type.md), [Constructors](./constructors.md), and [Transitions](./behaviors.md) sections for detailed explanations






## Inline Function Calls

 <span style="color:red">CONTINUE HERE </span>
If your contract creates new contracts or calls other contracts, you can represent this in Act.

**Example: Creating a New Token**

```act
creates
  Token token := new Token(100)
```

**Guidelines:**
- Use `new ContractName(arguments)` to create a new contract
- The result is assigned to a storage variable
- This is primarily used in constructors and complex transitions