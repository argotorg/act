diff --git a/tests/coq/amm/amm.act b/tests/coq/amm/amm.act
index 48bcae3b..14a10946 100644
--- a/tests/coq/amm/amm.act
+++ b/tests/coq/amm/amm.act
@@ -1,112 +1,108 @@
-constructor of Token
-interface constructor(uint256 _totalSupply)
+contract Token
 
-iff CALLVALUE == 0
+constructor(uint256 _totalSupply)
 
 creates
 
   uint256 totalSupply := _totalSupply
-  mapping(address => uint) balanceOf :=  [CALLER := _totalSupply]
+  mapping(address => uint) balanceOf :=  [CALLER => _totalSupply]
   mapping(address=>mapping(address=>uint)) allowance := []
 
 
-behaviour transfer of Token
-interface transfer(uint256 value, address to)
+transition transfer(uint256 value, address to) : uint256
 
 iff
 
-  CALLVALUE == 0
   inRange(uint256, balanceOf[CALLER] - value)
-  CALLER =/= to => inRange(uint256, balanceOf[to] + value)
+  CALLER != to ==> inRange(uint256, balanceOf[to] + value)
 
-case CALLER =/= to:
+case CALLER != to:
 
-  storage
+  updates
 
-     balanceOf[CALLER] => balanceOf[CALLER] - value
-     balanceOf[to]     => balanceOf[to] + value
+     balanceOf := balanceOf[ CALLER => balanceOf[CALLER] - value
+                           , to     => balanceOf[to] + value ]
 
   returns 1
 
 case CALLER == to:
 
+  updates
   returns 1
 
 
-behaviour transferFrom of Token
-interface transferFrom(address src, address dst, uint amount)
+transition transferFrom(address src, address dst, uint amount) : uint256
 
 iff
 
   amount <= balanceOf[src]
-  src    =/= dst => inRange(uint256, balanceOf[dst] + amount)
-  CALLER =/= src => inRange(uint256, allowance[src][CALLER] - amount)
-  CALLVALUE == 0
+  src    != dst ==> inRange(uint256, balanceOf[dst] + amount)
+  CALLER != src ==> inRange(uint256, allowance[src][CALLER] - amount)
 
-case src =/= dst and CALLER == src:
+case src != dst and CALLER == src:
 
-  storage
+  updates
 
-     balanceOf[src] => balanceOf[src] - amount
-     balanceOf[dst] => balanceOf[dst] + amount
+     balanceOf := balanceOf[ src => balanceOf[src] - amount
+                           , dst => balanceOf[dst] + amount ]
 
   returns 1
 
-case src =/= dst and CALLER =/= src and allowance[src][CALLER] == 2^256 - 1:
+case src != dst and CALLER != src and allowance[src][CALLER] == 2^256 - 1:
 
-  storage
+  updates
 
-     balanceOf[src] => balanceOf[src] - amount
-     balanceOf[dst] => balanceOf[dst] + amount
+     balanceOf := balanceOf[ src => balanceOf[src] - amount
+                           , dst => balanceOf[dst] + amount ]
 
   returns 1
 
-case src =/= dst and CALLER =/= src and allowance[src][CALLER] < 2^256 - 1:
+case src != dst and CALLER != src and allowance[src][CALLER] < 2^256 - 1:
 
-  storage
+  updates
 
-    allowance[src][CALLER] => allowance[src][CALLER] - amount
-    balanceOf[src]         => balanceOf[src] - amount
-    balanceOf[dst]         => balanceOf[dst] + amount
+    allowance := allowance[ src => allowance[src][CALLER => allowance[src][CALLER] - amount] ]
+    balanceOf := balanceOf[ src => balanceOf[src] - amount
+                          , dst => balanceOf[dst] + amount ]
 
   returns 1
 
-case src == dst and CALLER =/= src and allowance[src][CALLER] < 2^256 - 1:
+case src == dst and CALLER != src and allowance[src][CALLER] < 2^256 - 1:
 
-  storage
+  updates
 
-    allowance[src][CALLER] => allowance[src][CALLER] - amount
+    allowance := allowance[ src => allowance[src][CALLER => allowance[src][CALLER] - amount] ]
 
   returns 1
 
 case src == dst and (CALLER == src or allowance[src][CALLER] == 2^256 - 1):
 
+  updates
   returns 1
 
 
-behaviour approve of Token
-interface approve(address spender, uint amount)
+transition approve(address spender, uint amount) : uint256
 
 iff
 
   inRange(uint256, amount)
   CALLVALUE == 0
 
-case CALLER =/= spender:
+case CALLER != spender:
 
-  storage
+  updates
 
-    allowance[CALLER][spender] => amount
+    allowance := allowance[ CALLER => allowance[CALLER][spender => amount] ]
 
   returns 1
 
 case CALLER == spender:
 
+  updates
   returns 1
 
 
-behaviour burn of Token
-interface burn(uint256 amount)
+transition burn(uint256 amount) : uint256
 
 iff
 
@@ -114,210 +110,95 @@ iff
   inRange(uint256, totalSupply - amount)
   inRange(uint256, balanceOf[CALLER] - amount)
 
-storage
+updates
 
-  totalSupply => totalSupply - amount
-  balanceOf[CALLER] => balanceOf[CALLER] - amount
+  totalSupply := totalSupply - amount
+  balanceOf := balanceOf[ CALLER => balanceOf[CALLER] - amount ]
 
 returns 1
 
 
-behaviour burnFrom of Token
-interface burnFrom(address src, uint256 amount)
+transition burnFrom(address src, uint256 amount) : uint256
 
 iff
   amount <= totalSupply
   amount <= balanceOf[src]
-  CALLER =/= src => amount <= allowance[src][CALLER]
+  CALLER != src ==> amount <= allowance[src][CALLER]
   CALLVALUE == 0
 
-case CALLER =/= src and allowance[src][CALLER] == 2^256 - 1:
+case CALLER != src and allowance[src][CALLER] == 2^256 - 1:
 
-  storage
+  updates
 
-    totalSupply => totalSupply - amount
-    balanceOf[src] => balanceOf[src] - amount
+    totalSupply := totalSupply - amount
+    balanceOf := balanceOf[ src => balanceOf[src] - amount ]
 
   returns 1
 
-case CALLER =/= src and allowance[src][CALLER] < 2^256 - 1:
+case CALLER != src and allowance[src][CALLER] < 2^256 - 1:
 
-  storage
+  updates
 
-    totalSupply => totalSupply - amount
-    allowance[src][CALLER] => allowance[src][CALLER] - amount
-    balanceOf[src]         => balanceOf[src] - amount
+    totalSupply := totalSupply - amount
+    allowance := allowance[ src => allowance[src][CALLER => allowance[src][CALLER] - amount] ]
+    balanceOf := balanceOf[ src => balanceOf[src] - amount ]
 
   returns 1
 
 case CALLER == src:
 
-  storage
+  updates
 
-    totalSupply => totalSupply - amount
-    balanceOf[src] => balanceOf[src] - amount
+    totalSupply := totalSupply - amount
+    balanceOf := balanceOf[ src => balanceOf[src] - amount ]
 
   returns 1
 
 ensures
 
-  pre(balanceOf[src]) - post(balanceOf[src]) == pre(totalSupply) - post(totalSupply)
-
-
-behaviour mint of Token
-interface mint(address dst, uint256 amount)
+  pre(balanceOf)[src] - post(balanceOf)[src] == pre(totalSupply) - post(totalSupply)
 
-iff in range uint256
 
-  totalSupply + amount
-  balanceOf[dst] + amount
+transition mint(address dst, uint256 amount) : uint256
 
 iff
-
+  inRange(uint256, totalSupply + amount)
+  inRange(uint256, balanceOf[dst] + amount)
   CALLVALUE == 0
 
-storage
+updates
 
-  totalSupply => totalSupply + amount
-  balanceOf[dst] => balanceOf[dst] + amount
+  totalSupply := totalSupply + amount
+  balanceOf := balanceOf[ dst => balanceOf[dst] + amount ]
 
 returns 1
 
 
 // View functions:
 
-behaviour totalSupply of Token
-interface totalSupply()
+transition totalSupply() : uint256
 
 iff 
 
   CALLVALUE == 0
 
-returns pre(totalSupply)
+updates
+returns totalSupply
 
-behaviour balanceOf of Token
-interface balanceOf(address idx)
+transition balanceOf(address idx) : uint256
 
 iff 
 
   CALLVALUE == 0
 
-returns pre(balanceOf[idx])
+updates
+returns balanceOf[idx]
 
-behaviour allowance of Token
-interface allowance(address idx1, address idx2)
+transition allowance(address idx1, address idx2) : uint256
 
 iff 
 
   CALLVALUE == 0
 
-returns pre(allowance[idx1][idx2])
-
-constructor of Amm
-interface constructor()
-
-iff
-
-    CALLVALUE == 0
-
-creates
-
-    Token token0 := create Token(200) 
-    Token token1 := create Token(200)
-
-behaviour swap0 of Amm
-interface swap0(uint256 amt)
-
-iff
-    CALLVALUE == 0
-    inRange(uint256,token0.balanceOf[CALLER] - amt)
-    CALLER =/= THIS => inRange(uint256,token0.balanceOf[THIS] + amt)
-    CALLER =/= THIS => inRange(uint256,token0.allowance[CALLER][THIS] - amt)
-
-    inRange(uint256,token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))
-    CALLER =/= THIS => inRange(uint256,token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))
-
-    token0.balanceOf[THIS] + amt =/= 0
-
-case CALLER =/= THIS and token0.allowance[CALLER][THIS] == 2^256 - 1:
-
-storage
-
-    token0.balanceOf[CALLER] => token0.balanceOf[CALLER] - amt
-    token0.balanceOf[THIS]   => token0.balanceOf[THIS] + amt
-
-    token1.balanceOf[THIS]   => token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
-    token1.balanceOf[CALLER] => token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
-
-returns 1
-
-case CALLER =/= THIS and token0.allowance[CALLER][THIS] < 2^256 - 1:
-
-storage
-
-    token0.balanceOf[CALLER] => token0.balanceOf[CALLER] - amt
-    token0.balanceOf[THIS]   => token0.balanceOf[THIS] + amt
-    token0.allowance[CALLER][THIS] => token0.allowance[CALLER][THIS] - amt
-
-    token1.balanceOf[THIS]   => token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
-    token1.balanceOf[CALLER] => token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
-
-returns 1
-
-case CALLER == THIS:
-
-returns 1
-
-ensures
-
-    pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) <= post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS])
-    post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS]) <= pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) + pre(token0.balanceOf[THIS]) + amt
-
-
-behaviour swap1 of Amm
-interface swap1(uint256 amt)
-
-iff
-    CALLVALUE == 0
-    inRange(uint256,token1.balanceOf[CALLER] - amt)
-    CALLER =/= THIS => inRange(uint256,token1.balanceOf[THIS] + amt)
-    CALLER =/= THIS => inRange(uint256,token1.allowance[CALLER][THIS] - amt)
-
-    inRange(uint256,token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))
-    CALLER =/= THIS => inRange(uint256,token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))
-
-    token1.balanceOf[THIS] + amt =/= 0
-
-case CALLER =/= THIS and token1.allowance[CALLER][THIS] == 2^256 - 1:
-
-storage
-
-    token1.balanceOf[CALLER] => token1.balanceOf[CALLER] - amt
-    token1.balanceOf[THIS]   => token1.balanceOf[THIS] + amt
-
-    token0.balanceOf[THIS]   => token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
-    token0.balanceOf[CALLER] => token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
-
-returns 1
-
-case CALLER =/= THIS and token1.allowance[CALLER][THIS] < 2^256 - 1:
-
-storage
-
-    token1.balanceOf[CALLER] => token1.balanceOf[CALLER] - amt
-    token1.balanceOf[THIS]   => token1.balanceOf[THIS] + amt
-    token1.allowance[CALLER][THIS] => token1.allowance[CALLER][THIS] - amt
-
-    token0.balanceOf[THIS]   => token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
-    token0.balanceOf[CALLER] => token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
-
-returns 1
-
-case CALLER == THIS:
-
-returns 1
-
-ensures
-
-    pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) <= post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS])
-    post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS]) <= pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) + pre(token1.balanceOf[THIS]) + amt
+updates
+returns allowance[idx1][idx2]
