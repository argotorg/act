contract Token

constructor(uint256 _totalSupply)

creates

  uint256 totalSupply := _totalSupply
  mapping(address => uint) balanceOf :=  [CALLER => _totalSupply]
  mapping(address=>mapping(address=>uint)) allowance := []


transition transfer(uint256 value, address to) : uint256

iff

  inRange(uint256, balanceOf[CALLER] - value)
  CALLER != to ==> inRange(uint256, balanceOf[to] + value)

case CALLER != to:

  updates

     balanceOf := balanceOf[ CALLER => balanceOf[CALLER] - value
                           , to     => balanceOf[to] + value ]

  returns 1

case CALLER == to:

  updates
  returns 1


transition transferFrom(address src, address dst, uint amount) : uint256

iff

  amount <= balanceOf[src]
  src    != dst ==> inRange(uint256, balanceOf[dst] + amount)
  CALLER != src ==> inRange(uint256, allowance[src][CALLER] - amount)

case src != dst and CALLER == src:

  updates

     balanceOf := balanceOf[ src => balanceOf[src] - amount
                           , dst => balanceOf[dst] + amount ]

  returns 1

case src != dst and CALLER != src and allowance[src][CALLER] == 2^256 - 1:

  updates

     balanceOf := balanceOf[ src => balanceOf[src] - amount
                           , dst => balanceOf[dst] + amount ]

  returns 1

case src != dst and CALLER != src and allowance[src][CALLER] < 2^256 - 1:

  updates

    allowance := allowance[ src => allowance[src][CALLER => allowance[src][CALLER] - amount] ]
    balanceOf := balanceOf[ src => balanceOf[src] - amount
                          , dst => balanceOf[dst] + amount ]

  returns 1

case src == dst and CALLER != src and allowance[src][CALLER] < 2^256 - 1:

  updates

    allowance := allowance[ src => allowance[src][CALLER => allowance[src][CALLER] - amount] ]

  returns 1

case src == dst and (CALLER == src or allowance[src][CALLER] == 2^256 - 1):

  updates
  returns 1


transition approve(address spender, uint amount) : uint256

iff

  inRange(uint256, amount)
  CALLVALUE == 0

case CALLER != spender:

  updates

    allowance := allowance[ CALLER => allowance[CALLER][spender => amount] ]

  returns 1

case CALLER == spender:

  updates
  returns 1


transition burn(uint256 amount) : uint256

iff

  CALLVALUE == 0
  inRange(uint256, totalSupply - amount)
  inRange(uint256, balanceOf[CALLER] - amount)

updates

  totalSupply := totalSupply - amount
  balanceOf := balanceOf[ CALLER => balanceOf[CALLER] - amount ]

returns 1


transition burnFrom(address src, uint256 amount) : uint256

iff
  amount <= totalSupply
  amount <= balanceOf[src]
  CALLER != src ==> amount <= allowance[src][CALLER]
  CALLVALUE == 0

case CALLER != src and allowance[src][CALLER] == 2^256 - 1:

  updates

    totalSupply := totalSupply - amount
    balanceOf := balanceOf[ src => balanceOf[src] - amount ]

  returns 1

case CALLER != src and allowance[src][CALLER] < 2^256 - 1:

  updates

    totalSupply := totalSupply - amount
    allowance := allowance[ src => allowance[src][CALLER => allowance[src][CALLER] - amount] ]
    balanceOf := balanceOf[ src => balanceOf[src] - amount ]

  returns 1

case CALLER == src:

  updates

    totalSupply := totalSupply - amount
    balanceOf := balanceOf[ src => balanceOf[src] - amount ]

  returns 1

ensures

  pre(balanceOf)[src] - post(balanceOf)[src] == pre(totalSupply) - post(totalSupply)


transition mint(address dst, uint256 amount) : uint256

iff
  inRange(uint256, totalSupply + amount)
  inRange(uint256, balanceOf[dst] + amount)
  CALLVALUE == 0

updates

  totalSupply := totalSupply + amount
  balanceOf := balanceOf[ dst => balanceOf[dst] + amount ]

returns 1


// View functions:

transition totalSupply() : uint256

iff 

  CALLVALUE == 0

updates
returns totalSupply

transition balanceOf(address idx) : uint256

iff 

  CALLVALUE == 0

updates
returns balanceOf[idx]

transition allowance(address idx1, address idx2) : uint256

iff 

  CALLVALUE == 0

updates
returns allowance[idx1][idx2]


contract Amm

constructor(address<Token> t0, address<Token> t1)

iff

    CALLVALUE == 0
    t0 != t1

creates

    Token token0 := t0 
    Token token1 := t1

transition swap0(uint256 amt) : uint256

iff
    CALLVALUE == 0
    inRange(uint256,token0.balanceOf[CALLER] - amt)
    CALLER != THIS ==> inRange(uint256,token0.balanceOf[THIS] + amt)
    CALLER != THIS ==> inRange(uint256,token0.allowance[CALLER][THIS] - amt)

    inRange(uint256,token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))
    CALLER != THIS ==> inRange(uint256,token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))

    token0.balanceOf[THIS] + amt != 0

case CALLER != THIS and token0.allowance[CALLER][THIS] == 2^256 - 1:

updates

    token0.balanceOf := token0.balanceOf[ CALLER => token0.balanceOf[CALLER] - amt
                                        , THIS   => token0.balanceOf[THIS] + amt ]

    token1.balanceOf := token1.balanceOf[ THIS   => token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
                                        , CALLER => token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)) ]

returns 1

case CALLER != THIS and token0.allowance[CALLER][THIS] < 2^256 - 1:

updates

    token0.balanceOf := token0.balanceOf[ CALLER => token0.balanceOf[CALLER] - amt
                                        , THIS   => token0.balanceOf[THIS] + amt ]
    token0.allowance := token0.allowance[ CALLER => token0.allowance[CALLER][THIS => token0.allowance[CALLER][THIS] - amt] ]

    token1.balanceOf := token1.balanceOf[ THIS   => token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
                                        , CALLER => token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)) ]

returns 1

case CALLER == THIS:

updates
returns 1

ensures

    pre(token0).balanceOf[THIS] * pre(token1).balanceOf[THIS] <= post(token0).balanceOf[THIS] * post(token1).balanceOf[THIS]
    post(token0).balanceOf[THIS] * post(token1).balanceOf[THIS] <= pre(token0).balanceOf[THIS] * pre(token1).balanceOf[THIS] + pre(token0).balanceOf[THIS] + amt


transition swap1(uint256 amt) : uint256

iff
    CALLVALUE == 0
    inRange(uint256,token1.balanceOf[CALLER] - amt)
    CALLER != THIS ==> inRange(uint256,token1.balanceOf[THIS] + amt)
    CALLER != THIS ==> inRange(uint256,token1.allowance[CALLER][THIS] - amt)

    inRange(uint256,token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))
    CALLER != THIS ==> inRange(uint256,token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))

    token1.balanceOf[THIS] + amt != 0

case CALLER != THIS and token1.allowance[CALLER][THIS] == 2^256 - 1:

updates

    token1.balanceOf := token1.balanceOf[ CALLER => token1.balanceOf[CALLER] - amt
                                        , THIS   => token1.balanceOf[THIS] + amt ]

    token0.balanceOf := token0.balanceOf[ THIS   => token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
                                        , CALLER => token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)) ]

returns 1

case CALLER != THIS and token1.allowance[CALLER][THIS] < 2^256 - 1:

updates

    token1.balanceOf := token1.balanceOf[ CALLER => token1.balanceOf[CALLER] - amt
                                        , THIS   => token1.balanceOf[THIS] + amt ]
    token1.allowance := token1.allowance[ CALLER => token1.allowance[CALLER][THIS => token1.allowance[CALLER][THIS] - amt] ]

    token0.balanceOf := token0.balanceOf[ THIS   => token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
                                        , CALLER => token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)) ]

returns 1

case CALLER == THIS:

updates
returns 1

ensures

    pre(token0).balanceOf[THIS] * pre(token1).balanceOf[THIS] <= post(token0).balanceOf[THIS] * post(token1).balanceOf[THIS]
    post(token0).balanceOf[THIS] * post(token1).balanceOf[THIS] <= pre(token0).balanceOf[THIS] * pre(token1).balanceOf[THIS] + pre(token1).balanceOf[THIS] + amt
