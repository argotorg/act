(* --- GENERATED BY ACT --- *)

Require Import Stdlib.ZArith.ZArith.
Require Import ActLib.ActLib.
Require Stdlib.Strings.String.

Module Str := Stdlib.Strings.String.
Open Scope Z_scope.

Module A.

Record State : Set := state
{ addr : address
; x : Z
}.

Inductive addressIn : Z -> State -> Prop :=
| address_addr : forall (STATE : State),
     addressIn (addr STATE) STATE

.

Definition noAliasing (STATE : State) :=
     True
.

Definition envStateConstraint (ENV : Env) (STATE : State) :=
  forall (p : address), addressIn p STATE -> NextAddr ENV > p
.

Definition A (ENV : Env) :=
(NextEnv ENV, state (NextAddr ENV) 0).

Definition initPreconds (ENV : Env) :=
     True
.

Definition A_post0 :=
  forall (ENV : Env) (STATE' : State),
     initPreconds ENV
  -> STATE' = snd (A ENV)
  -> ((0 <= (A.x STATE')) /\ ((A.x STATE') <= (UINT_MAX 256)))
.


Inductive A_step : State -> State -> Prop :=
.

Inductive extStep : Env -> State -> State -> Prop :=
| extStep_A : forall (ENV : Env) (STATE : State) (STATE' : State),
     A_step STATE STATE'
  -> extStep ENV STATE STATE'

.

Definition step (STATE : State) (STATE' : State) :=
exists (ENV : Env), extStep ENV STATE STATE'.

Inductive init : State ->  Prop :=
| InitState : forall (ENV : Env),
     initPreconds ENV
  -> init (snd (A ENV))

.

Definition multistep (STATE STATE' : State) :=
multistep step STATE STATE'.

Definition reachable (STATE : State) :=
exists STATE', init STATE' /\ multistep STATE' STATE.

Definition reachableFromInit (ENV : Env) (STATE : State) :=
initPreconds ENV /\ multistep (snd (A ENV)) STATE.

Definition invariantInit (IP : Env -> State -> Prop) :=
  forall (ENV : Env),
     initPreconds ENV
  -> IP ENV (snd (A ENV))
.

Definition invariantStep (IP : Env -> State -> Prop) :=
  forall (ENV : Env) (STATE : State) (STATE' : State),
     initPreconds ENV
  -> step STATE STATE'
  -> IP ENV STATE
  -> IP ENV STATE'
.

Lemma invariantReachable :
  forall (ENV : Env) (STATE : State) (IP : Env -> State -> Prop) (HIPinvInit : invariantInit IP) (HIPinvStep : invariantStep IP),
     reachableFromInit ENV (STATE : State)
  -> IP ENV STATE
.
Proof.
  intros ENV STATE IP HIPinvInit HIPinvStep Hreach.
  unfold reachableFromInit in Hreach.
  destruct Hreach as [Hinit Hmulti].
  apply step_multi_step with (P := fun s s' => IP ENV s -> IP ENV s' ) in Hmulti.
  - apply Hmulti.
    apply HIPinvInit; assumption.
  - intros s s' Hstep.
    apply HIPinvStep with (STATE := s) (STATE' := s') ; assumption.
  - unfold Relation_Definitions.reflexive.
    intros.
    assumption.
  - unfold Relation_Definitions.transitive.
    intros s1 s2 s3 Ht1 Ht2 Ht3.
    apply Ht2, Ht1.
    assumption.

Qed.


End A.


Module B.

Record State : Set := state
{ addr : address
; bu1 : address
; bu2 : address
; pba : A.State
; y : Z
}.

Inductive addressIn : Z -> State -> Prop :=
| address_addr : forall (STATE : State),
     addressIn (addr STATE) STATE

| address_bu1 : forall (STATE : State),
     addressIn (bu1 STATE) STATE

| address_bu2 : forall (STATE : State),
     addressIn (bu2 STATE) STATE

| address_pba : forall (p : address) (STATE : State),
     A.addressIn p (pba STATE)
  -> addressIn p STATE

.

Definition noAliasing (STATE : State) :=
     (bu1 STATE) <> (bu2 STATE)
  /\ (addr STATE) <> (bu1 STATE)
  /\ (addr STATE) <> (bu2 STATE)
  /\ (forall (p : address), A.addressIn p (pba STATE) -> (addr STATE) <> p)
  /\ (forall (p : address), A.addressIn p (pba STATE) -> (bu1 STATE) <> p)
  /\ (forall (p : address), A.addressIn p (pba STATE) -> (bu2 STATE) <> p)
  /\ A.noAliasing (pba STATE)
.

Definition envStateConstraint (ENV : Env) (STATE : State) :=
  forall (p : address), addressIn p STATE -> NextAddr ENV > p
.

Definition B (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) :=
(NextEnv ENV, state (NextAddr ENV) p2 p4 pa1 0).

Definition initPreconds (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) :=
     ((A.addr pa1) <> p2)
  /\ ((A.addr pa1) <> (A.addr pa3))
  /\ ((A.addr pa1) <> p4)
  /\ (p2 <> (A.addr pa3))
  /\ (p2 <> p4)
  /\ ((A.addr pa3) <> p4)
  /\ ((0 <= (A.addr pa1)) /\ ((A.addr pa1) <= (UINT_MAX 160)))
  /\ ((0 <= p2) /\ (p2 <= (UINT_MAX 160)))
  /\ ((0 <= (A.addr pa3)) /\ ((A.addr pa3) <= (UINT_MAX 160)))
  /\ ((0 <= p4) /\ (p4 <= (UINT_MAX 160)))
  /\ A.envStateConstraint ENV pa1
  /\ NextAddr ENV > p2
  /\ A.envStateConstraint ENV pa3
  /\ NextAddr ENV > p4
.

Definition B_post0 :=
  forall (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) (STATE' : State),
     initPreconds ENV pa1 p2 pa3 p4
  -> STATE' = snd (B ENV pa1 p2 pa3 p4)
  -> ((0 <= (B.y STATE')) /\ ((B.y STATE') <= (UINT_MAX 256)))
.


Definition B_post1 :=
  forall (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) (STATE' : State),
     initPreconds ENV pa1 p2 pa3 p4
  -> STATE' = snd (B ENV pa1 p2 pa3 p4)
  -> ((0 <= (B.bu1 STATE')) /\ ((B.bu1 STATE') <= (UINT_MAX 160)))
.


Definition B_post2 :=
  forall (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) (STATE' : State),
     initPreconds ENV pa1 p2 pa3 p4
  -> STATE' = snd (B ENV pa1 p2 pa3 p4)
  -> ((0 <= (B.bu2 STATE')) /\ ((B.bu2 STATE') <= (UINT_MAX 160)))
.


Inductive B_step : State -> State -> Prop :=
.

Inductive extStep : Env -> State -> State -> Prop :=
| extStep_B : forall (ENV : Env) (STATE : State) (STATE' : State),
     B_step STATE STATE'
  -> extStep ENV STATE STATE'

| extStep_pba : forall (ENV : Env) (STATE : State) (STATE' : State),
     envStateConstraint ENV STATE
  -> A.extStep ENV (pba STATE) (pba STATE')
  -> (bu1 STATE) = (bu1 STATE')
  -> (bu2 STATE) = (bu2 STATE')
  -> (y STATE) = (y STATE')
  -> extStep ENV STATE STATE'

.

Definition step (STATE : State) (STATE' : State) :=
exists (ENV : Env), extStep ENV STATE STATE'.

Inductive init : State ->  Prop :=
| InitState : forall (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address),
     initPreconds ENV pa1 p2 pa3 p4
  -> init (snd (B ENV pa1 p2 pa3 p4))

.

Definition multistep (STATE STATE' : State) :=
multistep step STATE STATE'.

Definition reachable (STATE : State) :=
exists STATE', init STATE' /\ multistep STATE' STATE.

Definition reachableFromInit (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) (STATE : State) :=
initPreconds ENV pa1 p2 pa3 p4 /\ multistep (snd (B ENV pa1 p2 pa3 p4)) STATE.

Definition invariantInit (IP : Env -> A.State -> address -> A.State -> address -> State -> Prop) :=
  forall (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address),
     initPreconds ENV pa1 p2 pa3 p4
  -> IP ENV pa1 p2 pa3 p4 (snd (B ENV pa1 p2 pa3 p4))
.

Definition invariantStep (IP : Env -> A.State -> address -> A.State -> address -> State -> Prop) :=
  forall (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) (STATE : State) (STATE' : State),
     initPreconds ENV pa1 p2 pa3 p4
  -> step STATE STATE'
  -> IP ENV pa1 p2 pa3 p4 STATE
  -> IP ENV pa1 p2 pa3 p4 STATE'
.

Lemma invariantReachable :
  forall (ENV : Env) (pa1 : A.State) (p2 : address) (pa3 : A.State) (p4 : address) (STATE : State) (IP : Env -> A.State -> address -> A.State -> address -> State -> Prop) (HIPinvInit : invariantInit IP) (HIPinvStep : invariantStep IP),
     reachableFromInit ENV pa1 p2 pa3 p4 (STATE : State)
  -> IP ENV pa1 p2 pa3 p4 STATE
.
Proof.
  intros ENV pa1 p2 pa3 p4 STATE IP HIPinvInit HIPinvStep Hreach.
  unfold reachableFromInit in Hreach.
  destruct Hreach as [Hinit Hmulti].
  apply step_multi_step with (P := fun s s' => IP ENV pa1 p2 pa3 p4 s -> IP ENV pa1 p2 pa3 p4 s' ) in Hmulti.
  - apply Hmulti.
    apply HIPinvInit; assumption.
  - intros s s' Hstep.
    apply HIPinvStep with (STATE := s) (STATE' := s') ; assumption.
  - unfold Relation_Definitions.reflexive.
    intros.
    assumption.
  - unfold Relation_Definitions.transitive.
    intros s1 s2 s3 Ht1 Ht2 Ht3.
    apply Ht2, Ht1.
    assumption.

Qed.


End B.


Module C.

Record State : Set := state
{ addr : address
; a1 : A.State
; b1 : B.State
; cu1 : address
; cu2 : address
}.

Inductive addressIn : Z -> State -> Prop :=
| address_addr : forall (STATE : State),
     addressIn (addr STATE) STATE

| address_a1 : forall (p : address) (STATE : State),
     A.addressIn p (a1 STATE)
  -> addressIn p STATE

| address_b1 : forall (p : address) (STATE : State),
     B.addressIn p (b1 STATE)
  -> addressIn p STATE

| address_cu1 : forall (STATE : State),
     addressIn (cu1 STATE) STATE

| address_cu2 : forall (STATE : State),
     addressIn (cu2 STATE) STATE

.

Definition noAliasing (STATE : State) :=
     (cu1 STATE) <> (cu2 STATE)
  /\ (addr STATE) <> (cu1 STATE)
  /\ (addr STATE) <> (cu2 STATE)
  /\ (forall (p : address), A.addressIn p (a1 STATE) -> (addr STATE) <> p)
  /\ (forall (p : address), A.addressIn p (a1 STATE) -> (cu1 STATE) <> p)
  /\ (forall (p : address), A.addressIn p (a1 STATE) -> (cu2 STATE) <> p)
  /\ (forall (p : address), B.addressIn p (b1 STATE) -> (addr STATE) <> p)
  /\ (forall (p : address), B.addressIn p (b1 STATE) -> (cu1 STATE) <> p)
  /\ (forall (p : address), B.addressIn p (b1 STATE) -> (cu2 STATE) <> p)
  /\ (forall (p p' : address), A.addressIn p (a1 STATE) -> B.addressIn p' (b1 STATE) -> p <> p')
  /\ A.noAliasing (a1 STATE)
  /\ B.noAliasing (b1 STATE)
.

Definition envStateConstraint (ENV : Env) (STATE : State) :=
  forall (p : address), addressIn p STATE -> NextAddr ENV > p
.

Definition C (ENV : Env) (pa1 : A.State) (pa2 : A.State) :=
let (ENV1, STATE1) := A.A ENV in
let (ENV2, STATE2) := A.A ENV1 in
let (ENV3, STATE3) := A.A ENV2 in
let (ENV4, STATE4) := B.B ENV3 pa1 (A.addr pa2) STATE2 (A.addr STATE3) in
let (ENV5, STATE5) := A.A ENV4 in
let (ENV6, STATE6) := A.A ENV5 in
(NextEnv ENV6, state (NextAddr ENV6) STATE1 STATE4 (A.addr STATE5) (A.addr STATE6)).

Definition initPreconds (ENV : Env) (pa1 : A.State) (pa2 : A.State) :=
     ((A.addr pa1) <> (A.addr pa2))
  /\ ((0 <= (A.addr pa1)) /\ ((A.addr pa1) <= (UINT_MAX 160)))
  /\ ((0 <= (A.addr pa2)) /\ ((A.addr pa2) <= (UINT_MAX 160)))
  /\ A.envStateConstraint ENV pa1
  /\ A.envStateConstraint ENV pa2
.

Definition C_post0 :=
  forall (ENV : Env) (pa1 : A.State) (pa2 : A.State) (STATE' : State),
     initPreconds ENV pa1 pa2
  -> STATE' = snd (C ENV pa1 pa2)
  -> ((0 <= (C.cu1 STATE')) /\ ((C.cu1 STATE') <= (UINT_MAX 160)))
.


Definition C_post1 :=
  forall (ENV : Env) (pa1 : A.State) (pa2 : A.State) (STATE' : State),
     initPreconds ENV pa1 pa2
  -> STATE' = snd (C ENV pa1 pa2)
  -> ((0 <= (C.cu2 STATE')) /\ ((C.cu2 STATE') <= (UINT_MAX 160)))
.


Definition f0_conds (ENV : Env) (pa1 : A.State) (pa2 : A.State) (STATE : State) :=
     ((A.addr pa1) <> (A.addr pa2))
  /\ ((A.addr pa1) <> (A.addr (C.a1 STATE)))
  /\ ((A.addr pa2) <> (A.addr (C.a1 STATE)))
  /\ ((A.addr pa1) <> (B.addr (C.b1 STATE)))
  /\ ((A.addr pa2) <> (B.addr (C.b1 STATE)))
  /\ ((A.addr pa1) <> (A.addr (B.pba (C.b1 STATE))))
  /\ ((A.addr pa2) <> (A.addr (B.pba (C.b1 STATE))))
  /\ ((A.addr pa1) <> (C.cu1 STATE))
  /\ ((A.addr pa2) <> (C.cu1 STATE))
  /\ ((A.addr pa1) <> (C.cu2 STATE))
  /\ ((A.addr pa2) <> (C.cu2 STATE))
  /\ ((0 <= (A.addr pa1)) /\ ((A.addr pa1) <= (UINT_MAX 160)))
  /\ ((0 <= (A.addr pa2)) /\ ((A.addr pa2) <= (UINT_MAX 160)))
  /\ ((0 <= (B.y (C.b1 STATE))) /\ ((B.y (C.b1 STATE)) <= (UINT_MAX 256)))
  /\ ((0 <= (A.x (B.pba (C.b1 STATE)))) /\ ((A.x (B.pba (C.b1 STATE))) <= (UINT_MAX 256)))
  /\ ((0 <= (C.cu1 STATE)) /\ ((C.cu1 STATE) <= (UINT_MAX 160)))
  /\ ((0 <= (C.cu2 STATE)) /\ ((C.cu2 STATE) <= (UINT_MAX 160)))
  /\ True
  /\ envStateConstraint ENV STATE
  /\ A.envStateConstraint ENV pa1
  /\ A.envStateConstraint ENV pa2
.

Definition f0 (ENV : Env) (STATE : State) (pa1 : A.State) (pa2 : A.State) :=
let (ENV1, STATE1) := A.A ENV in
let (ENV2, STATE2) := A.A ENV1 in
let (ENV3, STATE3) := B.B ENV2 pa1 (A.addr pa2) STATE1 (A.addr STATE2) in
(NextEnv ENV3, state (NextAddr ENV3) (C.a1 STATE) (B.state (B.addr STATE3) (B.bu1 STATE3) (B.bu2 STATE3) (B.pba STATE3) (B.y STATE3)) (C.cu1 STATE) (C.cu2 STATE)).

Definition f0_post0 :=
  forall (ENV : Env) (STATE : State) (STATE' : State) (pa1 : A.State) (pa2 : A.State),
     f0_conds ENV pa1 pa2 STATE
  -> STATE' = snd (f0 ENV STATE pa1 pa2)
  -> ((0 <= (B.y (C.b1 STATE'))) /\ ((B.y (C.b1 STATE')) <= (UINT_MAX 256)))
.


Definition f0_post1 :=
  forall (ENV : Env) (STATE : State) (STATE' : State) (pa1 : A.State) (pa2 : A.State),
     f0_conds ENV pa1 pa2 STATE
  -> STATE' = snd (f0 ENV STATE pa1 pa2)
  -> ((0 <= (A.x (B.pba (C.b1 STATE')))) /\ ((A.x (B.pba (C.b1 STATE'))) <= (UINT_MAX 256)))
.

Inductive C_step : State -> State -> Prop :=
| f0_step : forall (ENV : Env) (pa1 : A.State) (pa2 : A.State) (STATE : State),
     f0_conds ENV pa1 pa2 STATE
  -> C_step STATE (snd (f0 ENV STATE pa1 pa2))

.

Inductive extStep : Env -> State -> State -> Prop :=
| extStep_C : forall (ENV : Env) (STATE : State) (STATE' : State),
     C_step STATE STATE'
  -> extStep ENV STATE STATE'

| extStep_a1 : forall (ENV : Env) (STATE : State) (STATE' : State),
     envStateConstraint ENV STATE
  -> A.extStep ENV (a1 STATE) (a1 STATE')
  -> (b1 STATE) = (b1 STATE')
  -> (cu1 STATE) = (cu1 STATE')
  -> (cu2 STATE) = (cu2 STATE')
  -> extStep ENV STATE STATE'

| extStep_b1 : forall (ENV : Env) (STATE : State) (STATE' : State),
     envStateConstraint ENV STATE
  -> B.extStep ENV (b1 STATE) (b1 STATE')
  -> (a1 STATE) = (a1 STATE')
  -> (cu1 STATE) = (cu1 STATE')
  -> (cu2 STATE) = (cu2 STATE')
  -> extStep ENV STATE STATE'

.

Definition step (STATE : State) (STATE' : State) :=
exists (ENV : Env), extStep ENV STATE STATE'.

Inductive init : State ->  Prop :=
| InitState : forall (ENV : Env) (pa1 : A.State) (pa2 : A.State),
     initPreconds ENV pa1 pa2
  -> init (snd (C ENV pa1 pa2))

.

Definition multistep (STATE STATE' : State) :=
multistep step STATE STATE'.

Definition reachable (STATE : State) :=
exists STATE', init STATE' /\ multistep STATE' STATE.

Definition reachableFromInit (ENV : Env) (pa1 : A.State) (pa2 : A.State) (STATE : State) :=
initPreconds ENV pa1 pa2 /\ multistep (snd (C ENV pa1 pa2)) STATE.

Definition invariantInit (IP : Env -> A.State -> A.State -> State -> Prop) :=
  forall (ENV : Env) (pa1 : A.State) (pa2 : A.State),
     initPreconds ENV pa1 pa2
  -> IP ENV pa1 pa2 (snd (C ENV pa1 pa2))
.

Definition invariantStep (IP : Env -> A.State -> A.State -> State -> Prop) :=
  forall (ENV : Env) (pa1 : A.State) (pa2 : A.State) (STATE : State) (STATE' : State),
     initPreconds ENV pa1 pa2
  -> step STATE STATE'
  -> IP ENV pa1 pa2 STATE
  -> IP ENV pa1 pa2 STATE'
.

Lemma invariantReachable :
  forall (ENV : Env) (pa1 : A.State) (pa2 : A.State) (STATE : State) (IP : Env -> A.State -> A.State -> State -> Prop) (HIPinvInit : invariantInit IP) (HIPinvStep : invariantStep IP),
     reachableFromInit ENV pa1 pa2 (STATE : State)
  -> IP ENV pa1 pa2 STATE
.
Proof.
  intros ENV pa1 pa2 STATE IP HIPinvInit HIPinvStep Hreach.
  unfold reachableFromInit in Hreach.
  destruct Hreach as [Hinit Hmulti].
  apply step_multi_step with (P := fun s s' => IP ENV pa1 pa2 s -> IP ENV pa1 pa2 s' ) in Hmulti.
  - apply Hmulti.
    apply HIPinvInit; assumption.
  - intros s s' Hstep.
    apply HIPinvStep with (STATE := s) (STATE' := s') ; assumption.
  - unfold Relation_Definitions.reflexive.
    intros.
    assumption.
  - unfold Relation_Definitions.transitive.
    intros s1 s2 s3 Ht1 Ht2 Ht3.
    apply Ht2, Ht1.
    assumption.

Qed.


End C.
