contract Token

constructor(uint _supply)

creates
    mapping(address => uint) balanceOf :=  [CALLER => _supply]

transition balanceOf(address a) : uint256

returns pre(balanceOf[a])


transition transferFrom(uint256 value, address from, address to) : uint256

iff

  from != to ==> inRange(uint256, balanceOf[to] + value)
  inRange(uint256,balanceOf[from] - value)

case from != to:

  updates

    balanceOf[from]  := balanceOf[from] - value
    balanceOf[to]    := balanceOf[to] + value

  returns 1

case from == to:

  returns 1


contract Amm

constructor(uint256 amt1, uint256 amt2)

creates

    Token token0 := new Token(amt1)
    Token token1 := new Token(amt2)

transition swap0(uint256 amt) : uint256

iff
    CALLVALUE == 0
    inRange(uint256,token0.balanceOf[CALLER] - amt)
    CALLER != THIS ==> inRange(uint256,token0.balanceOf[THIS] + amt)

    inRange(uint256,token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))
    CALLER != THIS ==> inRange(uint256,token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))

    token0.balanceOf[THIS] + amt != 0

case CALLER != THIS:

updates

    token0.balanceOf[CALLER] := token0.balanceOf[CALLER] - amt
    token0.balanceOf[THIS]   := token0.balanceOf[THIS] + amt

    token1.balanceOf[THIS]   := token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
    token1.balanceOf[CALLER] := token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))

returns 1

case CALLER == THIS:

returns 1

ensures

    pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) <= post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS])
    post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS]) <= pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) + pre(token0.balanceOf[THIS]) + amt



transition swap1(uint256 amt) : uint256

iff
    CALLVALUE == 0
    inRange(uint256,token1.balanceOf[CALLER] - amt)
    CALLER != THIS ==> inRange(uint256,token1.balanceOf[THIS] + amt)

    inRange(uint256,token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))
    CALLER != THIS ==> inRange(uint256,token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))

    token1.balanceOf[THIS] + amt != 0

case CALLER != THIS:

updates

    token1.balanceOf[CALLER] := token1.balanceOf[CALLER] - amt
    token1.balanceOf[THIS]   := token1.balanceOf[THIS] + amt

    token0.balanceOf[THIS]   := token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
    token0.balanceOf[CALLER] := token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))

returns 1

case CALLER == THIS:

returns 1

ensures

    pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) <= post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS])
    post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS]) <= pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) + pre(token1.balanceOf[THIS]) + amt
