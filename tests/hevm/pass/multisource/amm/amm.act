contract Amm

constructor(address<Token> t0, address<Token> t1)

iff

    CALLVALUE == 0
    t0 != t1

creates

    Token token0 := t0 
    Token token1 := t1

transition swap0(uint256 amt) : uint256

iff
    CALLVALUE == 0
    inRange(uint256,token0.balanceOf[CALLER] - amt)
    CALLER != THIS ==> inRange(uint256,token0.balanceOf[THIS] + amt)
    CALLER != THIS ==> inRange(uint256,token0.allowance[CALLER][THIS] - amt)

    inRange(uint256,token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))
    CALLER != THIS ==> inRange(uint256,token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt)))

    token0.balanceOf[THIS] + amt != 0

case CALLER != THIS and token0.allowance[CALLER][THIS] == 2^256 - 1:

storage

    token0.balanceOf := token0.balanceOf[ CALLER => token0.balanceOf[CALLER] - amt
                                        , THIS => token0.balanceOf[THIS] + amt]

    token1.balanceOf :=
        token1.balanceOf[ THIS => token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
                        , CALLER => token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))]

returns 1

case CALLER != THIS and token0.allowance[CALLER][THIS] < 2^256 - 1:

storage

    token0.balanceOf[CALLER] := token0.balanceOf[CALLER] - amt
    token0.balanceOf[THIS]   := token0.balanceOf[THIS] + amt
    token0.allowance[CALLER][THIS] := token0.allowance[CALLER][THIS] - amt

    token1.balanceOf[THIS]   := token1.balanceOf[THIS] - ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))
    token1.balanceOf[CALLER] := token1.balanceOf[CALLER] + ((token1.balanceOf[THIS] * amt) / (token0.balanceOf[THIS] + amt))

returns 1

case CALLER == THIS:

storage
returns 1

ensures

    pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) <= post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS])
    post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS]) <= pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) + pre(token0.balanceOf[THIS]) + amt


transition swap1(uint256 amt) : uint256

iff
    CALLVALUE == 0
    inRange(uint256,token1.balanceOf[CALLER] - amt)
    CALLER != THIS ==> inRange(uint256,token1.balanceOf[THIS] + amt)
    CALLER != THIS ==> inRange(uint256,token1.allowance[CALLER][THIS] - amt)

    inRange(uint256,token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))
    CALLER != THIS ==> inRange(uint256,token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt)))

    token1.balanceOf[THIS] + amt != 0

case CALLER != THIS and token1.allowance[CALLER][THIS] == 2^256 - 1:

storage

    token1.balanceOf[CALLER] := token1.balanceOf[CALLER] - amt
    token1.balanceOf[THIS]   := token1.balanceOf[THIS] + amt

    token0.balanceOf[THIS]   := token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
    token0.balanceOf[CALLER] := token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))

returns 1

case CALLER != THIS and token1.allowance[CALLER][THIS] < 2^256 - 1:

storage

    token1.balanceOf[CALLER] := token1.balanceOf[CALLER] - amt
    token1.balanceOf[THIS]   := token1.balanceOf[THIS] + amt
    token1.allowance[CALLER][THIS] := token1.allowance[CALLER][THIS] - amt

    token0.balanceOf[THIS]   := token0.balanceOf[THIS] - ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))
    token0.balanceOf[CALLER] := token0.balanceOf[CALLER] + ((token0.balanceOf[THIS] * amt) / (token1.balanceOf[THIS] + amt))

returns 1

case CALLER == THIS:

returns 1

ensures

    pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) <= post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS])
    post(token0.balanceOf[THIS]) * post(token1.balanceOf[THIS]) <= pre(token0.balanceOf[THIS]) * pre(token1.balanceOf[THIS]) + pre(token1.balanceOf[THIS]) + amt
