contract Token

constructor(uint _supply)

creates
    mapping(address => uint) balanceOf :=  [CALLER => _supply]

transition balanceOf(address a) : uint256

updates
returns balanceOf[a]


transition transfer(address to, uint256 _value) : uint256

iff

  CALLER != to ==> inRange(uint256, balanceOf[to] + _value)
  inRange(uint256,balanceOf[CALLER] - _value)

case CALLER != to:

  updates

    balanceOf := balanceOf [ CALLER => balanceOf[CALLER] - _value
                           , to => balanceOf[to] + _value]

  returns 1

case CALLER == to:

  updates
  returns 1


contract TransferOneToken

constructor(address<Token> _tokenAddress)

iff

    address(_tokenAddress) != 0

creates

    Token token := _tokenAddress

transition transfer() : uint256

iff
    THIS != CALLER ==> inRange(uint256, token.balanceOf[CALLER] + 1)
    inRange(uint256,token.balanceOf[THIS] - 1)

case CALLER != THIS:

updates

    token.balanceOf := token.balanceOf[ CALLER => token.balanceOf[CALLER] + 1
                                      , THIS => token.balanceOf[THIS] - 1 ]

returns 1

case CALLER == THIS:

updates
returns 1
