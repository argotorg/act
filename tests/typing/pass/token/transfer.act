contract Token

constructor(string _symbol, string _name, string _version, uint _totalSupply)

creates

  string name         := _name
  string symbol       := _symbol
  uint256 totalSupply := _totalSupply
  mapping(address => uint) balanceOf :=  [CALLER => _totalSupply]
  mapping(address=>mapping(address=>uint)) allowance := []

invariants

  totalSupply == _totalSupply
  name == _name
  symbol == _symbol


transition transfer(uint256 value, address to) : uint256

iff

  CALLVALUE == 0
  value <= balanceOf[CALLER]
  CALLER != to ==> balanceOf[to] + value < 2^256

case CALLER != to:

  storage

    balanceOf := balanceOf[CALLER => balanceOf[CALLER] - value, to => balanceOf[to] + value]

  returns 1

case CALLER == to:
  storage

  returns 1


transition transferFrom(address src, address dst, uint amount) : uint256

iff

  amount <= balanceOf[src]
  src    != dst ==> balanceOf[dst] + amount < 2^256
  CALLER != src ==> 0 <= allowance[src][CALLER] - amount
  CALLVALUE == 0

case src != dst and CALLER == src:

  storage

     balanceOf := balanceOf[ src => balanceOf[src] - amount
                           , dst => balanceOf[dst] + amount ]

  returns 1

case src != dst and CALLER != src and allowance[src][CALLER] == 2^256 - 1:

  storage

     balanceOf := balanceOf[ src => balanceOf[src] - amount
                           , dst => balanceOf[dst] + amount ]

  returns 1

case src != dst and CALLER != src and allowance[src][CALLER] < 2^256 - 1:

  storage

    allowance := allowance[ src => allowance[src][CALLER => allowance[src][CALLER] - amount ]]
    balanceOf := balanceOf[ src => balanceOf[src] - amount
                          , dst => balanceOf[dst] + amount ]

  returns 1

case src == dst:

  storage

  returns 1
